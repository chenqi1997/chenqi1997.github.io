<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面经,基础知识,C++,">










<meta name="description" content="后台开发知识点汇总 C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件锁(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 在条件变量中只能使用std::unique_lock&amp;lt; std::mut">
<meta name="keywords" content="面经,基础知识,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="后台开发知识点汇总">
<meta property="og:url" content="http://chenqi1997.github.io/2020/11/17/后台开发知识点汇总/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="后台开发知识点汇总 C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件锁(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 在条件变量中只能使用std::unique_lock&amp;lt; std::mut">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20180520012305597">
<meta property="og:image" content="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg">
<meta property="og:image" content="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg">
<meta property="og:image" content="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215306696">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215332079">
<meta property="og:image" content="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg">
<meta property="og:image" content="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcjvgSoF3zeGINoyibX5tpfgfQwBABm2KMEnohSmkRXjzicCuQtt4IWsc9fniahl1mW39gS674icZibqibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png">
<meta property="og:image" content="https://img-blog.csdn.net/20171123102431734">
<meta property="og:updated_time" content="2020-12-15T06:41:13.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="后台开发知识点汇总">
<meta name="twitter:description" content="后台开发知识点汇总 C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件锁(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 在条件变量中只能使用std::unique_lock&amp;lt; std::mut">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/11/17/后台开发知识点汇总/">





  <title>后台开发知识点汇总 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/11/17/后台开发知识点汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">后台开发知识点汇总</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-17T17:46:00+08:00">
                2020-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面经/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#后台开发知识点汇总">后台开发知识点汇总</a><ul>
<li><a href="#c基础">C++基础</a><ul>
<li><a href="#c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</a><ul>
<li><a href="#互斥锁mutex">互斥锁(Mutex)</a></li>
<li><a href="#条件锁condition_variable">条件锁(condition_variable)</a></li>
<li><a href="#自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</a></li>
<li><a href="#读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</a></li>
<li><a href="#递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</a></li>
<li><a href="#定时锁time_mutex">定时锁(time_mutex)</a></li>
<li><a href="#两种基本的锁类型">两种基本的锁类型</a><ul>
<li><a href="#在条件变量中只能使用stdunique_lock-stdmutex-说明"><strong>在条件变量中只能使用std::unique_lock&lt; std::mutex &gt; 说明</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c中thread操作">C++中thread操作</a><ul>
<li><a href="#stdthread构造">std::thread构造</a></li>
<li><a href="#join">join()</a></li>
<li><a href="#detach">detach()</a></li>
<li><a href="#wait成员函数">wait()成员函数</a></li>
<li><a href="#wait_for成员函数">wait_for()成员函数</a></li>
<li><a href="#notify_allnotify_one"><strong>notify_all/notify_one</strong></a></li>
<li><a href="#虚假唤醒">虚假唤醒</a></li>
</ul>
</li>
<li><a href="#c多态">C++多态</a><ul>
<li><a href="#多态有哪几种">多态有哪几种？</a></li>
<li><a href="#虚函数的实现">虚函数的实现</a></li>
<li><a href="#动态绑定">动态绑定</a></li>
<li><a href="#为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</a></li>
<li><a href="#为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</a></li>
<li><a href="#为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</a></li>
<li><a href="#静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</a></li>
<li><a href="#友元可以继承吗">友元可以继承吗？</a></li>
<li><a href="#多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</a></li>
<li><a href="#类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</a></li>
<li><a href="#钻石继承问题">钻石继承问题</a></li>
</ul>
</li>
<li><a href="#c的四种cast">C++的四种cast</a><ul>
<li><a href="#static_cast">static_cast</a></li>
<li><a href="#const_cast">const_cast</a></li>
<li><a href="#reinterpret_cast">reinterpret_cast</a></li>
<li><a href="#dynamic_cast">dynamic_cast</a></li>
<li><a href="#哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</a></li>
</ul>
</li>
<li><a href="#c智能指针">C++智能指针</a><ul>
<li><a href="#auto_ptr弃用">auto_ptr(弃用)</a></li>
<li><a href="#unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
<li><a href="#weak_ptr">weak_ptr</a></li>
<li><a href="#智能指针是线程安全的吗">智能指针是线程安全的吗？</a></li>
</ul>
</li>
<li><a href="#c对象的内存模型">C++对象的内存模型</a><ul>
<li><a href="#普通对象模型">普通对象模型</a></li>
<li><a href="#派生类的对象模型">派生类的对象模型</a></li>
<li><a href="#vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</a></li>
</ul>
</li>
<li><a href="#volitale关键字">Volitale关键字</a><ul>
<li><a href="#volatile指针">volatile指针</a></li>
<li><a href="#可见性">可见性</a><ul>
<li><a href="#什么是可见性">什么是可见性？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c中指针和引用的区别">C++中指针和引用的区别</a></li>
<li><a href="#c中new与malloc的区别">C++中new与malloc的区别</a></li>
<li><a href="#c-内存对齐">C++ 内存对齐</a></li>
<li><a href="#c存储类型">C++存储类型</a><ul>
<li><a href="#auto-自动变量">auto 自动变量</a></li>
<li><a href="#register-寄存器变量">register 寄存器变量</a></li>
<li><a href="#static-关键字">static 关键字</a></li>
<li><a href="#extern关键字">extern关键字</a></li>
<li><a href="#mutable-存储类">mutable 存储类</a></li>
<li><a href="#thread_local-存储类">thread_local 存储类</a></li>
</ul>
</li>
<li><a href="#stdmove语义">std::move()语义</a></li>
<li><a href="#右值引用">右值引用</a><ul>
<li><a href="#左值引用">左值引用</a></li>
<li><a href="#右值引用-1">右值引用</a></li>
<li><a href="#右值引用有办法指向左值吗">右值引用有办法指向左值吗</a></li>
<li><a href="#完美转发-stdforward">完美转发 std::forward()</a></li>
<li><a href="#auto也是这个意思">auto&amp;&amp;也是这个意思</a></li>
</ul>
</li>
<li><a href="#c内联函数">C++内联函数</a><ul>
<li><a href="#内联函数有什么优点">内联函数有什么优点？</a></li>
<li><a href="#将内联函数放入头文件">将内联函数放入头文件</a></li>
<li><a href="#内联函数与宏定义的区别">内联函数与宏定义的区别？</a></li>
</ul>
</li>
<li><a href="#深拷贝与浅拷贝">深拷贝与浅拷贝</a></li>
<li><a href="#必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</a></li>
<li><a href="#定位内存泄露及检测">定位内存泄露及检测</a></li>
<li><a href="#手写strcpymemcpystrcatstrcmp等函数"><strong>手写strcpy，memcpy，strcat，strcmp等函数</strong></a><ul>
<li><a href="#strcpy">strcpy</a></li>
<li><a href="#memcpy">memcpy</a></li>
<li><a href="#strlen">strlen</a></li>
<li><a href="#strcat">strcat</a></li>
<li><a href="#strcmp">strcmp</a></li>
</ul>
</li>
<li><a href="#memmove">memmove</a></li>
<li><a href="#三个线程交替打印">三个线程交替打印</a></li>
<li><a href="#类模板和模板类的区别">类模板和模板类的区别？</a></li>
<li><a href="#海量数据问题">海量数据问题</a><ul>
<li><a href="#十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</a></li>
<li><a href="#十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</a></li>
</ul>
</li>
<li><a href="#布隆过滤器">布隆过滤器</a><ul>
<li><a href="#几十亿个数经常要查找某一个数在不在里面">几十亿个数经常要查找某一个数在不在里面</a></li>
<li><a href="#布隆过滤器的原理">布隆过滤器的原理。</a></li>
<li><a href="#布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</a></li>
</ul>
</li>
<li><a href="#stl">STL</a><ul>
<li><a href="#hash-map冲突如何解决">Hash Map冲突如何解决？</a><ul>
<li><a href="#哈希函数">哈希函数</a></li>
<li><a href="#哈希冲突解决方案">哈希冲突解决方案</a></li>
</ul>
</li>
<li><a href="#hash_map扩容发生什么">Hash_map扩容发生什么</a></li>
<li><a href="#unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</a><ul>
<li><a href="#map与unordered_map的区别">map与unordered_map的区别</a></li>
<li><a href="#为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？<strong>红黑树查询效率为什么快？</strong></a></li>
</ul>
</li>
<li><a href="#vector相关">vector相关</a><ul>
<li><a href="#vector空间的动态增长">vector空间的动态增长</a></li>
<li><a href="#vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</a></li>
</ul>
</li>
<li><a href="#stl里的内存池实现">STL里的内存池实现</a><ul>
<li><a href="#内存的分配和回收">内存的分配和回收</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</a></li>
<li><a href="#进程和线程的区别和联系">⭐进程和线程的区别和联系</a></li>
<li><a href="#多进程和多线程的区别">多进程和多线程的区别？</a><ul>
<li><a href="#优劣">优劣</a></li>
</ul>
</li>
<li><a href="#临界区进程同步">临界区(进程同步)</a></li>
<li><a href="#原子操作">原子操作</a><ul>
<li><a href="#cas原子操作compare-and-swap">CAS原子操作(compare and swap)</a></li>
</ul>
</li>
<li><a href="#进程间如何通信">进程间如何通信？</a><ul>
<li><a href="#应用场景">应用场景</a></li>
<li><a href="#管道">管道</a><ul>
<li><a href="#无名管道pipe">无名管道(pipe)</a></li>
<li><a href="#有名管道fifo">有名管道(FIFO)</a></li>
</ul>
</li>
<li><a href="#信号signal">信号(signal)</a></li>
<li><a href="#消息队列message-queue">消息队列(message queue)</a></li>
<li><a href="#共享内存shared-memory">共享内存(shared memory)</a></li>
<li><a href="#信号量semophore">信号量(semophore )</a><ul>
<li><a href="#信号量工作原理">信号量工作原理</a></li>
</ul>
</li>
<li><a href="#套接字socket">套接字(socket)</a></li>
</ul>
</li>
<li><a href="#多线程间通信和同步">多线程间通信和同步</a></li>
<li><a href="#协程">⭐协程</a><ul>
<li><a href="#libco库">libco库</a></li>
</ul>
</li>
<li><a href="#五种io模型">五种IO模型</a></li>
<li><a href="#io多路复用selectpollepoll">⭐IO多路复用：select/poll/epoll</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a><ul>
<li><a href="#epoll-函数">epoll 函数</a></li>
<li><a href="#工作模式">工作模式</a></li>
<li><a href="#epoll的优点">epoll的优点：</a></li>
<li><a href="#边缘触发的io应该怎么写">边缘触发的IO应该怎么写？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#缺页中断">缺页中断</a></li>
<li><a href="#银行家算法防止死锁">银行家算法：防止死锁</a></li>
</ul>
</li>
<li><a href="#计算机网络">计算机网络</a><ul>
<li><a href="#tcpip">TCP/IP</a><ul>
<li><a href="#udp和tcp的差别">⭐UDP和TCP的差别</a></li>
<li><a href="#计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</a><ul>
<li><a href="#地址解析协议-arp">地址解析协议 ARP</a></li>
</ul>
</li>
<li><a href="#三次握手四次挥手">三次握手四次挥手</a></li>
<li><a href="#get和post的区别">get和post的区别</a></li>
<li><a href="#tcp三次握手如果第三次客户端发出的信息服务器没收到怎么办">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</a></li>
</ul>
</li>
<li><a href="#http">HTTP</a><ul>
<li><a href="#http状态码">HTTP状态码</a></li>
<li><a href="#https的通信过程">⭐HTTPS的通信过程</a></li>
<li><a href="#getpost-区别">get/post 区别</a></li>
<li><a href="#httphttps-10-11-20的特点和区别">http/https 1.0、1.1、2.0的特点和区别</a></li>
<li><a href="#从浏览器输入网址到出现页面经过了哪些阶段">从浏览器输入网址到出现页面经过了哪些阶段</a></li>
</ul>
</li>
<li><a href="#cache的结构与工作原理">Cache的结构与工作原理</a></li>
</ul>
</li>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#mysql相关">Mysql相关</a></li>
</ul>
</li>
<li><a href="#其他">其他</a><ul>
<li><a href="#从两个文件各含50亿个url中找出共同的url">从两个文件(各含50亿个url)中找出共同的url</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h1><span id="后台开发知识点汇总">后台开发知识点汇总</span></h1><h2><span id="c基础">C++基础</span></h2><h3><span id="c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</span></h3><p>C++线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong> 这几种</p>
<h4><span id="互斥锁mutex">互斥锁(Mutex)</span></h4><p>互斥锁用于<strong>控制多个线程对他们之间共享资源互斥访问的一个信号量</strong>。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。</p>
<p>在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以<strong>阻塞方式</strong>进行等待。</p>
<p><strong>互斥锁是是一种sleep-waiting的锁</strong>。假设线程 <code>T1</code> 获取互斥锁并且正在 <code>core1</code> 上运行时，此时线程 <code>T2</code> 也想要获取互斥锁 (pthread_mutex_lock)，但是由于 <code>T1</code> 正在使用互斥锁使得 <code>T2</code> 被阻塞。当 <code>T2</code> 处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器 <code>core2</code> 会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p>
<p><strong>用法：</strong>在C++中，通过构造 <code>std::mutex</code> 的实例创建互斥元，调用成员函数 <code>lock()</code> 来锁定它，调用 <code>unlock()</code> 来解锁，不过一般不推荐这种做法，标准C++库提供了std::lock_guard类模板，实现了互斥元的 <code>RAII</code> 惯用语法。<code>std::mutex</code> 和 <code>std::lock_guard</code> 。都声明在 <code>&lt;mutex&gt;</code> 头文件中。</p>
<p><code>lock_guard</code> 对象通常用于管理某个锁(Lock)对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用互斥元保护列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list;</span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(some_mutex);</span><br><span class="line">    some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="条件锁condition_variable">条件锁(condition_variable)</span></h4><p>条件锁就是所谓的条件变量，某一个线程因为某个条件<strong>未满足</strong>时可以使用 <code>条件锁</code> 使该程序处于 <code>阻塞状态</code> 。</p>
<p>一旦条件满足，可以以 <code>信号量</code> 的方式唤醒一个因为该条件而被阻塞的线程。</p>
<p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为 <code>任务队列为空</code> 这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用std::condition_variable等待数据</span></span><br><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);   <span class="comment">//这里使用unique_lock是为了后面方便解锁</span></span><br><span class="line">        data_cond.wait(lk,&#123;[]<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面，<code>wait()</code> 的实现接下来检查条件，并在满足时返回。如果条件不满足，wait()解锁互斥元，并将该线程置于阻塞或等待状态。当来自数据准备线程中对 <code>notify_one()</code> 的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从wait()返回值，互斥元仍被锁定。如果条件不满足，该线程解锁互斥元，并恢复等待。</p>
<hr>
<h4><span id="自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</span></h4><p><em>自旋锁需要与互斥锁一起来比较理解。</em></p>
<p><strong>自旋锁是一种busy-waiting的锁</strong>。也就是说，如果 <code>T1</code> 正在使用自旋锁，而 <code>T2</code> 也去申请这个自旋锁，此时 <code>T2</code> 肯定得不到这个自旋锁。与互斥锁相反的是，此时运行 <code>T2</code> 的处理器 <code>core2</code> 会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p>
<p>从 <code>自旋锁</code> 的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一直占用 <code>CPU</code> 请求这个自旋锁使得 <code>CPU</code> 不能去做其他的事情，直到获取这个锁为止，这就是 <code>自旋</code> 的含义。</p>
<p>当发生阻塞时，互斥锁可以让 <code>CPU</code> 去处理其他的任务；而自旋锁让 <code>CPU</code> 一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道 <code>自旋锁</code> 是比较耗费 <code>CPU</code> 的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(<span class="keyword">spinlock_t</span> *x);<span class="comment">//初始化</span></span><br><span class="line">spin_lock(x);   			  <span class="comment">//只有在获得锁的情况下才返回，否则一直“自旋”</span></span><br><span class="line">spin_trylock(x);  			  <span class="comment">//如立即获得锁则返回真，否则立即返回假</span></span><br><span class="line">spin_unlock(x);				  <span class="comment">//释放锁</span></span><br><span class="line">spin_is_locked(x)			  <span class="comment">//该宏用于判断自旋锁x是否已经被某执行单元保持（即被锁），如果是，   返回真，否则返回假。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</span></h4><p><code>std::shared_mutex</code>有两种访问级别：</p>
<ul>
<li><strong>共享：</strong>多个线程可以共享这个锁的拥有权。一般用于数据的<strong>读操作</strong>，防止数据被写修改。</li>
<li><p><strong>互斥：</strong>仅仅一个线程可以拥有这个锁。一般用于<strong>写操作</strong>。</p>
</li>
<li><p>如果一个线程已经获取了 <code>互斥锁</code> ，则其他线程都无法获取该锁。</p>
</li>
<li>如果一个线程已经获取了 <code>共享锁</code> ，则其他任何线程都无法获取 <code>互斥锁</code> ，但是可以获取 <code>共享锁</code> 。</li>
</ul>
<hr>
<h4><span id="递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</span></h4><p>我们都知道，一般的互斥量对于同一个线程只能同时加锁一次（调用 <code>lock</code> ），如果连续调用两次以上便会出现死锁。但设想这样一个场景，如果在一个函数内给互斥量上了锁还没有解开，然后又调用了另一个函数，这个被调用的函数也去给互斥量上锁，这种情境下就会出现死锁。</p>
<p>对于互斥锁，分为递归锁和非递归锁。在不同的线程中调用已锁定的互斥锁，必然会导致死锁。但是在<strong>同一个线程中，如果想要多次获得一个锁，只能使用递归锁</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MutexLock mutex;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    mutex.unlock();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    foo();  </span><br><span class="line">    mutex.unlock();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，引入了递归锁的概念。</p>
<p><strong>递归锁</strong>，顾名思义，<strong>如果因为多次函数调用而导致出现多次上锁的情况，只有第一次会去真正加锁，后面的加锁操作会被自动忽略。</strong></p>
<p><strong>recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁）</strong>，来获得对互斥量对象的<strong>多层所有权</strong>，<code>recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和 <code>unlock()</code> 次数相同，除此之外，<code>recursive_mutex</code> 的特性和<code>mutex</code> 大致相同。</p>
<hr>
<h4><span id="定时锁time_mutex">定时锁(time_mutex)</span></h4><p><code>std::time_mutex</code> 比 <code>std::mutex</code> 多了两个成员函数，<code>try_lock_for()</code> ，<code>try_lock_until()</code> 。</p>
<p><strong>try_lock_for</strong> 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 <code>std::mutex</code> 的 <code>try_lock()</code> 不同，<code>try_lock</code> 如果被调用时没有获得锁则直接返回 <code>false</code>），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code>。</p>
<p><strong>try_lock_until</strong> 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code> 。</p>
<hr>
<h4><span id="两种基本的锁类型">两种基本的锁类型</span></h4><p>C++11 标准为我们提供了两种基本的锁类型，分别如下：</p>
<ul>
<li><strong>std::lock_guard</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁。<ul>
<li><strong>lock_guard</strong> 对象通常用于管理某个锁( <code>Lock</code> )对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源 )。</li>
<li>在 <code>lock_guard</code> 对象构造时，传入的 <code>Mutex</code> 对象(即它所管理的 <code>Mutex</code> 对象)会被<strong>当前线程</strong>锁住。在<code>lock_guard</code> 对象被析构时，它所管理的 <code>Mutex</code> 对象会自动解锁，由于不需要程序员手动调用 <code>lock</code> 和 <code>unlock</code> 对 <code>Mutex</code> 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 <code>Mutex</code> 对象可以正确进行解锁操作，极大地简化了程序员编写与 <code>Mutex</code> 相关的异常处理代码。</li>
<li>值得注意的是，<code>lock_guard</code> 对象并不负责管理 <code>Mutex</code> 对象的生命周期，<code>lock_guard</code> 对象只是简化了 <code>Mutex</code> 对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁。</li>
</ul>
</li>
<li><strong>std::unique_lock</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。<ul>
<li><strong>unique_lock</strong> 提供了更好的上锁和解锁控制。顾名思义，<code>unique_lock</code> 对象以独占所有权的方式(unique owership)管理 <code>mutex</code> 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权。</li>
<li>在构造(或移动(move)赋值)时，<code>unique_lock</code> 对象需要传递一个 <code>Mutex</code> 对象作为它的参数，新创建的 <code>unique_lock</code> 对象负责传入的 <code>Mutex</code> 对象的上锁和解锁操作。</li>
</ul>
</li>
</ul>
<h5><span id="在条件变量中只能使用stdunique_locklt-stdmutex-gt-说明"><strong>在条件变量中只能使用std::unique_lock&lt; std::mutex &gt; 说明</strong></span></h5><p><code>unique_lock</code> 和 <code>lock_guard</code> 都是管理锁的辅助类工具，都是 <code>RAII(资源定义即初始化)</code> 风格；它们是在定义时获得锁，在析构时释放锁。它们的主要区别在于 <code>unique_lock</code> 锁机制更加灵活，可以再需要的时候进行 <code>lock</code> 或者 <code>unlock</code> 调用，不非得是析构或者构造时。它们的区别可以通过成员函数就可以一目了然。</p>
<hr>
<h3><span id="c中thread操作">C++中thread操作</span></h3><h4><span id="stdthread构造">std::thread构造</span></h4><table>
<thead>
<tr>
<th>default (1)</th>
<th>thread() noexcept;</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialization (2)</td>
<td>template <class fn,="" class...="" args=""> explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;… args);</class></td>
</tr>
<tr>
<td>copy [deleted] (3)</td>
<td>thread (const thread&amp;) = delete;</td>
</tr>
<tr>
<td>move (4)</td>
<td>thread (thread&amp;&amp; x) noexcept;</td>
</tr>
</tbody>
</table>
<ol>
<li>默认构造函数，创建一个空的 thread 执行对象。</li>
<li>初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</li>
<li>拷贝构造函数(被禁用)，意味着 <strong>thread 不可被拷贝构造</strong>。只能用<strong>右值引用配合move赋值操作</strong>。</li>
<li>move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。</li>
</ol>
<p>注意：可被 <code>joinable</code> 的 <code>thread</code> 对象必须在他们销毁之前被主线程 <code>join</code> 或者将其设置为 <code>detached</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(<span class="built_in">std</span>::move(t3))</span></span>; <span class="comment">// t4 is now running f2(). t3 is no longer a thread</span></span><br></pre></td></tr></table></figure>
<h4><span id="join">join()</span></h4><ul>
<li><p>阻塞当前线程，直至 <code>this</code> 所标识的线程完成其执行。<code>this</code> 所标识的线程的完成同步于从 <strong>join()</strong> 的成功返回。</p>
</li>
<li><p>该方法简单暴力，主线程等待子进程期间什么都不能做。<code>thread::join()</code> 会清理子线程相关的内存空间，此后<code>thread object</code> 将不再和这个子线程相关了，即 <code>thread object</code> 不再 <code>joinable</code> 了，所以 <code>join</code> 对于一个子线程来说只可以被调用一次，为了实现更精细的线程等待机制，可以使用条件变量等机制。</p>
</li>
</ul>
<h4><span id="detach">detach()</span></h4><ul>
<li>从调用线程中分离出对象所代表的线程，从而使它们彼此独立执行。两个线程继续运行，而不会阻塞或以任何方式进行同步。</li>
<li>请注意，当任何一个执行结束时，其资源将被释放。</li>
<li>调用此函数后，线程对象变得不可连接，并且可以安全地销毁。</li>
</ul>
<h4><span id="wait成员函数">wait()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock )</span></span>;</span><br><span class="line"><span class="comment">//Predicate 谓词函数，可以普通函数或者lambda表达式</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );</span><br></pre></td></tr></table></figure>
<p><code>wait</code>  导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，可选地循环<strong>直至满足某谓词</strong>。</p>
<h4><span id="wait_for成员函数">wait_for()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function">cv_status <span class="title">wait_for</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span>, <span class="title">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">wait_for</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span><br><span class="line">               <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span><br><span class="line">               Predicate pred);</span><br></pre></td></tr></table></figure>
<p><code>wait_for</code> 导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，或者<strong>超时返回</strong>。</p>
<p>以上两个类型的<strong>wait函数都在会阻塞时，自动释放锁权限，即调用unique_lock的成员函数unlock（），以便其他线程能有机会获得锁</strong>。这就是条件变量只能和 <code>unique_lock</code> 一起使用的原因，否则当前线程一直占有锁，线程被阻塞。</p>
<h4><span id="notify_allnotify_one"><strong>notify_all/notify_one</strong></span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则解阻塞（唤醒)全部等待线程。</span></span><br></pre></td></tr></table></figure>
<h4><span id="虚假唤醒">虚假唤醒</span></h4><p>在正常情况下，<code>wait</code> 类型函数返回时要不是因为被唤醒，要不是因为超时才返回，但是在实际中发现，因此操作系统的原因，<code>wait</code> 类型在不满足条件时，它也会返回，这就导致了虚假唤醒。因此，我们一般都是使用带有谓词参数的 <code>wait</code> 函数，因为这种<code>(xxx, Predicate pred )</code>类型的函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!(xxx条件) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//虚假唤醒发生，由于while循环，再次检查条件是否满足，</span></span><br><span class="line">    <span class="comment">//否则继续等待，解决虚假唤醒</span></span><br><span class="line">    wait();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c多态">C++多态</span></h3><p><strong>封装，继承，多态是面向对象设计的三个特征</strong>，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。</p>
<h4><span id="多态有哪几种">多态有哪几种？</span></h4><p>多态是面向对象的重要特性之一，它是一种行为的封装，是同一种事物所表现出的多种形态，简单地说是”一个接口多种实现“。多态的实现主要分为<strong>静态多态</strong>和<strong>动态多态</strong>：</p>
<ul>
<li><p>静态多态主要是<strong>重载</strong>，在编译的时候就已经确定。</p>
<ul>
<li><strong>函数重载</strong></li>
<li><strong>运算符重载</strong></li>
<li><strong>模板</strong></li>
</ul>
</li>
<li><p>动态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。</p>
</li>
</ul>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，<strong>在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数</strong>。在子类中重新定义父类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<hr>
<h4><span id="虚函数的实现">虚函数的实现</span></h4><p>在有虚函数的类中，<strong>类的最开始部分是一个虚函数表的指针</strong>，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在 <code>代码段(.text)</code> 中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<p>虚表是一个<strong>指针数组</strong>，其元素是<strong>虚函数的指针</strong>，每个元素对应一个<strong>虚函数的函数指针</strong>。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。虚表内的条目，即<strong>虚函数指针的赋值发生在编译器的编译阶段</strong>，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<p>虚表是<strong>属于类</strong>的，而不是属于某个具体的对象，<strong>一个类只需要一个虚表</strong>即可。<strong>同一个类的所有对象都使用同一个虚表。</strong></p>
<p>⭐<code>Linux</code> 下虚表存储位置在<strong>只读数据段中(rodata)</strong>，<code>windows</code> 是在存储位置应该是<strong>常量区域。</strong> </p>
<p>为了指定对象的虚表，对象内部包含一个<strong>虚表的指针</strong>，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>void** __vfptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg" alt="img"></p>
<hr>
<h4><span id="动态绑定">动态绑定</span></h4><p>如果将基类的成员函数声明为 <code>virtual</code> 的，然后用<strong>指向派生类对象的基类指针或者引用</strong>来<strong>调用该成员函数</strong>，那么程序会<strong>在运行时选择该派生类的函数而不是基类的函数</strong>，这种特性成为<strong>运行时绑定</strong>（<strong>动态绑定</strong>、<strong>晚绑定</strong>）。</p>
<p>派生类虚函数要达成运行时动态绑定的效果，必须和基类的函数名、参数列表完全相同，否则仅仅是对基类虚函数的<strong>隐藏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类 <code>A</code> 是基类，类 <code>B</code> 继承类 <code>A</code> ，类 <code>C</code> 又继承类 <code>B</code> 。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> ，其对象模型如下图所示。由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（<code>A vtbl</code>），类B的虚表（<code>B vtbl</code>），类C的虚表（<code>C vtbl</code>）。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> 对象都拥有一个虚表指针<code>*__vptr</code>，用来指向自己所属类的虚表。</p>
<p><strong>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</strong>。</p>
<p><strong>生成子类虚表的过程：</strong></p>
<ol>
<li>将父类虚表内容拷贝到子类虚表上。</li>
<li>将子类重写的虚函数覆盖掉表中父类的虚函数。</li>
<li>如果子类有新增加的虚函数,按声明次序加到最后。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg" alt="img"></p>
<p>我们把经过虚表调用虚函数的过程称为<strong>动态绑定</strong>，其表现出来的现象称为<strong>运行时多态</strong>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为<strong>静态绑定</strong>，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p>
<ol>
<li>通过<strong>指针或引用</strong>来调用函数</li>
<li>指针<strong>upcast</strong>向上转型（继承类向基类的转换称为 <code>upcast</code> ）</li>
<li>调用的是虚函数</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<hr>
<h4><span id="为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</span></h4><p>将<strong>可能会被继承的父类</strong>的析构函数设置为虚函数，可以保证当我们 <code>new</code> 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<hr>
<h4><span id="为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</span></h4><p>C++默认的析构函数不是虚函数是因为虚函数<strong>需要额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是<strong>只有当需要当作父类时，设置为虚函数。</strong></p>
<hr>
<h4><span id="为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</span></h4><p>1.<strong>从存储空间角度：</strong> 虚函数对应一个 <code>vtable</code> ，这个 <code>vtable</code> 其实是存储在<strong>对象的内存空间</strong>的。问题出来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到<code>vtable</code> ，所以构造函数不能是虚函数。<br><strong>2，从使用角度：</strong> 构造函数本身就是要<strong>初始化实例</strong>，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。<strong>虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数</strong>。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。<br><strong>3、构造函数不需要是虚函数，也不允许是虚函数：</strong>因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过基类的指针或引用去访问它。<br><strong>4、从实现上看，</strong><code>vtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数。</p>
<hr>
<h4><span id="静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</span></h4><p>⭐<strong>静态数据成员和静态成员函数可以被继承！</strong>具体如下：</p>
<ol>
<li>父类的 <code>static</code> 变量和函数在派生类中依然可用，但是<strong>受访问性控制</strong>（比如，父类的 <code>private</code> 域中的就不可访问），而且对 <code>static</code> 变量来说，派生类和父类中的 <code>static</code> 变量是<strong>共用空间</strong>的，这点在利用 <code>static</code> 变量进行引用计数的时候要特别注意。</li>
<li><code>static</code> 函数没有“虚函数”一说。因为 <code>static</code> 函数实际上是<strong>加上了访问控制的全局函数</strong>，全局函数哪来的什么虚函数的概念？</li>
<li>派生类的 <code>friend</code> 函数可以访问派生类本身的一切变量，包括从父类继承下来的 <code>protected</code> 域中的变量。但是对父类来说，他并不是 <code>friend</code> 的。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。所以 <code>static</code> 成员的这种应该算是继承。</li>
</ol>
<hr>
<h4><span id="友元可以继承吗">友元可以继承吗？</span></h4><p>⭐<strong>不能！</strong></p>
<p>友元只是能访问<strong>指定类的私有和保护成员的自定义函数</strong>，<strong>不是被指定类的成员</strong>，自然不能继承。 使用友元类时注意：</p>
<ol>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>A</code> 不一定是类 <code>B</code> 的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>C</code> 是 <code>B</code> 的友元，类 <code>C</code> 不一定是类 <code>A</code> 的友元，同样要看类中是否有相应的声明。</li>
</ol>
<hr>
<h4><span id="多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</span></h4><ol>
<li>基类对象首先被创建。</li>
<li>派生类构造函数应通过<strong>成员初始化列表</strong>（<strong>调用顺序和继承顺序相关</strong>）将基类信息传递给基类构造函数 ，可以使用初始化列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。</li>
<li>派生类构造函数<strong>应初始化派生类新增的数据成员</strong>。派生类对象析构时，程序<strong>首先调用派生类析构函数，再调用基类析构函数。</strong></li>
</ol>
<hr>
<h4><span id="类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</span></h4><ul>
<li><strong>函数重载：重载函数通常用来命名一组 <code>功能相似</code> 的函数</strong><ul>
<li>函数要在 <code>相同的类域</code></li>
<li>函数的 <code>名字要相同</code> </li>
<li>函数的 <code>参数列表或返回值不同</code> </li>
</ul>
</li>
<li><strong>函数重写/覆盖：覆盖是指 <code>派生类函数覆盖基类函数</code> </strong><ul>
<li>函数是要在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>基类函数 <code>必须是虚函数</code></li>
<li>两个函数的 <code>参数相同</code> </li>
</ul>
</li>
<li><strong>函数重定义/隐藏：指派生类的函数屏蔽了与其同名的基类函数</strong><ul>
<li>两个函数在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>两个函数的 <code>参数不同</code> </li>
<li><strong>如果派生类函数与基类函数参数相同，但是在基类函数中没有virtual关键字，发生函数隐藏</strong></li>
</ul>
</li>
</ul>
<hr>
<h4><span id="钻石继承问题">钻石继承问题</span></h4><hr>
<h3><span id="c的四种cast">C++的四种cast</span></h3><h4><span id="static_cast">static_cast</span></h4><p>在C++语言中 <code>static_cast</code> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。例如将整型数据转换为浮点型数据。</p>
<p>主要用法有如下几种：</p>
<ol>
<li><p>用于类层次结构中基类和派生类之间指针或引用的转换。</p>
<p>进行<strong>上行转换</strong>（把派生类的指针或引用转换成基类表示）是<strong>安全</strong>的<br>进行<strong>下行转换</strong>（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，是<strong>不安全</strong>的</p>
</li>
<li><p>用于基本数据类型之间的转换，如把 <code>int</code> 转换成 <code>char</code> 。这种转换的安全也要开发人员来保证。</p>
</li>
<li><p>把空指针转换成目标类型的空指针。</p>
</li>
<li><p>把任何类型的表达式转换为 <code>void</code> 类型。</p>
</li>
</ol>
<ul>
<li>注意：<code>static_cast</code> 不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</li>
<li><code>static_cast</code> : 可以实现C++中内置基本数据类型之间的相互转换。</li>
<li>如果涉及到类的话，<code>static_cast</code> 只能在<strong>有相互联系的类型</strong>中进行相互转换,不一定包含虚函数。</li>
</ul>
<hr>
<h4><span id="const_cast">const_cast</span></h4><p><strong>const_cast&lt;type_id&gt; (expression)</strong></p>
<p><code>const_cast</code> 用于强制去掉 <code>const</code> 这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是<strong>去除指向常数对象的指针或引用的常量性</strong>，其去除常量性的对象必须为指针或引用。用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li>
<li>常量对象被转换成非常量对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> *q =<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    *q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="string">" "</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=10 *p=20 *q=20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，原来的 <code>a</code> 的常量性并没有被去除，而指向常量的指针 <code>p</code> 被转化成非常量指针，并且仍然指向原来的对象，并且指向的值被 <code>q</code> 改变成 <code>20</code> 。</p>
<hr>
<h4><span id="reinterpret_cast">reinterpret_cast</span></h4><p><strong>reinterpret_cast&lt;type_id&gt; (expression) </strong>主要有三种强制转换用途：</p>
<ol>
<li>改变指针或引用的类型。</li>
<li>将指针或引用转换为一个足够长度的整形。</li>
<li>将整型转换为指针或引用类型。</li>
</ol>
<p>其中， <code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。<code>reinterpret_cast</code> 可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。整型指针通过 <code>reinterpret_cast</code> 强制转换成了双精度浮点型指针如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code> 可以将指针或引用转换为一个足够长度的整形，此中的足够长度具体长度需要多少则取决于操作系统，如果是32位的操作系统，就需要4个字节及以上的整型，如果是64位的操作系统则需要8个字节及以上的整型。</p>
<hr>
<h4><span id="dynamic_cast">dynamic_cast</span></h4><p><strong>用法：dynamic_cast&lt;type_id&gt; (expression)</strong></p>
<ol>
<li>其他三种都是<strong>编译时完成</strong>的，dynamic_cast是<strong>程序运行</strong>时处理的，运行时要进行<strong>类型检查</strong>。</li>
<li>不能用于内置的基本数据类型的强制转换。</li>
<li><code>dynamic_cast</code> 转换如果成功的话返回的是<strong>指向类的指针或引用</strong>，转换失败的话则会返回 <code>NULL</code> 。</li>
<li><code>dynamic_cast</code>涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换</li>
<li>使用 <code>dynamic_cast</code> 进行转换的，<strong>基类中一定要有虚函数，否则编译不通过</strong>。<br> 基类中需要检测有虚函数的原因：<ul>
<li>类中存在虚函数，就说明它有想<strong>要让基类指针或引用指向派生类对象</strong>的情况，此时转换才有意义。<br> 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。</li>
</ul>
</li>
<li>在类的转换时，在类层次间进行<strong>上行转换</strong> (子类指针指向父类指针) 时，<code>dynamic_cast</code> 和 <code>static_cast</code> 的效果是一样的。在进行下行转换 (父类指针指向子类指针) 时，<code>dynamic_cast</code> 具有类型检查的功能，比 <code>static_cast</code> 更安全。</li>
<li>在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。<code>dynamic_cast</code> 操作符则可以在运行期对可能产生问题的类型转换进行检查。这个检查主要来自<em>虚函数(virtual function)</em> 。在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名(function siguature)的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。</li>
</ol>
<hr>
<h4><span id="哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</span></h4><p>C风格的强制转换(Type Cast)容易理解,不管什么类型的转换都可以使用使用下面的方式.：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeName b = (TypeName)a;</span><br></pre></td></tr></table></figure>
<p><strong>static_cast</strong> 作用和C语言风格强制转换的效果基本一样，都没有运行时的类型检查来保证转换的安全性。</p>
<hr>
<h3><span id="c智能指针">C++智能指针</span></h3><p><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a></p>
<p>C++提出了智能指针，有以下四种<code>auto_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>, <code>unique_ptr</code>。其中后三个是 <code>C++11</code> 支持的，第一个已经被 <code>C++11</code> 弃用。</p>
<p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是<strong>栈上</strong>的对象，所以当函数（或程序）结束时<strong>会自动被释放通过智能指针管理分配的内存单元</strong>。</p>
<h4><span id="auto_ptr弃用">auto_ptr(弃用)</span></h4><p><code>auto_ptr</code> 采用<strong>所有权模式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，相当于 <code>p2</code> 剥夺了 <code>p1</code> 的所有权，但是当程序运行时访问 <code>p1</code> 将会报错。所以 <code>auto_ptr</code> 的缺点是：存在潜在的内存崩溃问题。</p>
<hr>
<h4><span id="unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</span></h4><p><code>unique_ptr</code> 实现<strong>独占式拥有或严格拥有</strong>概念，保证<strong>同一时间内只有一个智能指针</strong>可以指向该对象。它对于避免资源泄露 (例如“以new创建对象后因为发生异常而忘记调用delete”) 特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;</span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>同时，当程序试图将一个 <code>unique_ptr</code> 赋值给另一个时，如果源 <code>unique_ptr</code> 是个临时右值，编译器允许这么做；如果源 <code>unique_ptr</code> 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                          <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));       <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>#1</code> 留下悬挂的 <code>unique_ptr(pu1)</code> ，这可能导致危害。而 <code>#2</code> 不会留下悬挂的 <code>unique_ptr</code> ，因为它调用 <code>unique_ptr</code> 的构造函数，该构造函数创建的临时对象在其所有权让给 <code>pu3</code> 后就会被销毁</p>
<p>如果想要完成上面 <code>#1</code> 的操作，需要将一个 <code>unique_ptr</code> 赋给另一个，可以使用 <code>std::move()</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">std</span>::move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="shared_ptr">shared_ptr</span></h4><p><code>shared_ptr</code> 实现共享式拥有概念：多个智能指针可以指向相同对象，该对象和其相关资源会在<strong>最后一个引用被销毁</strong>时候释放。</p>
<p><code>shared_ptr</code> 使用计数机制来表明资源被几个指针共享。可以通过成员函数 <code>use_count()</code> 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 <code>auto_ptr</code> , <code>unique_ptr</code> , <code>weak_ptr</code> 来构造。当我们调用 <code>release()</code> 时，当前指针会释放资源所有权，计数减一。当计数等于 <code>0</code> 时，资源会被释放。</p>
<p>成员函数：</p>
<ul>
<li><p><code>use_count()</code> 返回引用计数的个数</p>
</li>
<li><p><code>unique()</code> 返回是否是独占所有权(use_count为 1 )</p>
</li>
<li><p><code>swap</code> 交换两个 <code>shared_ptr</code> 对象(即交换所拥有的对象)</p>
</li>
<li><p><code>reset</code> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li><p><code>get</code> 返回内部对象(指针), 由于已经重载了 <code>()</code> 方法, 因此和直接使用对象是一样的。</p>
<p>如 <code>shared_ptr&lt;int&gt; sp(new int(1));</code>  sp 与 sp.get() 是等价的。</p>
</li>
</ul>
<p><strong>引用计数带来的副作用</strong> <code>循环引用问题</code><br>A对象的指针指向B对象，B对象的指针指向了A对象。两个指针相互指向。<code>造成堆里的内存无法正常回收，造成内存泄漏。</code> 这个时候就需要 <code>weak_ptr</code> 了。</p>
<hr>
<h4><span id="weak_ptr">weak_ptr</span></h4><p><code>weak_ptr</code> 是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象，进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code> 。</p>
<p><code>weak_ptr</code> 只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 工作, <strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>, 它的构造和析构不会引起引用记数的增加或减少。</p>
<p><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题：</strong></p>
<p>如果两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。<code>weak_ptr</code> 是对对象的一种弱引用，不会增加对象的引用计数。</p>
<p><code>weak_ptr</code> 和 <code>shared_ptr</code> 之间可以相互转化，<code>shared_ptr</code> 可以直接赋值给<code>weak_ptr</code> ，<code>weak_ptr</code> 也可以通过调用 <code>lock</code> 函数来获得 <code>shared_ptr</code> 。</p>
<p>具体栗子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会只输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>出现了循环引用，当要跳出函数时，智能指针 <code>pa</code> ，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code> ，导致跳出函数时资源没有被释放(A\B的析构函数没有被调用)，如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 <code>A</code> 里面的 <code>shared_ptr pb_;</code> 改为 <code>weak_ptr pb_;</code> 运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">B delete</span><br><span class="line">A delete</span><br></pre></td></tr></table></figure>
<p>资源 <code>B</code> 的引用开始就只有 <code>1</code> ，当 <code>pb</code> 析构时，<code>B</code> 的计数变为 <code>0</code> ，<code>B</code> 得到释放，<code>B</code> 释放的同时也会使 <code>A</code> 的计数减一，同时 <code>pa</code> 析构时使 <code>A</code> 的计数减一，那么 <code>A</code> 的计数为 <code>0</code> ， <code>A</code> 得到释放。</p>
<p>注意的是我们不能通过 <code>weak_ptr</code> 直接访问对象的方法，比如 <code>B</code> 对象中有一个方法 <code>print()</code> ,我们不能这样访问，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;pb_-&gt;print()</span><br></pre></td></tr></table></figure>
<p><code>pb_</code> 是一个 <code>weak_ptr</code> ，应该先调用 <code>lock()</code> 函数把它转化为 <code>shared_ptr</code> ，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> p = pa-&gt;pb_.lock();</span><br><span class="line">p-&gt;print();</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>如何判断weak_ptr的对象是否失效？</strong></p>
<ol>
<li><code>expired()</code> ：检查被引用的对象是否已删除。</li>
<li><code>lock()</code> 会返回 <code>shared_ptr</code> 指针，判断该指针是否为空。</li>
<li><code>use_count()</code> 也可以得到 <code>shared_ptr</code> 引用的个数，但速度较慢。</li>
</ol>
<hr>
<p><strong>shared_ptr 和 unique_ptr 区别</strong></p>
<p><code>unique_ptr</code> 具有唯一性，对指向的对象值存在唯一的 <code>unique_ptr</code> 。<code>unique_ptr</code> 不可复制，赋值，但是<code>std::move()</code> 可以转换对象的所有权，局部变量的返回值除外。与 <code>shared_ptr</code> 相比，若自定义删除器，<code>unique_ptr</code>需要在声明处指定删除器类型，而 <code>shared_ptr</code> 不需要，<code>shared_ptr</code> 自定义删除器只需要指定删除器对象即可；在赋值时，<code>shared_ptr</code> 可以随意赋值，删除器对象也会被赋值给新的对象。因为在 <code>unique_ptr</code> 的实现中，删除器对象是作为 <code>unique_ptr</code> 的一部分，而 <code>shared_ptr</code> 的删除器对象保存在<code>control_block</code> 中。</p>
<hr>
<h4><span id="智能指针是线程安全的吗">智能指针是线程安全的吗？</span></h4><p><code>shared_ptr</code> 本身不是 <code>100%</code> 线程安全的。</p>
<p>它的引用计数本身是安全且无锁的，智能指针的引用计数在手段上使用了<strong>atomic原子操作</strong>，只要 <code>shared_ptr</code> 在拷贝或赋值时增加引用，析构时减少引用就可以了。首先原子是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的。</p>
<p>但对象的读写则不是，因为<code>shared_ptr</code> 有<strong>两个数据成员</strong>，读写操作不能原子化：一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象，当智能指针发生拷贝的时候，标准库的实现是<strong>先拷贝智能指针</strong>，<strong>再拷贝引用计数对象</strong>（拷贝引用计数对象的时候，会使 <code>use_count++</code>），这两个操作并不是原子操作，隐患就出现在这里。<strong>两个线程中智能指针的引用计数同时++或–，这个操作不是原子的，假设引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了，违背了原子性。</strong></p>
<p>根据 <code>boost</code> 文档，<code>shared_ptr</code> 的线程安全级别和内建类型、标准库容器、<code>std::string</code> 一样，即：</p>
<ul>
<li>一个 <code>shared_ptr</code> 对象实体可被多个线程同时读取；</li>
<li>两个 <code>shared_ptr</code> 对象实体可以被两个线程同时写入，<code>析构</code> 算写操作；</li>
<li>如果要从多个线程读写同一个 <code>shared_ptr</code> 对象，那么需要加锁。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>读</code> 是安全的。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>写</code> 是不安全的。</li>
<li>同一个 <code>shared_ptr</code> 对象不能被多线程直接修改，但可以通过原子函数完成。</li>
<li>共享引用计数的不同的 <code>shared_ptr</code> 被多个线程 <code>写</code>  是安全的。</li>
</ul>
<hr>
<h3><span id="c对象的内存模型">C++对象的内存模型</span></h3><h4><span id="普通对象模型">普通对象模型</span></h4><p>对象是如何在内存中布局的？</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>存放位置</th>
<th>访问范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>非静态数据成员</td>
<td>每一个对象体内</td>
<td>为该对象专有</td>
</tr>
<tr>
<td>静态数据成员</td>
<td>程序的静态存储区内，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>成员函数（静态/非静态）</td>
<td>程序的代码段中，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>类内嵌套的各种类型（typedef、class、struct、enum等）</td>
<td>与放在类外面定义的类型除了定义域之外没有本质区别</td>
<td>遵循类内部的访问规则</td>
</tr>
</tbody>
</table>
<p>因此，构成对象本身的<strong>只有数据</strong>，类的成员函数不属于任何一个对象。<strong>非静态成员函数与对象之间的关系是通过this指针绑定的</strong>。</p>
<h4><span id="派生类的对象模型">派生类的对象模型</span></h4><p>派生类的对象是如何在内存中布局的？</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承自基类的非静态数据成员</td>
<td>作为对象自己专用的数据</td>
</tr>
<tr>
<td>继承自基类的非静态成员函数</td>
<td>作为类的成员函数一样访问</td>
</tr>
<tr>
<td>虚函数（继承的或者新增的）</td>
<td>所有虚函数的地址都存放在vtable里</td>
</tr>
<tr>
<td>多态类每一个对象中的vptr</td>
<td>函数指针的指针，指向所属类的vtable</td>
</tr>
<tr>
<td>继承自基类的vptr</td>
<td>继承和重用该vptr</td>
</tr>
<tr>
<td>多重继承的多个分支</td>
<td>每个分支都继承一个vptr并生成一个对应的vtable</td>
</tr>
</tbody>
</table>
<p><code>vptr</code> 在派生类对象中的相对位置不会随着继承的层次改变而改变，一般编译器会将 <code>vptr</code> 放在所有数据成员的最前面。为了支持 <code>RTTI</code> ，编译器会为每一个多态类创建一个 <code>type_info</code> 对象，并把其地址保存在该类 <code>vtable</code> 中的第一个位置。</p>
<h4><span id="vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</span></h4><ol>
<li>如果虚函数是第一次出现，则把它的函数地址指针依次插入到 <code>vtable</code> 的尾部。</li>
<li>如果派生类改写了基类的虚函数，则这个函数的地址在派生类 <code>vtable</code> 中的位置与其在基类 <code>vtable</code> 中的位置一致，而与其在派生类中的声明位置无关。也就是说<strong>一旦虚函数指针在 <code>vtable</code> 的位置确定，则它的位置就不会因为继承层次的改变而改变。</strong></li>
<li>派生类没有改写的基类虚函数被继承，位置与原先在 <code>vtable</code> 中的位置相同。</li>
</ol>
<hr>
<h3><span id="volitale关键字">Volitale关键字</span></h3><p> <code>volatile</code> 关键字直译应该是 <code>易变的</code> ，也就是它修饰的对象有可能突然发生不可预期的改变。被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p>
<p><code>volatile</code> 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>，从而可以<strong>提供对特殊地址的稳定访问</strong>。</p>
<p><code>volatile</code> 可理解为编译器警告指示字；<code>volatile</code> 用于告诉编译器必须每次去内存中取变量值；<code>volatile</code>主要修饰可能被多个线程访问的变量；<code>volatile</code> 也可以修饰可能被未知因数更改的变量。</p>
<p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在<strong>主存(物理内存)</strong>当中的，这时就存在一个问题，由于CPU执行速度很快，而<strong>从内存读取数据</strong>和<strong>向内存写入数据</strong>的过程跟<strong>CPU执行指令的速度</strong>比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。</p>
<p>为了处理这个问题，在CPU里面就有了<strong>高速缓存(Cache)</strong>的概念。当程序在运行过程中，会将运算需要的数据<strong>从主存复制一份到CPU的高速缓存当中</strong>，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将<strong>高速缓存中的数据刷新到主存当中</strong>。</p>
<p>这一过程在单线程运行是没有问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存。这时就会出现同一个变量在两个高速缓存中的<strong>值</strong>不一致问题了。例如：两个线程分别读取了 <code>t</code> 的值，假设此时 <code>t</code> 的值为0，并且把 <code>t</code> 的值存到了各自的高速缓存中，然后线程1对 <code>t</code> 进行了加1操作，此时 <code>t</code> 的值为1，并且把 <code>t</code> 的值写回到主存中。但是线程2中高速缓存的值还是0，进行加1操作之后，<code>t</code> 的值还是为1，然后再把 <code>t</code> 的值写回主存。此时，就出现了 <code>线程不安全</code> 问题了。</p>
<p>按照 <a href="https://link.zhihu.com/?target=http%3A//web.archive.org/web/20180120044239/http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html" target="_blank" rel="noopener">Hans Boehm &amp; Nick Maclaren 的总结</a>，<code>volatile</code> 只在三种场合下是合适的。</p>
<ul>
<li><ul>
<li>和信号处理（signal handler）相关的场合；</li>
<li>和内存映射硬件（memory mapped hardware）相关的场合；</li>
<li>和非本地跳转（<code>setjmp</code> 和 <code>longjmp</code>）相关的场合。换句话说也就是</li>
</ul>
</li>
</ul>
<p>也就是：</p>
<p><strong>1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；</strong></p>
<p><strong>2) 多任务环境下各任务间共享的标志应该加volatile；</strong></p>
<p><strong>3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</strong></p>
<h4><span id="volatile指针">volatile指针</span></h4><p>和 <code>const</code> 修饰词类似，<code>const</code> 有常量指针和指针常量的说法，<code>volatile</code> 也有相应的概念：</p>
<ul>
<li>修饰由指针指向的对象、数据是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span>* vpch;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针自身的值——一个代表地址的整数变量，是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>(1) 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</strong></p>
<p>(2) 除了基本类型外，对用户定义类型也可以用 <code>volatile</code> 类型进行修饰。</p>
<p>(3) C++中一个有 <code>volatile</code> 标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用<code>const_cast</code> 来获得对类型接口的完全访问。此外，<code>volatile</code> 像 <code>const</code> 一样会从类传递到它的成员。</p>
<h4><span id="可见性">可见性</span></h4><h5><span id="什么是可见性">什么是可见性？</span></h5><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的<strong>工作空间</strong>中读取。<br>例如我们上面说的，当线程1对 <code>t</code> 进行了加1操作并把数据写回到主存之后，线程2就会知道它自己工作空间内的 <code>t</code> 已经被修改了，当它要执行加1操作之后，就会去主存中读取。这样，两边的数据就能一致了。<br>假如一个变量被声明为 <code>volatile</code> ，那么这个变量就具有了<strong>可见性</strong>的性质了。这就是 <code>volatile</code> 关键的作用之一了。</p>
<hr>
<p><strong>静态全局变量</strong>：注意使用 <code>static</code> 修饰变量，就不能使用 <code>extern</code> 来修饰，即 <code>static</code> 和 <code>extern</code> 不可同时出现。<code>static</code> 修饰的全局变量的声明与定义同时进行，即当你在头文件中使用 <code>static</code> 声明了全局变量，同时它也被定义了。</p>
<hr>
<h3><span id="c中指针和引用的区别">C++中指针和引用的区别</span></h3><ol>
<li><p>指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li><p>使用 <code>sizeof</code> 看一个指针的大小是 <code>4</code> ，而引用则是被引用对象的大小；</p>
</li>
<li><p>指针可以被初始化为 <code>NULL</code> ，而引用必须被初始化且必须是一个已有对象的引用；</p>
</li>
<li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
</li>
<li><p>可以有 <code>const</code> 指针，但是没有 <code>const</code> 引用；</p>
<ul>
<li><p><strong>指针常量</strong> <code>int *const P1</code>：指针常量约束的是该指针所指的地址，即指针变量本身，而并不是对象本身，地址不能够改变，但是对象值可以改变。<code>const</code> 在 <code>*</code> 后，表示约束的量是指针的地址。</p>
</li>
<li><p><strong>指向常量的指针</strong> <code>const int *P1</code> ：用 <code>const</code> 约束指针对所指对象进行访问时，这个指针称为指向常量的指针。<code>const</code> 在 <code>*</code> 前，表示约束的是指针量本身。<strong>指向常量的指针可以获取变量的地址，但限制用指针间址访问对象方式为“只读</strong>。</p>
</li>
</ul>
</li>
<li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p>
</li>
<li><p>指针可以有多级指针（<code>**p</code>），而引用只有一级；</p>
</li>
<li><p>指针和引用使用 <code>++</code> 运算符的意义不一样：引用自增被引用对象的值，指针自增内存地址</p>
</li>
<li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起<strong>内存泄露</strong>。</p>
</li>
</ol>
<hr>
<h3><span id="c中new与malloc的区别">C++中new与malloc的区别</span></h3><p><code>new</code> 和 <code>malloc</code> 的内存是分配在堆上的。也有说 <code>new</code> 是分配在自由存储区而 <code>malloc</code> 分配在堆上，自由存储区可以是堆也可以不是，具体要看 <code>new</code> 内部的实现。操作系统在堆上维护一个空闲内存链表，当需要分配内存的时候，就查找这个表，找到一块内存大于所需内存的区域，分配内存并将剩余的内存空间返还到空闲链表上(如果有剩余的话)。</p>
<ol>
<li><p><code>malloc</code> 和 <code>free</code> 是库函数，而 <code>new</code> 和 <code>delete</code> 是 <code>C++</code> 操作符；</p>
</li>
<li><p><code>new</code> 自己计算需要的空间大小，比如 <code>int * a = new</code> ，<code>malloc</code> 需要指定大小，例如 <code>int * a = malloc(sizeof(int));</code> </p>
</li>
<li><p><code>new</code> 在动态分配内存的时候可以初始化对象，调用其构造函数，<code>delete</code> 在释放内存时调用对象的析构函数。而 <code>malloc</code> 只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回 <code>NULL</code> 。</p>
</li>
<li><p><code>new</code> 是 <code>C++</code> 操作符，是关键字，而 <code>operate new</code> 是 <code>C++</code> 库函数</p>
</li>
<li><p><code>opeartor new</code> / <code>operator delete</code> 可以重载，而 <code>malloc</code> 不行</p>
</li>
<li><p><code>new</code> 可以调用 <code>malloc</code> 来实现，但是 <code>malloc</code> 不能调用 <code>new</code> 来实现</p>
</li>
<li><p>对于数组，C++定义 <code>new[]</code> 专门进行动态数组分配，用 <code>delete[]</code> 进行销毁。<code>new[]</code> 会一次分配内存，然后多次调用构造函数；<code>delete[]</code> 会先多次调用析构函数，然后一次性释放。</p>
</li>
<li><strong>malloc能够直观地重新分配内存</strong>：使用 <code>malloc</code> 分配的内存后，如果在使用过程中发现内存不足，可以使用<code>realloc</code> 函数进行内存重新分配实现内存的扩充。<code>realloc</code> 先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域；<code>new</code> 没有这样直观的配套设施来扩充内存。</li>
</ol>
<hr>
<h3><span id="c-内存对齐">C++ 内存对齐</span></h3><p>现代计算机中内存空间都是按照 <code>byte</code> 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的<strong>首地址的值</strong>是某个数 <code>k</code> （通常它为4或8）的倍数，这就是所谓的内存对齐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，32位系统下，<code>int</code> 占 <code>4 byte</code> ，<code>char</code> 占一个 <code>byte</code> ，那么将它们放到一个结构体中应该占<code>4+1=5byte</code>；但是实际上，<code>sizeof(s)</code> 得到的结果是 <code>8 byte</code> ，这就是内存对齐所导致的。</p>
<p><strong>为什么要内存对齐？</strong></p>
<p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，四字节，<code>8</code> 字节，<code>16</code> 字节甚至 <code>32</code> 字节为单位来存取内存，我们将上述这些存取单位称为<strong>内存存取粒度</strong>。</p>
<p>现在考虑 <code>4</code> 字节存取粒度的处理器取 <code>int</code> 类型变量（<code>32</code> 位系统），该处理器只能从地址为 <code>4</code> 的倍数的内存开始读取数据。这样处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p>
<p>每个特定平台上的编译器都有自己的默认<strong>对齐系数</strong>（也叫对齐模数）。<code>gcc</code> 中默认 <code>#pragma pack(4)</code> ，可以通过预编译命令 <code>#pragma pack(n)</code> ，<code>n = 1,2,4,8,16</code> 来改变这一系数。</p>
<p>有效对其值：是给定值 <code>#pragma pack(n)</code> 和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p><strong>内存对齐规则：</strong></p>
<ul>
<li><p>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 <code>offset</code> 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
</li>
<li><p><strong>结构体的总大小</strong>为有效对齐值的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">&#125;x3;</span><br></pre></td></tr></table></figure>
<p><code>x1</code> , <code>x2</code> , <code>x3</code> 的 <code>sizeof</code> 结果分别是 <code>8</code> ,  <code>12</code> , <code>8</code> 。</p>
<p>内存结构分别如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg" alt="img"></p>
<hr>
<h3><span id="c存储类型">C++存储类型</span></h3><p>C++中<strong>存储类型的说明符</strong>有四个：<strong>auto</strong>, <strong>register</strong>, <strong>static</strong>和<strong>extern</strong>。前两者称为<code>自动</code>类型，后两者分别为<code>静态</code>和<code>外部</code>类型。此外还有 <code>mutable存储类</code> 和 <code>thread_local 存储类</code> 。</p>
<hr>
<h4><span id="auto-自动变量">auto 自动变量</span></h4><p>用 <code>auto</code> 说明的变量，通常 <code>auto</code> 省略。局部变量都是自动类型。其生命期开始于块的执行，结束于块的结束。</p>
<p>自动变量的空间分配在<strong>栈</strong>中，在程序运行过程中，块开始执行时系统<strong>自动</strong>分配空间（未初始化时值为随机数），块执行结束时系统<strong>自动</strong>释放空间。因此，自动变量的<strong>生命期和作用域是一致的</strong>。</p>
<hr>
<h4><span id="register-寄存器变量">register 寄存器变量</span></h4><p>用 <code>register</code> 说明的变量，如 <code>register int i</code> ; 系统将这样说明的变量尽可能保存在寄存器中，以提高程序运行速度。但不同的编译器对哪些变量可以说明为寄存器变量有不同的规定，而且一般的编译器都会对寄存器的使用进行优化，所以不提倡使用寄存器变量。</p>
<hr>
<h4><span id="static-关键字">static 关键字</span></h4><p>静态变量存储在<strong>全局存储区(静态存储区)</strong>，在整个程序运行期间一直存在。如果程序未显式给出初始化值，系统自动初始化为全 <code>0</code>，且初始化只进行一次。静态变量占有的空间要到整个程序执行结束才释放，故静态变量具有<strong>全局生命期</strong>。</p>
<p>静态变量根据定义位置的不同还分为 <code>局部静态变量</code> 和 <code>全局静态变量</code> ，</p>
<ol>
<li><p><strong>局部静态变量：</strong></p>
<p>是指在块中定义的静态变量，当块第一次被执行的时候，编译器在<strong>全局存储区</strong>为其开辟空间并保存数据，该空间一直到整个程序结束才释放。该变量具有<strong>局部作用域</strong>，但却具有<strong>全局生命期</strong>。当定义它的函数或者语句块结束的时候，作用域结束。:star:但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且变量的值不变。</p>
</li>
<li><p><strong>全局静态变量：</strong></p>
<p>全局静态变量在声明他的文件之外是不可见的，作用域是从定义之处-&gt;文件结尾。</p>
</li>
<li><p><strong>静态函数：</strong></p>
<p>在函数返回类型前加 <code>static</code> ，函数就定义为静态函数。函数的定义和声明在默认情况下都是<code>extern</code> 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用 <code>static</code> 修饰，那么这个函数只可在本 <code>cpp</code> 内使用，不会同其他 <code>cpp</code> 中的同名函数引起冲突。</p>
<p>注意：不要在头文件中声明 <code>static</code> 的全局函数，不要在 <code>cpp</code> 内声明非 <code>static</code> 的全局函数，如果你要在多个 <code>cpp</code> 中复用该函数，就把它的声明提到头文件里去，否则 <code>cpp</code> 内部声明需加上static修饰。</p>
</li>
<li><p><strong>类的静态成员：</strong></p>
<p>在类中，静态成员可以实现多个对象之间的<strong>数据共享</strong>，并且使用静态数据成员还<strong>不会破坏隐藏的原则</strong>，即保证了安全性。因此，静态成员是<strong>类的所有对象中共享的成员</strong>，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
</li>
<li><p><strong>类的静态函数：</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)。</p>
<ol>
<li>静态成员函数<strong>是类的一个特殊的成员函数</strong></li>
<li>静态成员函数<strong>属于整个类所有，没有this指针</strong></li>
<li>静态成员函数<strong>只能直接访问静态成员变量和静态成员函数</strong></li>
<li><strong>可以通过类名直接访问类的公有静态成员函数</strong></li>
<li><strong>可以通过对象名访问类的公有静态成员函数</strong></li>
<li><strong>定义静态成员函数，直接使用static关键字修饰即可</strong></li>
</ol>
<p>这里面有一种很常见的情况是，在 <code>sort()</code> 函数中，<code>sort</code> 函数的参数 <code>cmp</code> 的调用要求不带 <code>this</code> 指针，对于类内函数，他们都有一个隐式的 <code>this</code> 指针在第一个参数内，因此要么把 <code>cmp</code> 写在类外，要么加上 <code>static</code> 声明，<code>static</code> 声明后的成员函数不带有 <code>this</code> 指针。所以要写成如下形式：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="extern关键字">extern关键字</span></h4><p><code>extern</code> 是一种<strong>外部声明</strong>的关键字，字面意思就是<strong>在此处声明</strong>某种变量或函数，<strong>在外部定义</strong>。</p>
<p><code>extern</code> 关键字的主要作用是<strong>扩大变量/函数的作用域</strong>，使得其它源文件和头文件可以复用同样的变量/函数，也起到类似“分块储存”的作用，划分代码。如图所示，在一个头文件里做了外部声明，就能把变量的定义部分和函数体的实现部分转移到其它地方了。</p>
<p><img src="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png" alt="img"></p>
<p>此外 <code>extern</code> 也可用来进行<strong>链接指定</strong>：当它与 <code>C</code> 一起连用时，如: <code>extern &quot;C&quot; void fun(int a, int b);</code> 则告诉编译器在编译 <code>fun</code> 这个函数名时按着 <code>C</code> 的规则去翻译相应的函数名而不是 <code>C++</code> 的，<code>C++</code> 的规则在翻译这个函数名时会把 <code>fun</code> 这个名字变得面目全非，可能是 <code>fun@aBc_int_int#%$</code> 也可能是别的，因为 <code>C++</code> 支持函数的重载。</p>
<p><strong>对于extern关键字：只在头文件中做声明，真理总是这么简单</strong>。</p>
<hr>
<h4><span id="mutable-存储类">mutable 存储类</span></h4><p><strong>mutable</strong> 说明符仅适用于类的对象。它允许对象的成员替代常量。也就是说，<code>mutable</code> 成员可以通过 <code>const</code> 成员函数修改。</p>
<hr>
<h4><span id="thread_local-存储类">thread_local 存储类</span></h4><p><code>thread_local</code> 变量是 <code>C++11</code> 新引入的一种存储类型。它会影响变量的存储周期( <code>Storage duration</code> )。只有<code>thread_local</code> 关键字修饰的变量具有线程周期( <code>thread duration</code> )，这些变量(或者说对象）在线程开始的时候被生成( <code>allocated</code> )，在线程结束的时候被销毁( <code>deallocated</code> )。并且每 一个线程都拥有一个独立的变量实例。<code>thread_local</code> 可以和<code>static</code> 与 <code>extern</code>关键字联合使用，这将影响变量的链接属性。</p>
<hr>
<h3><span id="stdmove语义">std::move()语义</span></h3><p>在 <code>C++11</code> 中，标准库在 <code>&lt;utility&gt;</code> 中提供了一个有用的函数 <code>std::move</code> ，<code>std::move</code> 并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。  </p>
<hr>
<h3><span id="右值引用">右值引用</span></h3><p><strong>左值与右值</strong></p>
<p>左值可以取地址、位于等号左边；而右值没法取地址，位于等号右边。</p>
<p>有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<h4><span id="左值引用">左值引用</span></h4><p><strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure>
<p>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。但是，<strong>const左值引用</strong>是可以指向右值的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<p><code>const</code> 左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用 <code>const &amp;</code> 作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p>
<h4><span id="右值引用">右值引用</span></h4><p>右值引用的标志是 <code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>
<h4><span id="右值引用有办法指向左值吗">右值引用有办法指向左值吗</span></h4><p>可以通过 <code>std::move()</code> 实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>
<p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>。</p>
<p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参是个右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span> </span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// ref_a_left是个左值引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// ref_a_right是个右值引用</span></span><br><span class="line"> </span><br><span class="line">    change(a); <span class="comment">// 编译不过，a是左值，change参数要求右值</span></span><br><span class="line">    change(ref_a_left); <span class="comment">// 编译不过，左值引用ref_a_left本身也是个左值</span></span><br><span class="line">    change(ref_a_right); <span class="comment">// 编译不过，右值引用ref_a_right本身也是个左值</span></span><br><span class="line">     </span><br><span class="line">    change(<span class="built_in">std</span>::move(a)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_right)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_left)); <span class="comment">// 编译通过</span></span><br><span class="line"> </span><br><span class="line">    change(<span class="number">5</span>); <span class="comment">// 当然可以直接接右值，编译通过</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    <span class="comment">// 打印这三个左值的地址，都是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::move()</code> 会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以 <code>move</code> 返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：</p>
<p><strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p>
<p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 </p>
<p><strong>总的来说：</strong></p>
<ol>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以<strong>避免拷贝</strong>。</li>
<li>右值引用可以直接指向右值，也可以通过 <code>std::move</code> 指向左值；而左值引用只能指向左值( <code>const</code> 左值引用也能指向右值)。</li>
<li>作为函数形参时，右值引用更灵活。虽然 <code>const</code> 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// 编译失败，const左值引用不能修改指向变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> &amp;&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">5</span>);</span><br><span class="line">    f2(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际场景中，右值引用和 <code>std::move</code> 被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。在 <code>STL</code> 的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如 <code>std::vector</code> 的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<p>移动构造函数即：把被拷贝者的数据移动过来，被拷贝者后边就不要这个数据了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2：std::vector和std::string的实际例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"aacasxs"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.push_back(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.emplace_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.emplace_back(<span class="string">"axcsddcas"</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::vector方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有些 <code>STL</code> 类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_a = <span class="built_in">std</span>::make_unique&lt;A&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = <span class="built_in">std</span>::move(ptr_a); <span class="comment">// unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = ptr_a; <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<h4><span id="完美转发-stdforward">完美转发 std::forward()</span></h4><p>和<code>std::move</code>一样，std::forward`也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换。</p>
<p>与 <code>move</code> 相比，<code>forward</code> 更强大，<code>move</code> 只能转出来右值，<code>forward</code> 都可以。</p>
<blockquote>
<p>std::forward<t>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</t></p>
</blockquote>
<h4><span id="autoampamp也是这个意思">auto&amp;&amp;也是这个意思</span></h4><p>迭代器中如果使用 <code>auto&amp;&amp;</code> 代表着接受任何初始化程序，无论它是左值表达式还是右值表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>         =&gt; will copy the <span class="built_in">vector</span>, but we wanted a reference</span><br><span class="line"><span class="keyword">auto</span>&amp;        =&gt; will only bind to modifiable lvalues</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;  =&gt; will bind to anything but make it <span class="keyword">const</span>, giving us const_iterator</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; =&gt; will bind only to rvalues</span><br></pre></td></tr></table></figure>
<p>所以说大部分情况下，<code>auto</code> 和 <code>auto&amp;&amp;</code> 能够解决大部分问题。</p>
<hr>
<h3><span id="c内联函数">C++内联函数</span></h3><h4><span id="内联函数有什么优点">内联函数有什么优点？</span></h4><ol>
<li><code>inline</code> 函数代码是被放到<strong>符号表</strong>中，使用时像宏一样展开，没有调用的开销，效率很高；</li>
<li><code>inline</code> 函数是真正的函数，所以要进行一系列的数据类型检查；</li>
<li><code>inline</code> 函数作为类的成员函数，可以使用类的保护成员及私有成员；</li>
</ol>
<p>C++中支持内联函数，其目的是为了<strong>提高函数的执行效率</strong>：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。用关键字 <code>inline</code> 放在函数定义(<strong>注意是定义而非声明</strong>)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上<strong>内联地</strong>展开，假设我们将 <code>max</code> 定义为内联函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>cout&lt;&lt;max(a, b)&lt;&lt;endl;</code> 的时候，编译时会展开为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;(a &gt; b ? a : b)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>Effective C++</code> 中，<code>Prefer consts，enums，and inlines to #defines</code>，建议我们用内联函数来替代宏定义。</p>
<h4><span id="将内联函数放入头文件">将内联函数放入头文件</span></h4><p>关键字 <code>inline</code> 必须与函数定义体放在一起才能使函数成为内联，仅将 <code>inline</code> 放在函数声明前面不起任何作用。定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125;   <span class="comment">// 自动地成为内联函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 <code>inline</code> 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p>
<p>当然内联函数定义也可以放在源文件中，但此时<strong>只有定义的那个源文件可以用它</strong>，而且<strong>必须为每个源文件拷贝一份定义</strong>(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。</p>
<h4><span id="内联函数与宏定义的区别">内联函数与宏定义的区别？</span></h4><ol>
<li><p>内联函数在<strong>编译时展开</strong>，宏在<strong>预编译时展开</strong>；</p>
</li>
<li><p>内联函数直接<strong>嵌入到目标代码中</strong>，宏是简单的做<strong>文本替换</strong>；</p>
<p>所以这时候宏定义会出意想不到的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= ADD(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//所得的结果却是210</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------其实本质就是--------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= x + y * <span class="number">10</span>;  <span class="comment">//编译器并不会给其加括号</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内联函数有<strong>类型检测、语法判断</strong>等功能，宏没有；</p>
</li>
<li><p><code>inline</code> 函数是函数，宏不是；</p>
</li>
<li><p>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；</p>
</li>
<li><p>C++中引入了类及类的访问控制，在涉及到<strong>类的保护成员和私有成员</strong>就不能用宏定义来操作。</p>
</li>
</ol>
<hr>
<h3><span id="深拷贝与浅拷贝">深拷贝与浅拷贝</span></h3><p>C++中类的拷贝有两种：<strong>深拷贝</strong>，<strong>浅拷贝</strong>：当出现类的等号赋值时，即会调用拷贝函数。<br><strong>深拷贝与浅拷贝的区别</strong></p>
<ol>
<li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但<strong>当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂</strong>现象，所以，此时，必须采用深拷贝。</li>
<li>深拷贝与浅拷贝的区别就在于深拷贝<strong>会在堆内存中另外申请空间来储存数据</strong>，从而也就解决了指针悬挂的问题。简而言之，当<strong>数据成员中有指针时，必须要用深拷贝</strong>。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。</p>
<p>深拷贝的实现一般如下，即自己定义拷贝构造函数来实现深拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student();</span><br><span class="line">	~Student();</span><br><span class="line">	Student(<span class="keyword">const</span> Student &amp;s);<span class="comment">//深拷贝构造函数，const防止对象被改变</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Student::Student() &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">Student::~Student() &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; (<span class="keyword">int</span>)name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> name;</span><br><span class="line">	name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;s) &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(name, s.name, <span class="built_in">strlen</span>(s.name));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="built_in">string</span> &amp;name;</span><br><span class="line">    Address addr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">int</span> grade, <span class="built_in">string</span> name):grade(grade), name(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常量成员</strong>：常量成员只能初始化不能赋值，所以必须放在初始化列表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>引用类型</strong>：引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>对象成员</strong>：成员是其他类的对象，例如上面的 <code>Address  addr</code> 成员。如果把它放在构造函数的初始化列表里，此时会调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>，对这个类对象进行初始化。如果把它放在构造函数体中，会先调用 <code>Address</code> 类的<strong>默认构造函数</strong>，然后再调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>。从性能上考虑，把对象成员的初始化放在初始化列表里性能会更高。</li>
<li><strong>对象成员，并且这个对象只有含参数的构造函数，没有无参数的构造函数：</strong>如果我们有一个<strong>类成员</strong>，它本身是一个类或者是一个结构，而且这个成员它<strong>只有一个带参数的构造函数，而没有默认构造函数</strong>，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。</li>
<li><strong>子类初始化父类的私有成员</strong>，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数。</li>
</ul>
<hr>
<h3><span id="定位内存泄露及检测">定位内存泄露及检测</span></h3><p><a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" target="_blank" rel="noopener">https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html</a></p>
<p>(1)在 <code>windows</code> 平台下通过 <code>CRT</code> 中的库函数进行检测；<br>(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置<br>(3) <code>Linux</code> 下通过工具 <code>valgrind</code> 检测</p>
<hr>
<h3><span id="手写strcpymemcpystrcatstrcmp等函数"><strong>手写strcpy，memcpy，strcat，strcmp等函数</strong></span></h3><h4><span id="strcpy">strcpy</span></h4><ol>
<li><p><code>const</code> 修饰：源字符串参数用 <code>const</code> 修饰，防止修改源字符串；</p>
</li>
<li><p>空指针检查：源指针和目的指针都有可能会出现空指针的情况，所以应该对其进行检查；</p>
</li>
<li><p>为什么要设置 <code>ret</code> 指针以及返回 <code>ret</code> 指针的位置，由于目的指针 <code>dst</code> 已经在进行移动了，所以用辅助指针 <code>ret</code> 表明首指针；</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dst || !src)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(src) + <span class="number">1</span>;<span class="comment">//拷贝最后的'/0'</span></span><br><span class="line">    <span class="keyword">char</span> * ret = dst;</span><br><span class="line">    <span class="keyword">if</span> (dst &gt; src &amp;&amp; dst &lt; len + <span class="number">1</span>)&#123;</span><br><span class="line">        dst = dst + len <span class="number">-1</span>;</span><br><span class="line">        src = src + len <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len--)&#123;</span><br><span class="line">            *dst-- = *src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">            *dst-- = *src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="memcpy">memcpy</span></h4><p>对于地址重叠的情况，该函数的行为是未定义的。因此自己动手实现 <code>memcpy()</code> 时就需要考虑地址重叠的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> *ret = dst;</span><br><span class="line">	<span class="keyword">char</span>* pdst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">	<span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">	<span class="keyword">if</span> (pdst &gt; src || pdst &lt; psrc + size) &#123;</span><br><span class="line">		pdst = pdst + size - <span class="number">1</span>;</span><br><span class="line">		psrc = psrc + size - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst-- = *psrc--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst++ = *psrc++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strlen">strlen</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    assert(<span class="literal">NULL</span> != str);</span><br><span class="line">    <span class="keyword">while</span> (*str++ != <span class="string">'\0'</span>) &#123;　</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcat">strcat</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*dst,<span class="keyword">const</span> <span class="keyword">char</span>*src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">while</span> (*dst != <span class="string">'\0'</span>)	</span><br><span class="line">        dst++;<span class="comment">//要在循环体内++；因为要是*strDest最后指向该字符串的结束标志’\0’</span></span><br><span class="line">	<span class="keyword">while</span> ((*dst++ = *src++) != <span class="string">'\0'</span>);<span class="comment">//赋值+自增+判断非结尾</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcmp">strcmp</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!str1 || !str2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (*str1 == *str2 &amp;&amp; str1 != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		str1++;</span><br><span class="line">		str2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="memmove">memmove</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *pdst, <span class="keyword">const</span> <span class="keyword">void</span>* psrc, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pdst || !psrc)   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span>* dst = (<span class="keyword">char</span>*)pdst;</span><br><span class="line">	<span class="keyword">char</span> *src = (<span class="keyword">char</span>*)psrc;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">if</span> (dst &lt; src || dst &gt;(src + n - <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst++) = *(src++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dst = dst + n - <span class="number">1</span>;</span><br><span class="line">		src = src + n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst--) = *(src--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="三个线程交替打印">三个线程交替打印</span></h3><hr>
<h3><span id="类模板和模板类的区别">类模板和模板类的区别？</span></h3><hr>
<h3><span id="海量数据问题">海量数据问题</span></h3><h4><span id="十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</span></h4><h4><span id="十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></h4><hr>
<h3><span id="布隆过滤器">布隆过滤器</span></h3><h4><span id="几十亿个数经常要查找某一个数在不在里面">几十亿个数经常要查找某一个数在不在里面</span></h4><h4><span id="布隆过滤器的原理">布隆过滤器的原理。</span></h4><h4><span id="布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</span></h4><hr>
<h3><span id="stl">STL</span></h3><h4><span id="hash-map冲突如何解决">Hash Map冲突如何解决？</span></h4><p>哈希表（Hash table，也叫散列表）， 是根据关键码值( <code>Key value</code> )而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p><strong>直接定址</strong>与<strong>解决冲突</strong>是哈希表的两大特点。</p>
<h5><span id="哈希函数">哈希函数</span></h5><ol>
<li><strong>直接定制法</strong>：哈希函数为关键字的线性函数如  $H(key)=a\times key+b$</li>
<li><strong>数字分析法</strong>：此种方法通常用于数字位数较长的情况，必须数字存在一定规律，其必须知道数字的分布情况</li>
<li><strong>平方取中法</strong>：如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。这种方法适合<strong>事先不知道数据并且数据长度较小的情况</strong></li>
<li><strong>折叠法</strong>：如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为 <code>hash</code> 地址。</li>
<li><strong>除留余数法</strong>：<code>H(key)=key MOD p</code> (p&lt;=m m为表长) <code>p</code> 应为不大于 <code>m</code> 的质数或是不含 <code>20</code> 以下的质因子的合数，这样可以减少地址的重复(冲突)。</li>
</ol>
<h5><span id="哈希冲突解决方案">哈希冲突解决方案</span></h5><ol>
<li><p><strong>开放定制法</strong></p>
<p>对于哈希函数 <code>H(key)</code> ，如果 $key_1$ 和 $key_i$ 哈希冲突，那么 $key_i$ 存储的位置为 $H_i=(H(key)+d_i)mod (m)$</p>
<ol>
<li><p><strong>线性探测再散列</strong>：$d_i=c∗i$</p>
<p>例如可以取 $d_i=1$，即冲突后存储在冲突后一个位置，如果仍然冲突继续向后线性探测。</p>
</li>
<li><p><strong>平方探测再散列</strong>：$d_i=1^2,-1^2,2^2,-2^2……$</p>
</li>
<li><p>随机探测再散列(双探测再散列)：$d_i$ 是一组伪随机数列</p>
</li>
</ol>
</li>
<li><p><strong>链地址法</strong></p>
<p>产生 <code>hash</code> 冲突后在存储数据后面加一个指针，指向后面冲突的数据(链地址法是可以直接删除元素的)</p>
<p><img src="https://img-blog.csdn.net/20180520012305597" alt="这里写图片描述"></p>
</li>
<li><p><strong>公共溢出区法</strong><br>建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。</p>
</li>
<li><p><strong>再散列法(rehash)</strong></p>
<p>准备若干个 <code>hash</code> 函数，如果使用第一个 <code>hash</code> 函数发生了冲突，就使用第二个 <code>hash</code> 函数，第二个也冲突，使用第三个……</p>
</li>
</ol>
<hr>
<h4><span id="hash_map扩容发生什么">Hash_map扩容发生什么</span></h4><ol>
<li>创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到<em>sqrt</em>(<em>n</em>)范围内的数)  </li>
<li>将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换)</li>
<li>通过swap函数将新桶和旧桶交换，销毁新桶</li>
</ol>
<hr>
<h4><span id="unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</span></h4><p><code>HashSet(unordered_set)</code> 和 <code>HashMap(unordered_map)</code> 都是以 <code>hashtable</code> 作为底层机制，提供与 <code>set</code> 和<code>map</code> 完全相同的操作，但是 <code>Hash</code> 版本的容器不提供自动排序的功能，非 <code>Hash</code> 的版本是以 <code>RB-tree</code> 作为底层机制，也就提供排序的能力。总体来说，<code>hash_map</code> 查找速度会比 <code>map</code> 快，而且查找速度基本和数据数据量大小，属于常数级别；而 <code>map</code> 的查找速度是 <code>log(n)</code> 级别。</p>
<h5><span id="map与unordered_map的区别">map与unordered_map的区别</span></h5><p>他们俩存储时是根据 <code>key</code> 的 <code>hash</code> 值判断元素是否相同，而 <code>unordered_map</code> 内部元素是无序的，<code>map</code> 中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时 <code>map</code> 的 <code>key</code> 需要定义<code>operator&lt;</code>。而 <code>unordered_map</code> 需要定义 <code>hash_value</code> 函数并且重载 <code>operator==</code> 。但是很多系统内置的数据类型都自带这些。总结： <code>map</code> 重载 <code>&lt;</code> 运算符，<code>unordered_map</code> 重载 <code>==</code> 运算符。</p>
<p><strong>set/map</strong>底层实现的机制是<strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，默认是按升序排序的。在红黑树上做查找、插入、删除操作的时间复杂度为 <code>O(logN)</code> 。(<strong>比较稳定</strong>)</p>
<p><strong>红黑树的缺点</strong>：空间占用率高，每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</p>
<p><strong>std::unordered_map</strong>对应哈希表，哈希表的特点就是<strong>查找效率高</strong>，时间复杂度为常数级别<strong>O(1)</strong>，而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 <code>std::unordered_map</code> 容器。而如果对<strong>内存大小比较敏感</strong>或者<strong>数据存储要求有序</strong>的话，则可以用 <code>std::map</code> 容器。</p>
<h5><span id="为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？<strong>红黑树查询效率为什么快？</strong></span></h5><p>红黑树不仅是作为 <code>AVL</code> 的工程版本，在增加节点颜色、不严格平滑等特性实现了更高效的插入和删除。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。<strong>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种弱平衡二叉树，相对于要求严格的 <code>AVL</code> 树来说，它的<strong>旋转次数少</strong>，所以对于<strong>搜索，插入，删除操作较多的情况</strong>下，通常使用红黑树。<code>AVL</code> 树是高度平衡的，频繁的插入和删除，会引起频繁的 <code>rebalance</code> ，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多<strong>两次</strong>旋转，删除最多<strong>三次</strong>旋转。</p>
<p>红黑树满足以下特征：</p>
<ol>
<li><strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</strong></li>
<li><strong>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;=2bd</strong></li>
<li><strong>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;=2log(n+1)</strong></li>
</ol>
<hr>
<h4><span id="vector相关">vector相关</span></h4><h5><span id="vector空间的动态增长">vector空间的动态增长</span></h5><h5><span id="vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</span></h5><hr>
<h4><span id="stl里的内存池实现">STL里的内存池实现</span></h4><p>首先我们需要明确, 内存池的目的到底是什么?我们每次使用 <code>new T</code> 来初始化类型 <code>T</code> 的时候, 其实发生了<strong>两步</strong>操作：</p>
<p> 第一步是<strong>内存分配</strong>， 这一步使用的其实不是 <code>new</code> 而是 <code>operator new</code> (也可以认为就是C语言中的 <code>malloc</code> )，这一步是直接和操作系统打交道的，操作系统可能需要经过相对繁琐的过程才能将一块指向空闲内存的指针返回给用户，所以这也是 <code>new</code> 比较耗时的一部分。</p>
<p>第二步是<strong>使用构造函数初始化该内存</strong>，这是我们比较熟悉。既然内存分配耗时。那我们很容易想到的就是一次性分配一大块内存，然后在用户需要的时候再划分其中一部分给用户。这样<strong>一次分配，多次使用</strong>， 自然而然提高了效率。而用来<strong>管理这所谓的一大块内存的数据结构</strong>，也就是今天我们要说的<strong>内存池</strong>。另外一个好处在于，频繁地使用 <code>new</code> 将导致系统内存空间碎片化严重，容易导致的后果就是很难找到一块连续的大块内存，空间利用率低。</p>
<p><code>STL</code> 内存分配分为<strong>一级分配器</strong>和<strong>二级分配器</strong>，一级分配器就是采用<strong>malloc分配内存</strong>，二级分配器采用<strong>内存池</strong>。</p>
<p>第二级配置器目的解决小型区块造成的内存碎片问题。</p>
<p>二级分配器设计的非常巧妙，分别给 <code>8byte</code> ，<code>16byte</code> ,…, <code>128byte</code> 等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块 <code>10K</code> 的内存，那么就找到最小的大于等于 <code>10byte</code> 的块，也就是 <code>16byte</code> ，从 <code>16byte</code> 的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。如果要分配的内存大于 <code>128byte</code> 则直接调用一级分配器。为了节省维持链表的开销，内存池采用了一个 <code>union</code> 结构体，分配器使用 <code>union</code> 里的 <code>next</code> 指针来指向下一个节点，而用户则使用 <code>union</code> 的空指针来表示该节点的地址。</p>
<p>使用<strong>自由链表(free-list)技巧</strong>。主动将不论什么小额区块的内存需求量上调至 <code>8</code> 的倍数。如需求 <code>30</code> ，则上调至<code>32</code> 。内存池可以认为由上面的一个<strong>指针数组</strong>和下面的<strong>自由链表</strong>两部分组成, 指针数组中第一个指针指向的是存放内存大小为 <code>8bytes</code> 的节点串接而成的自由链表, 之后依次是内存 <code>16bytes</code> , <code>24bytes</code> 直到 <code>128bytes</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Align = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MaxBytes = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfFreeLists = MaxBytes / Align;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfAddedNodesForEachTime = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span> MemNode &#123;</span><br><span class="line">		MemNode*	_next;</span><br><span class="line">		<span class="keyword">char</span>		_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> obj *freeLists[NumberOfFreeLists];</span><br></pre></td></tr></table></figure>
<p><code>union</code> 每个成员的起始地址都是开头的位置，所以每次仅能使用一个成员，在链表中由<code>_next</code> 指向下个内存块的地址，在分配内存时由 <code>_data</code> 指向内存首地址，长度为1 的数组放在结构体最后一个成员位置，可以访问给结构体多分配的地址空间，这种技术叫做<strong>柔性数组</strong>。这样做的好处减少了对内存块管理时额外的内存损耗。想想我们学习数据结构时实现的链表，都是通过结构体的一个成员来指向下个节点的地址，多出了一个指针 <code>4Byte</code> 的内存消耗。参考 <code>STL</code> ，内存块的管理如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="内存块示意图"></p>
<h5><span id="内存的分配和回收">内存的分配和回收</span></h5><p><img src="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>每次从系统申请内存时都通过一个辅助函数将内存增到为 <code>8</code> 的倍数，上层请求内存时寻找最小能容纳当前请求的头节点索引；当找到索引位置时，如果内存块不为空，则取出当前内存块，将之后的链表节点向前移动，如果内存不够的话，再次向系统请求新的内存。内存回收时与此理相同，通过辅助函数找到索引位置，将内存块放入首部位置，之前的内存块后移。</p>
<hr>
<h2><span id="操作系统">操作系统</span></h2><h3><span id="linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</span></h3><p>物理内存用完就会使用交换空间（swap），会导致应用运行变慢。因为需要频繁在交换空间和内存之间换入换出数据。</p>
<hr>
<h3><span id="进程和线程的区别和联系">⭐进程和线程的区别和联系</span></h3><p>我们可以说“进程”是包含“线程”的，“线程”是“进程”的一个子集。进程是资源分配的最小单位，线程是程序执行的最小单位。一个程序至少有一个进程,一个进程至少有一个线程。线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。</p>
<p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，<strong>进程是线程的容器</strong>。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。<strong>它被包含在进程之中，是进程中的实际运作单位</strong>。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p><strong>进程是由线程+内存+文件/网络句柄构成的</strong>，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。</p>
<p><strong>线程是由栈+PC(程序计数器)+TLS(线程本地存储)组成的。</strong>操作系统真正运行的是一个个的线程，而我们的进程只是它的一个容器。<strong>PC程序计数器是当前执行指令的地址</strong>，而这个指令是放在内存中。每个线程都有一串自己的指针，去指向自己当前所在内存的指针。计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的<br>这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。<strong>TLS</strong>用来存储线程所独有的数据。</p>
<ul>
<li>进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</li>
<li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li>
<li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li>
<li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li>
<li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li>
</ul>
<h3><span id="多进程和多线程的区别">多进程和多线程的区别？</span></h3><table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>多进程</strong></th>
<th><strong>多线程</strong></th>
<th><strong>总结</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用<strong>IPC</strong>；数据是分开的，<strong>同步简单</strong></td>
<td>因为共享进程数据，<strong>数据共享简单</strong>，但也是因为这个原因导致<strong>同步复杂</strong></td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td><strong>一个线程挂掉将导致整个进程挂掉</strong></td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<h5><span id="优劣">优劣</span></h5><table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<hr>
<h3><span id="临界区进程同步">临界区(进程同步)</span></h3><p>操作系统中，同一时刻内同一段代码可能会有多个<strong>进程</strong>在执行，而像 <code>文件读写</code> 、<code>硬件调用</code> 等操作都是排他性的，因此操作系统更应该做好临界区的设置。</p>
<p>临界区( <code>critical-section</code> )是解决进程协作的一个方法。将<strong>多个进程可能修改同一个共享变量的代码段</strong>设为临界区，当有进程进入临界区后，其他进程会被禁止进入，直到前一个进程离开临界区，其他进程才可以进入。即<strong>同一时刻只允许一个进程位于临界区</strong>内。伪代码形式可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//进入区</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="comment">//退出区</span></span><br><span class="line">	<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<p>临界区的实现需要满足以下三个条件：</p>
<ol>
<li><strong>互斥</strong>，即同一时刻只能有一个进程位于临界区内；</li>
<li><strong>前进</strong>，当多个进程同时等待进入临界区的时候，会有一个进程被选择进入</li>
<li><strong>有限等待</strong>，在进入区等待的进程必须在有限时间后进入临界区。</li>
</ol>
<p><strong>实现方式：</strong>对于操作系统的临界区实现，要分为<strong>抢占内核</strong>和非抢占内核来讨论。显然，非抢占内核不存在竞争的问题，因为在临界区内的进程不会被打断，除非进程主动退出。对抢占内核来说，就需要硬件或者软件（算法）上的支持来实现临界区。</p>
<p>软件支持的一个例子是 <code>Peterson</code> 算法。<code>Peterson</code> 算法的精髓在于用两个变量（或数组）来记录当前是否有进程位于临界区以及哪个进程位于临界区，这样通过在进入区检测并设置标记、退出区恢复标记可以实现临界区排他的特性。</p>
<p>硬件支持的方法是 <code>锁</code> ，从底层硬件的层面来看则是实现 <code>原子操作</code> 。进程在进入临界区前检测并申请锁，离开后释放锁。原子操作保证锁的正常运行。<br>Linux下的原子操作的数据结构是 <code>atomic_t</code> ，其定义放在 <code>&lt;linux/types.h&gt;</code> 下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125;<span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>对于单处理器单核系统来说，只要保证操作指令序列不被打断即可实现原子操作。对于简单的原子操作，<code>cpu</code> 实现上会提供单条指令，比如 <code>INC</code> 和 <code>XCHG</code> 。对于复杂的原子操作，需要包含多条指令。执行过程中，出现上下文切换行为，比如任务切换，中断处理等。这里的行为会影响原子操作的原子性。因此需要自旋锁 <code>spinlock</code> 来保证操作指令序列不会在执行的中途受干扰。</p>
<p>但是如果对于多处理器或者多核的系统，原子操作的实现除了需要 <code>spinlock</code> 来保证外，还需要保证不会受到同处理器上其他核，或者其他处理器的影响。当其他核上执行的指令访问的内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。</p>
<p>在 <code>x86架构</code> 中，提供了指令前缀 <code>LOCK</code> 。<code>LOCK</code> 保证了指令不会受其他处理器或 <code>cpu</code> 核的影响。在 <code>PentiumPro</code> 之前，<code>LOCK</code> 的实现，是通过锁住 <code>bus</code> （总线），从而阻止其他 <code>cpu</code> 核的内存访问。可想而知，这种实现是非常低效的。从 <code>PentiumPro</code> 开始，<code>LOCK</code> 只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<p><img src="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg" alt="img"></p>
<p>现在，大多数的 <code>x86</code> 处理器都支持了 <code>CAS</code> 的硬件实现，保证了多处理器多核系统下的原子操作的正确性。<code>CAS</code> 的实现同样无需锁住总线，只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<hr>
<hr>
<h3><span id="原子操作">原子操作</span></h3><p>原子操作指的是不可再分的指令操作，即在执行原子操作时不可能被打断，要么原子操作没有执行，要么已经执行完毕。原子操作的实现必须需要硬件的支持，操作系统仅仅是在硬件指令的基础之上进行一次封装。对于没有实现原子操作的硬件，则需要操作系统从软件算法层面进行支持。</p>
<h4><span id="cas原子操作compare-and-swap">CAS原子操作(compare and swap)</span></h4><p>如果一个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是原子的(atomic)。</p>
<p><strong>为什么要有CAS：</strong>因为通过锁实现原子操作时，其他线程必须等待已经获得锁的线程运行完以后才能获得资源，这样就会占用系统的大量资源。<code>CAS</code> <strong>可以通过硬件层面的阻塞实现原子操作的安全</strong>。</p>
<p><code>CAS</code> 原子操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">    ATOMIC();</span><br><span class="line">    <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">    <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">    	*reg = newval;</span><br><span class="line">    END_ATOMIC();</span><br><span class="line">    <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了还有如下几个原子操作：</p>
<ul>
<li><strong>Fetch And Add：</strong>一般用来对变量做 <code>+1</code> 的原子操作。</li>
<li><strong>Test-and-set：</strong>写值到某个内存位置并传回其旧值。汇编指令 <code>BST</code> 。</li>
<li><strong>Test and Test-and-set</strong>：用来实现多核环境下相互排斥锁。</li>
</ul>
<p>C++11中的 <code>STL</code> 中的 <code>atomic</code> 类的函数能够跨平台使用。（完整的C++11的原子操作可參看 <a href="http://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">Atomic Operation Library</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( volatile std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br></pre></td></tr></table></figure>
<p>具体使用的时候可以如下实现无锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mutex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unlock = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">test_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!(__sync_bool_compare_and_swap (&amp;mutex,lock, <span class="number">1</span>) )) usleep(<span class="number">100000</span>);</span><br><span class="line">        count++;</span><br><span class="line">        __sync_bool_compare_and_swap (&amp;mutex, unlock, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="进程间如何通信">进程间如何通信？</span></h3><p><img src="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg" alt="6种Linux进程间的通信方式6种Linux进程间的通信方式"></p>
<h4><span id="应用场景">应用场景</span></h4><ol>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ol>
<p>现在 <code>Linux</code> 使用的进程间通信方式包括：</p>
<h4><span id="管道">管道</span></h4><p><strong>管道的概念</strong></p>
<ul>
<li>管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。</li>
<li>一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。</li>
<li><strong>数据被一个进程读出后，将被从管道中删除</strong>，其它读进程将不能再读到这些数据。</li>
<li>管道提供了简单的流控制机制，<strong>进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞</strong></li>
<li>管道包括<strong>无名管道</strong>和<strong>有名管道</strong>两种，前者<strong>用于父进程和子进程间的通信，后者可用于运行于同一系统中的任意两个进程间的通信</strong>。</li>
</ul>
<h5><span id="无名管道pipe">无名管道(pipe)</span></h5><p>无名管道是一种<strong>半双工</strong>的通信方式，数据只能<strong>单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系一般指的是父子关系。无明管道一般用于<strong>两个不同进程之间的通信</strong>。当一个进程创建了一个管道，并调用 <code>fork</code> 创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。</p>
<p><img src="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg" alt="这里写图片描述"></p>
<p>无名管道创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符(<strong>fd</strong>)：</p>
<ul>
<li><code>filedis[0]</code> 用于读管道。</li>
<li><code>filedis[1]</code> 用于写管道。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161031215306696" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20161031215332079" alt="img"></p>
<ul>
<li>管道通讯是<strong>单向</strong>的，有固定的<strong>读端和写端</strong>。</li>
<li>数据被进程从管道读出后，在管道中该数据就不存在了。</li>
<li>当进程去<strong>读取空管道</strong>的时候，进程会阻塞。</li>
<li>当进程<strong>往满管道写入数据</strong>时，进程会阻塞。</li>
<li>管道容量为 <strong>64KB</strong>(缓存区有限)</li>
<li><strong>必须在系统调用fork( )前调用pipe( )，否则子进程将不会继承文件描述符</strong></li>
</ul>
<hr>
<h5><span id="有名管道fifo">有名管道(FIFO)</span></h5><p>有名管道和无名管道基本相同，但也有不同点：无名管道只能由父子进程使用；但是通过有名管道，<strong>不相关的进程也能交换数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_tmode)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>pathname：FIFO文件名</p>
</blockquote>
<blockquote>
<p>mode：属性（见文件操作章节）</p>
</blockquote>
<p><strong>一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO。</strong></p>
<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
<hr>
<h4><span id="信号signal">信号(signal)</span></h4><ul>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
<hr>
<h4><span id="消息队列message-queue">消息队列(message queue)</span></h4><ul>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>
<li>消息队列<strong>克服了信号传递信息少</strong>、<strong>管道只能承载无格式字节流以及缓冲区大小受限</strong>等缺点。</li>
<li>消息队列 ( <code>message queue</code> )与 <code>PIPE</code> 相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符( <code>message_type</code> )。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照<strong>先进先出</strong>的顺序取出，也可以<strong>只取出符合某个识别符的消息</strong>(有多个这样的消息时，同样按照先进先出的顺序取出)。</li>
<li>消息队列与 <code>PIPE</code> 的另一个不同在于它并不使用文件 <code>API</code> 。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</li>
</ul>
<hr>
<h4><span id="共享内存shared-memory">共享内存(shared memory)</span></h4><ul>
<li>共享内存就是<strong>映射一段能被其他进程所访问的内存</strong>，这段共享内存<strong>由一个进程创建，但多个进程都可以访问</strong>。共享内存是⭐<strong>最快</strong>⭐的 <code>IPC(interprocess communication)</code> 方式，它是<strong>针对其他进程间通信方式运行效率低而专门设计</strong>的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<ul>
<li>共享内存与多线程共享 <code>global data</code> 和 <code>heap</code> 类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用 <code>semaphore</code> 同步，也可以在共享内存中建立 <code>mutex</code> 或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，<strong>不涉及内核的拷贝</strong>，所以它是效率最高的 <code>IPC</code> 方式。</li>
</ul>
</li>
<li><strong>优点</strong>：无须复制，快捷，信息量大</li>
<li><strong>缺点</strong>：<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
<hr>
<h4><span id="信号量semophore">信号量(semophore )</span></h4><ul>
<li>信号量是一个计数器，可以用来<strong>控制多个线程对共享资源的访问</strong>，它不是用于交换大批数据，而是用于多线程之间的同步。它常作为一种<strong>锁机制</strong>，防止某进程在访问资源时其它进程也访问该资源。因此，<strong>主要作为进程间以及同一个进程内不同线程之间的同步手段</strong>。</li>
<li>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法。比如在任一时刻只能有一个执行线程访问代码的<strong>临界区</strong>。临界区是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说<strong>信号量是用来调协进程对共享资源的访问的</strong>。</li>
<li>信号量是一个特殊的变量，程序对其访问都是<strong>原子操作</strong>，且只允许对它进行等待(<code>P(sv)</code>) 和发送(<code>V(sv)</code>)信息操作。最简单的信号量是只能取 <code>0</code> 和 <code>1</code> 的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。</li>
<li>缺点是<strong>信号量有限</strong>。</li>
</ul>
<h5><span id="信号量工作原理">信号量工作原理</span></h5><p>由于信号量只能进行两种操作等待和发送信号，即 <code>P(sv)</code> 和 <code>V(sv)</code> ，他们的行为是这样的：</p>
<ul>
<li><strong>P(sv)等待：</strong>如果 <code>sv</code> 的值大于零，就给它减 <code>1</code> ；如果它的值为零，就<strong>挂起</strong>该进程的执行</li>
<li><strong>V(sv)发送：</strong>如果有其他进程因等待 <code>sv</code> 而被挂起，就让它恢复运行，如果没有进程因等待 <code>sv</code> 而挂起，就给它加 <code>1</code> 。</li>
</ul>
<p>举个例子，就是两个进程共享信号量 <code>sv</code> ，一旦其中一个进程执行了 <code>P(sv)</code> 操作，它将得到信号量，并可以进入临界区，使 <code>sv</code> 减1。而第二个进程将被阻止进入临界区，因为当它试图执行 <code>P(sv)</code> 时，<code>sv</code> 为 <code>0</code> ，它会被挂起以等待第一个进程离开临界区域并执行 <code>V(sv)</code> 释放信号量，这时第二个进程就可以恢复执行。</p>
<p>其实从意义上来说，<code>semaphore</code> 就是一个计数锁，它允许被 <code>N</code> 个进程获得。当有更多的进程尝试获得 <code>semaphore</code> 的时候，就必须等待有前面的进程释放锁。当 <code>N</code> 等于 <code>1</code> 的时候，<code>semaphore</code> 与 <code>mutex</code> 实现的功能就完全相同。许多编程语言也使用 <code>semaphore</code> 处理多线程同步的问题。一个 <code>semaphore</code> 会一直存在在内核中，直到某个进程删除它。</p>
<hr>
<h4><span id="套接字socket">套接字(socket)</span></h4><ul>
<li><p>套接字也是一种进程间通信机制，与其他通信机制不同的是，它<strong>可用于不同机器间的进程通信</strong>。</p>
</li>
<li><p><strong>优点：</strong></p>
<ol>
<li>传输数据为<strong>字节级</strong>，传输数据<strong>可自定义</strong>，数据量小效率高</li>
<li>传输数据<strong>时间短</strong>，<strong>性能高</strong></li>
<li>适合于客户端和服务器端之间信息<strong>实时交互</strong></li>
<li>可以<strong>加密</strong>，<strong>数据安全性强</strong></li>
</ol>
</li>
<li><strong>缺点：</strong>需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<hr>
<h3><span id="多线程间通信和同步">多线程间通信和同步</span></h3><ul>
<li>锁机制：包括互斥锁/量（<code>mutex</code>）、读写锁（ <code>reader-writer lock</code> ）、自旋锁（ <code>spin lock</code> ）、条件变量（ <code>condition variable</code> ）<ul>
<li>互斥锁/量（<code>mutex</code>）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（<code>reader-writer lock</code>）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（<code>spin lock</code>）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（<code>condition</code> ）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。<strong>条件变量始终与互斥锁一起使用</strong>。</li>
</ul>
</li>
<li>信号量机制( <code>Semaphore</code> )<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制( <code>Signal</code> )：类似进程间的信号处理</li>
<li>屏障（ <code>barrier</code> ）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于<strong>线程同步</strong>，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<hr>
<h3><span id="协程">⭐协程</span></h3><p><strong>什么是协程</strong></p>
<p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。在C++20中出现了<strong>coroutine</strong>的库。协程的作用是在同一个线程中通过保存代码执行段状态，进行代码段的分次执行，以及多个代码段的交织执行。每个代码段可以成为一个协程。协程的好处是<strong>避免了线程之间的频换切换</strong>、<strong>以及线程安全的优化</strong>（对于同一个变量的访问无需做同步控制）。</p>
<p><strong>协程是非抢占式的，线程是抢占式的。</strong></p>
<p>平时正常的程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。而协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg" alt="img"></p>
<p>协程不是被操作系统内核所管理的，而是<strong>完全由程序所控制</strong>，也就是在<strong>用户态</strong>执行。这样带来的好处是<strong>性能大幅度的提升</strong>，因为不会像线程切换那样消耗资源。</p>
<p>协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p>一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以有多个这样的特殊函数在运行，但是有一点必须明确的是：</p>
<blockquote>
<p><strong>一个线程的多个协程的运行是串行的</strong>。</p>
</blockquote>
<p>如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。<strong>当一个协程运行时，其它协程必须挂起</strong>。</p>
<p>C/C++ 语言本身是不能天然支持协程的。现有的 C++ 协程库均基于两种方案：<strong>利用汇编代码控制协程上下文的切换，以及利用操作系统提供的 API 来实现协程上下文切换</strong>。</p>
<p>在C++里，一个函数如果其函数体实现中包含 <code>co_await</code> 、<code>co_yield</code> 、<code>co_return</code> 中任何一个关键字，那么这个函数就是一个coroutine。其中：</p>
<ol>
<li><code>co_await</code>：挂起当前的coroutine。</li>
<li><code>co_return</code>：从当前coroutine返回一个结果。</li>
<li><code>co_yield</code>：返回一个结果并且挂起当前的coroutine。</li>
</ol>
<h4><span id="libco库">libco库</span></h4><ul>
<li><p><code>co_create_env()</code> 创建协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stStackMem_t</span> &#123;</span></span><br><span class="line">    stCoRoutine_t* occupy_co;  <span class="comment">// 使用该栈的协程</span></span><br><span class="line">    <span class="keyword">int</span> stack_size;            <span class="comment">// 栈大小</span></span><br><span class="line">    <span class="keyword">char</span>* stack_bp;            <span class="comment">// 栈底指针，栈从高地址向低地址增长</span></span><br><span class="line">    <span class="keyword">char</span>* stack_buffer;        <span class="comment">// 栈底</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_resume()</code> 激活协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">( stCoRoutine_t *co )</span> </span>&#123;</span><br><span class="line">    stCoRoutineEnv_t *env = co-&gt;env;</span><br><span class="line">    <span class="comment">// 获取当前正在运行的协程的结构</span></span><br><span class="line">    stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    <span class="keyword">if</span>( !co-&gt;cStart ) &#123;</span><br><span class="line">        <span class="comment">// 为将要运行的 co 布置上下文环境</span></span><br><span class="line">        coctx_make( &amp;co-&gt;ctx,(<span class="keyword">coctx_pfn_t</span>)CoRoutineFunc,co,<span class="number">0</span> );</span><br><span class="line">        co-&gt;cStart = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;pCallStack[ env-&gt;iCallStackSize++ ] = co;  <span class="comment">// 设置co为运行的线程</span></span><br><span class="line">    co_swap( lpCurrRoutine, co );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_swap()</code> 实现上下文切换，<code>co_swap</code> 具体完成三项工作：</p>
<ol>
<li>记录当前协程 <code>curr</code> 的运行栈的栈顶指针，通过 <code>char c; curr_stack_sp=&amp;c</code> 实现，当下次切换回 <code>curr</code>时，可以从该栈顶指针指向的位置继续，执行完 <code>curr</code> 后可以顺利释放该栈。</li>
<li>处理共享栈相关的操作，并且调用函数 <code>coctx_swap</code> 来完成上下文环境的切换。注意执行完 <code>coctx_swap</code>之后，执行流程将跳到新的 coroutine 也就是 pending_co 中运行，后续的代码需要等下次切换回 <code>curr</code> 时才会执行。</li>
<li>当下次切换回 <code>curr</code> 时，处理共享栈相关的操作。</li>
</ol>
</li>
<li><p>对应于 <code>co_resume</code> 函数，协程主动让出执行权则调用 <code>co_yield</code> 函数。<code>co_yield</code> 函数调用了 <code>co_yield_env</code>，将当前协程与当前线程中记录的其他协程进行切换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_env</span><span class="params">( stCoRoutineEnv_t *env )</span> </span>&#123;</span><br><span class="line">    stCoRoutine_t *last = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">2</span> ];</span><br><span class="line">    stCoRoutine_t *curr = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    env-&gt;iCallStackSize--;</span><br><span class="line">    co_swap( curr, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3><span id="五种io模型">五种IO模型</span></h3><p><strong>阻塞IO、非阻塞IO、IO多路复用、信号驱动IO以及异步IO</strong></p>
<hr>
<h3><span id="io多路复用selectpollepoll">⭐IO多路复用：select/poll/epoll</span></h3><p>所谓 <code>I/O</code> 多路复用指的是这样一个过程：</p>
<ol>
<li>我们拿到了一堆文件描述符 <code>fd</code> (不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)</li>
<li>通过调用<strong>某个函数</strong>告诉内核：“<strong>这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回</strong>”</li>
<li>当调用的这个函数返回后我们就能知道哪些文件描述符可以进行 <code>I/O</code> 操作了。</li>
</ol>
<p>也就是说<strong>通过I/O多路复用我们可以同时处理多路I/O</strong>。</p>
<p><code>select</code> ， <code>poll</code> ，<code>epoll</code> 都是 <code>IO</code> 多路复用的机制。<code>I/O</code> 多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步 <code>I/O</code> 则无需自己负责进行读写，异步 <code>I/O</code> 的实现会负责把数据从内核拷贝到用户空间。</p>
<p><code>I/O</code> 多路复用是指内核一旦发现进程指定的一个或者多个 <code>I/O</code> 条件准备读取，它就通知该进程。<code>I/O</code>多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述字时（一般是<strong>交互式输入</strong>和<strong>网络套接口</strong>），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
</ol>
<p><strong>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</strong></p>
<p><strong>select的几大缺点：</strong></p>
<p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>
<p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>
<p><strong>（3）select支持的文件描述符数量太小了，32位默认是1024，64位是2048</strong></p>
<p> <code>poll</code> 的实现和 <code>select</code> 非常相似，只是描述 <code>fd</code> 集合的方式不同，<code>poll</code> 使用 <code>pollfd</code> 结构而不是 <code>select</code> 的<code>fd_set</code> 结构，其他的都差不多。</p>
<ol>
<li><p><strong>select 时间复杂度O(n)</strong></p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
</li>
<li><p><strong>poll 时间复杂度O(n)</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，但是同样有一个缺点：</p>
<p>1、大量的 <code>fd</code> 的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   </p>
<p>2、<code>poll</code> 还有一个特点是<strong>水平触发</strong>，如果报告 <code>fd</code> 后，没有被处理，那么下次 <code>poll</code> 时会再次报告该 <code>fd</code> 。</p>
</li>
<li><p><strong>epoll 时间复杂度O(1)</strong></p>
<p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，<code>epoll</code> 会把哪个流发生了怎样的I/O事件通知我们。所以我们说 <code>epoll</code> 实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
</li>
</ol>
<h4><span id="select">select</span></h4><p><img src="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png" alt="img"></p>
<p><code>select</code> 调用过程如下：</p>
<ol>
<li>使用 <code>copy_from_user</code> 从用户空间拷贝 <code>fd_set</code> 到内核空间</li>
<li>注册回调函数 <code>__pollwait</code> </li>
<li>遍历所有 <code>fd</code> ，调用其对应的 <code>poll</code> 方法（对于 <code>socket</code> ，这个 <code>poll</code> 方法是 <code>sock_poll</code> ， <code>sock_poll</code> 根据情况会调用到 <code>tcp_poll</code> , <code>udp_poll</code> 或者 <code>datagram_poll</code> ）</li>
<li>以 <code>tcp_poll</code> 为例，其核心实现就是<strong>pollwait，也就是上面注册的回调函数。</strong></li>
<li><code>pollwait</code> 的主要工作就是把 <code>current</code> （当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于 <code>tcp_poll</code> 来说，其等待队列是 <code>sk-&gt;sk_sleep</code> （注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 <code>current</code> 便被唤醒了。</li>
<li><code>poll</code> 方法返回时会返回一个描述读写操作是否就绪的 <code>mask</code> 掩码，根据这个 <code>mask</code> 掩码给 <code>fd_set</code> 赋值。</li>
<li>如果遍历完所有的 <code>fd</code> ，还没有返回一个可读写的 <code>mask</code> 掩码，则会调用 <code>schedule_timeout</code> 是调用 <code>select</code> 的进程（也就是 <code>current</code> ）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（ <code>schedule_timeout</code> 指定），还是没人唤醒，则调用 <code>select</code> 的进程会重新被唤醒获得CPU，进而重新遍历 <code>fd</code> ，判断有没有就绪的 <code>fd</code> 。</li>
<li>把 <code>fd_set</code> 从内核空间拷贝到用户空间。</li>
</ol>
<p><img src="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png" alt="img"></p>
<p> <code>select</code> 函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure>
<p>返回值：就绪描述符的数目，超时返回 <code>0</code> ，出错返回 <code>-1</code> 。</p>
<p>函数参数介绍如下：</p>
<ol>
<li><p>第一个参数 <code>maxfdp1</code> 指定待测试的描述字个数，它的值是待测试的最大描述字加 <code>1</code> （因此把该参数命名为<code>maxfdp1</code> ），描述字 <code>0、1、2...maxfdp1 - 1</code> 均将被测试。因为文件描述符是从 <code>0</code> 开始的。</p>
</li>
<li><p>中间的三个参数 <code>readset</code> 、<code>writeset</code> 和 <code>exceptset</code> 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code> 可以理解为一个集合，这个集合中存放的是<strong>文件描述符FD</strong>，可通过以下四个宏进行设置：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 检查集合中指定的文件描述符是否可以读写</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>timeval *timeout</code> 告知内核等待所指定描述字中的任何一个就绪可花多少时间。其 <code>timeval</code> 结构用于指定这段时间的秒数和微秒数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个参数有三种可能：</p>
<p>（1）永远等待下去：仅在有一个描述字准备好 <code>I/O</code> 时才返回。为此，把该参数设置为空指针 <code>NULL</code> 。</p>
<p>（2）等待一段固定时间：在有一个描述字准备好 <code>I/O</code> 时返回，但是不超过由该参数所指向的 <code>timeval</code> 结构中指定的秒数和微秒数。</p>
<p>（3）根本不等待：检查描述字后立即返回，这称为<strong>轮询</strong>。为此，该参数必须指向一个 <code>timeval</code> 结构，而且其中的定时器值必须为 <code>0</code> 。</p>
<hr>
<h4><span id="poll">poll</span></h4><p><strong>“选举出来，立刻返回”</strong></p>
<p><code>poll</code> 的机制与 <code>select</code> 类似，与 <code>select</code> 在本质上没有多大差别，管理多个描述符也是进行<strong>轮询</strong>，根据描述符的状态进行处理，但是 <code>poll</code> <strong>没有最大文件描述符数量的限制</strong>。<code>poll</code> 和 <code>select</code> 同样存在一个缺点就是，<strong>包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</strong></p>
<p>函数格式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pollfd</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;         	  <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents;        <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>每一个 <code>pollfd</code> 结构体指定了一个<strong>被监视的文件描述符</strong>，可以传递多个结构体，指示 <code>poll()</code> 监视多个文件描述符。每个结构体的 <code>events</code> 域是监视该文件描述符的事件掩码，由用户来设置这个域。<code>revents</code> 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。<code>events</code> 域中请求的任何事件都可能在 <code>revents</code> 域中返回。合法的事件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 　　　　　　　　有数据可读。</span><br><span class="line">POLLRDNORM 　　　　  有普通数据可读。</span><br><span class="line">POLLRDBAND　　　　　 有优先数据可读。</span><br><span class="line">POLLPRI　　　　　　　　 有紧迫数据可读。</span><br><span class="line">POLLOUT　　　　　　      写数据不会导致阻塞。</span><br><span class="line">POLLWRNORM　　　　　  写普通数据不会导致阻塞。</span><br><span class="line">POLLWRBAND　　　　　   写优先数据不会导致阻塞。</span><br><span class="line">POLLMSGSIGPOLL 　　　　消息可用。</span><br></pre></td></tr></table></figure>
<p>此外，<code>revents</code> 域中还可能返回下列事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POLLER　　   指定的文件描述符发生错误。</span><br><span class="line">POLLHUP　　 指定的文件描述符挂起事件。</span><br><span class="line">POLLNVAL　　指定的文件描述符非法。</span><br></pre></td></tr></table></figure>
<p><code>timeout</code> 参数指定等待的毫秒数，无论 <code>I/O</code> 是否准备好，<code>poll</code> 都会返回。<code>timeout</code> 指定为负数值表示无限超时，使 <code>poll()</code> 一直挂起直到一个指定事件发生；<code>timeout</code> 为 <code>0</code> 指示 <code>poll</code> 调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，<code>poll()</code> 就像它的名字那样，一旦选举出来，立即返回。</p>
<p><strong>返回值和错误代码</strong><br>成功时，<code>poll()</code> 返回结构体中 <code>revents</code> 域不为 <code>0</code> 的文件描述符个数；如果在超时前没有任何事件发生，<code>poll()</code> 返回 <code>0</code> ；失败时，<code>poll()</code> 返回 <code>-1</code> ，并设置 <code>errno</code> 为下列值之一。</p>
<hr>
<h4><span id="epoll">epoll</span></h4><p><code>epoll</code> 是在 <code>2.6</code> 内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> <strong>使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的 <code>copy</code> 只需一次。</p>
<p><code>epoll</code> 使用 <code>事件</code> 的就绪通知方式，通过 <code>epoll_ctl</code> 注册 <code>fd</code> ，一旦该 <code>fd</code> 就绪，内核就会采用类似 <code>callback</code> 的回调机制来激活该 <code>fd</code> ，<code>epoll_wait</code> 便可以收到通知。</p>
<h5><span id="epoll-函数">epoll 函数</span></h5><p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>int epoll_create(int size);</strong><br>创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大。这个参数不同于 <code>select()</code> 中的第一个参数，给出最大监听的 <code>fd+1</code> 的值。需要注意的是，当创建好 <code>epoll</code> 句柄后，它就是会占用一个 <code>fd</code> 值，在 <code>linux</code> 下如果查看 <code>/proc/</code> 进程 <code>id/fd/</code> ，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
</li>
<li><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p>
<p><code>epoll</code> 的事件注册函数，它不同与 <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件 <code>epoll</code> 的事件注册函数，它不同与 <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是 <code>epoll_create()</code> 的返回值，第二个参数表示动作，用三个宏来表示<strong>EPOLL_CTL_ADD</strong>：注册新的 <code>fd</code> 到 <code>epfd</code> 中；<br><strong>EPOLL_CTL_MOD</strong>：修改已经注册的 <code>fd</code> 的监听事件；<br><strong>EPOLL_CTL_DEL</strong>：从 <code>epfd</code> 中删除一个 <code>fd</code> ；<br>第三个参数是需要监听的 <code>fd</code> ，第四个参数是告诉内核需要监听什么事，<code>struct epoll_event</code> 结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>events</code> 可以是以下几个宏的集合：<br><strong>EPOLLIN</strong> ：表示对应的文件描述符可以读（包括对端 <code>SOCKET</code> 正常关闭）；<br><strong>EPOLLOUT</strong>：表示对应的文件描述符可以写；<br><strong>EPOLLPRI</strong>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br><strong>EPOLLERR</strong>：表示对应的文件描述符发生错误；<br><strong>EPOLLHUP</strong>：表示对应的文件描述符被挂断；<br><strong>EPOLLET</strong>： 将 <code>EPOLL</code> 设为边缘触发(<strong>Edge Triggered</strong>)模式，这是相对于水平触发(<strong>Level Triggered</strong>)来说的。<br><strong>EPOLLONESHOT</strong>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 <code>socket</code> 的话，需要再次把这个 <code>socket</code> 加入到 <code>EPOLL</code> 队列里。</p>
</li>
<li><p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<p>等待事件的产生，类似于 <code>select()</code> 调用。参数 <code>events</code> 用来从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code> ，参数 <code>timeout</code> 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
</li>
</ol>
<h5><span id="工作模式">工作模式</span></h5><p><code>epoll</code> 对文件描述符的操作有两种模式：<code>LT（level trigger）</code> 和 <code>ET（edge trigger）</code> 。<code>LT</code> 模式是默认模式，<code>LT</code> 模式与 <code>ET</code> 模式的区别如下：</p>
<ul>
<li><strong>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></li>
<li><strong>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。</strong></li>
</ul>
<p><code>ET</code> 模式在很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 <code>LT</code> 模式高。<code>epoll</code> 工作在 <code>ET</code> 模式的时候，必须使用<strong>非阻塞套接口</strong>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h5><span id="epoll的优点">epoll的优点：</span></h5><ol>
<li>没有最大并发连接的限制，能打开的 <code>FD</code> 的上限远大于1024（1G的内存上能监听约10万个端口）</li>
<li>效率提升，不是轮询的方式，不会随着 <code>FD</code> 数目的增加效率下降。只有活跃可用的 <code>FD</code> 才会调用 <code>callback</code> 函数。即 <code>Epoll</code> 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>Epoll</code> 的效率就会远远高于 <code>select</code> 和 <code>poll</code> 。</li>
<li>内存拷贝，利用 <code>mmap()</code> 文件映射内存加速与内核空间的消息传递；即 <code>epoll</code> 使用 <code>mmap</code> 减少复制开销。</li>
</ol>
<h5><span id="边缘触发的io应该怎么写">边缘触发的IO应该怎么写？</span></h5><hr>
<h3><span id="缺页中断">缺页中断</span></h3><hr>
<h3><span id="银行家算法防止死锁">银行家算法：防止死锁</span></h3><p>死锁主要有以下几种预防方式：</p>
<ul>
<li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li>有序资源分配法</li>
<li><strong>银行家算法</strong></li>
</ul>
<hr>
<h2><span id="计算机网络">计算机网络</span></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcjvgSoF3zeGINoyibX5tpfgfQwBABm2KMEnohSmkRXjzicCuQtt4IWsc9fniahl1mW39gS674icZibqibQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h3><span id="tcpip">TCP/IP</span></h3><h4><span id="udp和tcp的差别">⭐UDP和TCP的差别</span></h4><p><strong>UDP：</strong></p>
<ul>
<li><strong>无连接</strong>：减少了开销和发送前时延；</li>
<li><strong>尽最大努力交付</strong>：不保证可靠交付；</li>
<li><strong>面向报文</strong>：对应用层交下来的报文既不合并，也不拆分，保留这些报文的边界。</li>
<li><strong>没有拥塞控制</strong>：网络拥塞不会使源主机发送速率降低，允许在网络拥塞时丢失一些数据，却不允许数据有太大的时延。</li>
<li><strong>支持一对一、一对多、多对一、多对多的交互通信</strong></li>
<li><strong>首部开销小：</strong> 首部长度只有 8 字节，比 TCP 的 20 字节短。</li>
</ul>
<p><strong>TCP:</strong></p>
<ul>
<li><strong>面向连接：</strong> 传输前需建立连接，传输完成需释放连接；TCP 连接是一条<strong>逻辑连接</strong>。</li>
<li><strong>点对点：</strong> 每一条 TCP 连接只能有两个端点；</li>
<li><strong>提供可靠交付：</strong> 无差错、不丢失、不重复、不失序；</li>
<li><strong>全双工通信：</strong> 设有发送缓存和接收缓存，允许双方随时发送数据。</li>
<li><strong>面向字节流：</strong> TCP 把应用进程交下来的数据看作一连串的无结构字节流；</li>
</ul>
<h4><span id="计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</span></h4><h5><span id="地址解析协议-arp">地址解析协议 ARP</span></h5><p><img src="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png" alt="1568551356084"></p>
<ul>
<li><strong>APR 协议作用：</strong> 已经知道一个机器的 <strong>IP 地址</strong>，需要找出对应的<strong>硬件地址</strong>。<ul>
<li><strong>RARP 协议</strong>：现在的 <code>DHCP</code> 协议包含逆地址解析协议功能，即从<strong>硬件地址</strong>找出其 <strong>IP 地址</strong>。</li>
</ul>
</li>
<li><strong>ARP 协议工作原理：</strong> 网络层使用 <code>IP</code> 地址，但实际网络链路上传送数据帧时，最终必须使用该网络的硬件地址( <code>MAC</code> )。<code>ARP</code> 解决方法是在<strong>主机 ARP 高速缓存</strong> 中存放一个从 <code>IP</code> 地址到硬件地址的映射表，并实时动态更新（新增或超时删除）。<ul>
<li>当主机 A 要向主机 B 发送 <code>IP</code> 数据报时，就在其 <code>ARP</code> 高速缓存中查看有无主机 B 的 <code>IP</code> 地址，如有就查找并<strong>写入 MAC 帧</strong>，并传输。</li>
<li>有可能查不到主机 B 的 <code>IP</code> 地址，可能主机 B 刚入网，可能主机 A 刚加电（高速缓存为空）。在这种情况下，主机 A 就自动运行 <code>ARP</code>，通过广播请求分组找出主机 B 的硬件地址。</li>
</ul>
</li>
<li><strong>ARP 协议工作流程：</strong><ol>
<li>主机 A 在本局域网上发送一个 <code>ARP</code> 请求分组，在本局域网上所有主机上运行的 <code>ARP</code> 进程都收到此请求分组。</li>
<li>主机 B 收下这个 <code>ARP</code> 请求，并向主机 A 发送响应分组（普通的单播，发送给主机 A ）。同时，把请求分组里 A 的 <code>IP</code> 地址到硬件地址的映射写入主机 B 的 <code>ARP</code> 高速缓存中。</li>
<li>主机 A 收到主机 B 的响应分组后，就在 <code>ARP</code> 高速缓存中写入主机 B 的 <code>IP</code> 地址到硬件地址的映射。</li>
</ol>
</li>
<li><strong>ARP生存时间：</strong> 超过生存时间（例如 10 ~ 20 分钟）的项目从高速缓存中删掉。这样如果 B 更换了设备， A 无法找到原主机 B ，但过了一段时间， A 的 <code>ARP</code> 高速缓存中已经删除了 B 原先硬件地址，于是 A 重新广播发送 <code>ARP</code> 请求分组，找到新的 B 硬件地址。</li>
</ul>
<hr>
<h4><span id="三次握手四次挥手">三次握手四次挥手</span></h4><h4><span id="get和post的区别">get和post的区别</span></h4><h4><span id="tcp三次握手如果第三次客户端发出的信息服务器没收到怎么办">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</span></h4><hr>
<h3><span id="http">HTTP</span></h3><h4><span id="http状态码">HTTP状态码</span></h4><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p><strong>HTTP状态码列表:</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/" target="_blank" rel="noopener">客户端</a>应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
<hr>
<h4><span id="https的通信过程">⭐HTTPS的通信过程</span></h4><p><code>HTTPS</code> 是一种通过计算机网络进行安全通信的传输协议。<code>HTTPS</code> 经由 <code>HTTP</code> 进行通信，但利用 <strong>SSL/TLS</strong> 来加密数据包。 <code>HTTPS</code> 的通信过程，充分利用了各种加密算法及其特性。</p>
<hr>
<h4><span id="getpost-区别">get/post 区别</span></h4><hr>
<h4><span id="httphttps-10-11-20的特点和区别">http/https 1.0、1.1、2.0的特点和区别</span></h4><hr>
<h4><span id="从浏览器输入网址到出现页面经过了哪些阶段">从浏览器输入网址到出现页面经过了哪些阶段</span></h4><ol>
<li><p><strong>输入网址</strong>：</p>
<p>URL的形式： <code>schema://host:port/path?query#fragment</code></p>
<p>　　<code>-schema</code> : 协议，例如 <code>http</code> , <code>https</code> ,  <code>ftp</code> 等</p>
<p>　　<code>-host</code> : 域名或者 <code>ip</code> 地址</p>
<p>　　<code>-port</code> ： 端口，<code>http</code> 默认端口 <code>80</code> ，可以省略</p>
<p>　　<code>-path</code> ： 路径，例如 <code>/abc</code>   <code>/a/b/c</code> </p>
<p>　　<code>-query</code> : 查询参数，例如 <code>token=sdfs2223fds2&amp;name=sdffaf</code></p>
<p>　　<code>-fragment</code> : 锚点（哈希 <code>Hash</code> ），用于定位页面的某个位置。</p>
<p>符合规则的URL</p>
<p>　　<a href="http://www.baidu.com/java/web?flag=1#function" target="_blank" rel="noopener">http://www.baidu.com/java/web?flag=1#function</a></p>
</li>
<li><p><strong>缓存解析</strong></p>
<p>浏览器获取了这个url，它先去缓存当中看看有没有，依次从浏览器缓存-&gt;系统缓存-&gt;路由器缓存当中查看，如果有从缓存当中显示页面，这样是不需要发送http请求的。如果没有那就进行步骤3。<br>缓存就是把之前访问的web资源，比如一些js，css，图片什么的保存在本机的内存或者磁盘当中。</p>
</li>
<li><p><strong>域名解析</strong></p>
<p>当缓存中没有这个url的时候，就需要发送http请求了，那么在发送http请求之前，需要先进行<strong>DNS解析</strong>将域名解析成 ip 地址。<strong>DNS解析</strong>存在着多级缓存：</p>
<ul>
<li>浏览器的DNS缓存</li>
<li>系统的DNS缓存</li>
<li>路由器的DNS缓存</li>
<li>网络运营商的DNS缓存（中国移动，中国电信）</li>
<li>上述都没有找到，则会采取递归的方式，向<strong>根服务器</strong>进行查询，根服务器告诉本地DNS服务器域服务器的地址，本地DNS向<strong>域服务器</strong>发出请求，域服务器告诉本地服务器<strong>域名解构服务器</strong>的地址，本地服务器向域名解构服务器发出请求，收到域名和IP的关系，本地服务器再返回给浏览器并将对应关系保存在缓存中以便下一次使用。</li>
</ul>
<hr>
<p><strong>DNS优化</strong></p>
<ul>
<li><strong>DNS缓存</strong><br>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li>
<li><strong>DNS负载均衡</strong><br>DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，</li>
</ul>
</li>
<li><p><strong>tcp链接，三次握手</strong></p>
<p>在域名解析之后，浏览器向服务器发起了http请求，tcp连接，三次握手建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接。</p>
<p>（1）客户端向服务器发送连接请求报文；<br>（2）服务器端接受客户端发送的连接请求后后回复ACK报文，并为这次连接分配资源。<br>（3）客户端接收到ACK报文后也向服务器端发生ACK报文，并分配资源。</p>
<p>这样TCP连接就建立了。<br>在此之后，浏览器开始向服务器发送http请求，请求数据包。请求信息包含一个头部和一个请求体。</p>
</li>
<li><p><strong>服务器收到请求</strong></p>
<p>服务器收到浏览器发送的请求信息，返回一个响应头和一个响应体。</p>
</li>
<li><p><strong>浏览器页面渲染</strong></p>
<ul>
<li>处理HTML标记并构建DOM树；</li>
<li>处理CSS标记并构建CSSDOM树；</li>
<li>将DOM和CSSOM合并为一颗渲染树；</li>
<li>根据渲染树来布局，以计算每个节点的几何信息(重排)</li>
<li>将各个结点绘制到屏幕上(重绘)</li>
<li>如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。</li>
</ul>
</li>
<li><p><strong>断开连接，四次挥手</strong></p>
</li>
</ol>
<hr>
<h3><span id="cache的结构与工作原理">Cache的结构与工作原理</span></h3><p><a href="https://blog.csdn.net/baidu_35679960/article/details/78610804" target="_blank" rel="noopener">https://blog.csdn.net/baidu_35679960/article/details/78610804</a></p>
<p>首先，要想理解cache，先理解内存。内存的简单表示如下图，内存里面的内容的查找是根据地址来进行的，也就是说内存包含两点①地址②内存的内容（存的数据），根据地址来找数据。</p>
<p><img src="https://img-blog.csdn.net/20171123102431734" alt="img"></p>
<hr>
<h2><span id="数据库">数据库</span></h2><h3><span id="mysql相关">Mysql相关</span></h3><p><strong>索引是个什么样的数据结构呢?</strong></p>
<p>索引的数据结构和具体存储引擎的实现有关, 在 <code>MySQL</code> 中使用较多的索引有 <code>Hash索引</code> ，<code>B+</code> 树索引等,而我们经常使用的 <code>InnoDB</code> 存储引擎的默认索引实现为：<code>B+</code> 树索引。</p>
<ul>
<li><code>hash索引</code> 底层就是 <code>hash表</code> ，进行查找时，调用一次 <code>hash</code> 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。<code>B+</code> 树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
<li><code>hash索引</code> 进行等值查询更快(一般情况下)，但是却<strong>无法进行范围查询</strong>。因为在 <code>hash索引</code> 中经过 <code>hash函数</code> 建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询；而 <code>B+树</code> 的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似)，天然支持范围。</li>
<li><code>hash索引</code> 任何时候都避免不了<strong>回表查询数据</strong>，而 <code>B+树</code> 在符合某些条件(<strong>聚簇索引</strong>，<strong>覆盖索引</strong>等)的时候可以只通过索引完成查询。</li>
</ul>
<hr>
<p><strong>上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?</strong></p>
<p>在 <code>B+树</code> 的索引中，叶子节点可能存储了当前的 <code>key</code> 值，也可能存储了当前的 <code>key</code> 值以及整行的数据，这就是<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。在 <code>InnoDB</code> 中，只有<strong>主键索引</strong>是<strong>聚簇索引</strong>，如果没有主键，则挑选一个唯一键建立聚簇索引.如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<p>事务特性</p>
<ul>
<li>持久型数据库怎么实现的</li>
<li>数据库有哪几种日志</li>
<li>分布式下还能满足ACID吗</li>
<li>数据库有哪几种锁</li>
<li>联合索引知道吗</li>
</ul>
<h2><span id="其他">其他</span></h2><h3><span id="从两个文件各含50亿个url中找出共同的url">从两个文件(各含50亿个url)中找出共同的url</span></h3><blockquote>
<p>给定a、b两个文件，各存放50亿个url，每个url各占用64字节，内存限制是4G，如何找出a、b文件共同的url？</p>
</blockquote>
<p>可以估计每个文件的大小为 <code>5G*64=300G</code> ，远大于 <code>4G</code> 。所以不可能将其完全加载到内存中处理。考虑采取<strong>分而治之</strong>的方法。<br>遍历文件 <code>a</code> ，对每个 <code>url</code> 求取 <code>hash(url)%1000</code>，然后根据所得值将 <code>url</code> 分别存储到 <code>1000</code> 个小文件（设为<code>a0,a1,...a999</code> ）当中。这样每个小文件的大小约为 <code>300M</code> 。遍历文件 <code>b</code> ，采取和 <code>a</code> 相同的方法将 <code>url</code> 分别存储到 <code>1000</code> 个小文件(<code>b0,b1....b999</code>)中。这样处理后，所有可能相同的 <code>url</code> 都在对应的小文件( <code>a0 vs b0, a1 vs b1....a999 vs b999</code> )当中，不对应的小文件（比如 <code>a0 vs b99</code> ）不可能有相同的url。然后我们只要求出 <code>1000</code> 对小文件中相同的 <code>url</code> 即可。<br>比如对于 <code>a0 vs b0</code> ，我们可以遍历 <code>a0</code> ，将其中的 <code>url</code> 存储到 <code>hash_map</code> 当中。然后遍历 <code>b0</code> ，如果 <code>url</code> 在 <code>hash_map</code> 中，则说明此 <code>url</code> 在 <code>a</code> 和 <code>b</code> 中同时存在，保存到文件中即可。<br>如果分成的小文件不均匀( <code>hash</code> 的问题)，导致有些小文件太大（比如大于 <code>2G</code> ），可以考虑将这些太大的小文件再按类似的方法分成小小文件即可。</p>
<hr>
<p> 无名管道和有名管道的区别</p>
<p>CAS（compare and swap）</p>
<p>cache的结构，工作原理详细介绍一下，组相联是什么概念。</p>
<p>虚拟地址到物理地址的转换过程</p>
<p>水平触发和边缘触发</p>
<p>一致性哈希算法</p>
<p> 编译型语言和解释型语言的区别 </p>
<p> socket通信为什么不用网络，而用本地 </p>
<p> 进程间通信的方式（你用这个的时候，你是怎么考虑的，为什么要用这个方式） </p>
<p> 说一下epoll </p>
<p> 多线程间通信和同步 </p>
<p> STL底层内存分配 </p>
<p> 问为什么windows vector是1.5倍，linux是2倍 </p>
<p> 协程的原理和具体的操作，以及跟线程的区别 </p>
<p> 协程的创建受什么影响 </p>
<p> 会原子操作吗 </p>
<p> 编译型语言和解释型语言的区别 </p>
<p> 如何把UDP变得可靠起来 </p>
<p> 了解一些中间件吗(说了一大堆，我都不会，我很绝望) </p>
<p> 说一下QUIC </p>
<p> 共享内存如何把一颗二叉树给读出来 </p>
<p> 12个瓶子，其中有一个不知道轻重，你如何查出来 </p>
<p> 某个线程CPU占比高，你如何排查出问题</p>
<p>RALL机制 </p>
<p> 四大智能指针 </p>
<p> weak_ptr为什么可以解决循环引用，底层怎么实现的，然后又讨论了一下一些应用场景和坑点 </p>
<p> 智能指针是线程安全的吗（这里，我崩了，我项目涉及多线程，我居然不能回答好这个问题，后面也因为这个问题导致了面试官对我的印象很不友好） </p>
<p> 说一下Reactor模式。 </p>
<p> Reactor模式是半同步半异步的吗（是的） </p>
<p> 那你还知道别的模式吗（本来想说proactor，但是英语太差，说不出来，只是说了个P字头的，然后面试官也知道我英语菜鸡。。） </p>
<p> 说一下怎么优化Reactor </p>
<p> 定时器是怎么做的。 </p>
<p> 说一下四次挥手，说完并且也说出来全双工，然后问我timewait，回答出来2msl和作用后又问我过多timewait会产生什么影响，这里回答的不太好，主要是有点忘记了，又问我怎么处理，我说修改linux内核的一些设置，面试官不太满意，提示我socket怎么处理，想起来是某个参数，但是我记不住呀，由此面试官可以看出来我网络编程凉凉。 </p>
<p> QUIC解决了什么问题（我答非所问） </p>
<p> 算法题：有100万个数字，求前K个数字 </p>
<p> 说一下堆排序</p>
<p>TCP发包发很大导致分包，如何怎么处理（面试官还结合ET和LT的区别来问）</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面经/" rel="tag"># 面经</a>
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/17/1030. 距离顺序排列矩阵单元格/" rel="next" title="Leetcode_1030 距离顺序排列矩阵单元格">
                <i class="fa fa-chevron-left"></i> Leetcode_1030 距离顺序排列矩阵单元格
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/01/705. 设计哈希集合/" rel="prev" title="Leetcode_705 设计哈希集合">
                Leetcode_705 设计哈希集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">336</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">后台开发知识点汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.</span> <span class="nav-text">C++线程中的几种锁/互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">互斥锁(Mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">条件锁(condition_variable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">自旋锁(spinlock_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">读写锁(shared_mutex)/共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">递归锁(recursive_mutex)/可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">定时锁(time_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">两种基本的锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.7.1.</span> <span class="nav-text">在条件变量中只能使用std::unique_lock&lt; std::mutex &gt; 说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.</span> <span class="nav-text">C++中thread操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">std::thread构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">detach()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">wait()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">wait_for()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">notify_all/notify_one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">虚假唤醒</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.</span> <span class="nav-text">C++多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">多态有哪几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">虚函数的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">为什么析构函数必须是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">为什么C++默认的析构函数不是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">为什么构造函数不能是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">静态成员及静态成员函数能不能被继承？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.8.</span> <span class="nav-text">友元可以继承吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.9.</span> <span class="nav-text">多态中构造函数/析构函数调用顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.10.</span> <span class="nav-text">类成员函数中重载/重写/隐藏的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.11.</span> <span class="nav-text">钻石继承问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.</span> <span class="nav-text">C++的四种cast</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">哪种cast更加接近C的强制类型转换？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.</span> <span class="nav-text">C++智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">auto_ptr(弃用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">unique_ptr(替换auto_ptr)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">智能指针是线程安全的吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.</span> <span class="nav-text">C++对象的内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">普通对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">派生类的对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">vtable中虚函数指针的排列顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.</span> <span class="nav-text">Volitale关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">volatile指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.2.1.</span> <span class="nav-text">什么是可见性？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.8.</span> <span class="nav-text">C++中指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.9.</span> <span class="nav-text">C++中new与malloc的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.10.</span> <span class="nav-text">C++ 内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.</span> <span class="nav-text">C++存储类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">auto 自动变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.2.</span> <span class="nav-text">register 寄存器变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.3.</span> <span class="nav-text">static 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.4.</span> <span class="nav-text">extern关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.5.</span> <span class="nav-text">mutable 存储类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.6.</span> <span class="nav-text">thread_local 存储类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.</span> <span class="nav-text">std::move()语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.13.</span> <span class="nav-text">右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.13.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.13.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.13.3.</span> <span class="nav-text">右值引用有办法指向左值吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.13.4.</span> <span class="nav-text">完美转发 std::forward()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.13.5.</span> <span class="nav-text">auto&amp;&amp;也是这个意思</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.</span> <span class="nav-text">C++内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.1.</span> <span class="nav-text">内联函数有什么优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.2.</span> <span class="nav-text">将内联函数放入头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.3.</span> <span class="nav-text">内联函数与宏定义的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.16.</span> <span class="nav-text">必须在构造函数初始化列表里进行初始化的数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.17.</span> <span class="nav-text">定位内存泄露及检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.18.</span> <span class="nav-text">手写strcpy，memcpy，strcat，strcmp等函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.18.1.</span> <span class="nav-text">strcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.18.2.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.18.3.</span> <span class="nav-text">strlen</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.18.4.</span> <span class="nav-text">strcat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.18.5.</span> <span class="nav-text">strcmp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.19.</span> <span class="nav-text">memmove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.20.</span> <span class="nav-text">三个线程交替打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.21.</span> <span class="nav-text">类模板和模板类的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.22.</span> <span class="nav-text">海量数据问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.22.1.</span> <span class="nav-text">十亿整数（随机生成，可重复）中前K最大的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.22.2.</span> <span class="nav-text">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.23.</span> <span class="nav-text">布隆过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.23.1.</span> <span class="nav-text">几十亿个数经常要查找某一个数在不在里面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.23.2.</span> <span class="nav-text">布隆过滤器的原理。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.23.3.</span> <span class="nav-text">布隆过滤器可能出现误判，怎么保证无误差？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.1.</span> <span class="nav-text">Hash Map冲突如何解决？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.1.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.1.2.</span> <span class="nav-text">哈希冲突解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.2.</span> <span class="nav-text">Hash_map扩容发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.3.</span> <span class="nav-text">Unordered_map和map底层实现有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.3.1.</span> <span class="nav-text">map与unordered_map的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.3.2.</span> <span class="nav-text">为什么用红黑树？红黑树查询效率为什么快？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.4.</span> <span class="nav-text">vector相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.4.1.</span> <span class="nav-text">vector空间的动态增长</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.4.2.</span> <span class="nav-text">vector底层数据结构，vector底层是如何删除元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.5.</span> <span class="nav-text">STL里的内存池实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.5.1.</span> <span class="nav-text">内存的分配和回收</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.1.</span> <span class="nav-text">Linux的内存不足时会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.2.</span> <span class="nav-text">⭐进程和线程的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.</span> <span class="nav-text">多进程和多线程的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.0.1.</span> <span class="nav-text">优劣</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.4.</span> <span class="nav-text">临界区(进程同步)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">CAS原子操作(compare and swap)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.</span> <span class="nav-text">进程间如何通信？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.2.1.</span> <span class="nav-text">无名管道(pipe)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.2.2.</span> <span class="nav-text">有名管道(FIFO)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">信号(signal)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">消息队列(message queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">共享内存(shared memory)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.6.</span> <span class="nav-text">信号量(semophore )</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.6.1.</span> <span class="nav-text">信号量工作原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.7.</span> <span class="nav-text">套接字(socket)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.7.</span> <span class="nav-text">多线程间通信和同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.</span> <span class="nav-text">⭐协程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">libco库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.9.</span> <span class="nav-text">五种IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.</span> <span class="nav-text">⭐IO多路复用：select/poll/epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.3.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.3.1.</span> <span class="nav-text">epoll 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.3.2.</span> <span class="nav-text">工作模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.3.3.</span> <span class="nav-text">epoll的优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.3.4.</span> <span class="nav-text">边缘触发的IO应该怎么写？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.11.</span> <span class="nav-text">缺页中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.12.</span> <span class="nav-text">银行家算法：防止死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">TCP/IP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">⭐UDP和TCP的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">计算机网络是如何根据IP地址定位到一台主机的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">地址解析协议 ARP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">三次握手四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">get和post的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">⭐HTTPS的通信过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">get/post 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">http/https 1.0、1.1、2.0的特点和区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">从浏览器输入网址到出现页面经过了哪些阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.</span> <span class="nav-text">Cache的结构与工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.</span> <span class="nav-text">Mysql相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.1.</span> <span class="nav-text">从两个文件(各含50亿个url)中找出共同的url</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
