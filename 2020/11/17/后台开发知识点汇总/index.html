<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,C++,面经,">










<meta name="description" content="后台开发知识点汇总 C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;g">
<meta name="keywords" content="基础知识,C++,面经">
<meta property="og:type" content="article">
<meta property="og:title" content="后台开发知识点汇总">
<meta property="og:url" content="http://chenqi1997.github.io/2020/11/17/后台开发知识点汇总/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="后台开发知识点汇总 C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;g">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-da022f1196cfbe2f439a21cd64208e10_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-fc1fb96508a363b17d1bb7737dc51e54_720w.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20180520012305597">
<meta property="og:image" content="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/364303/201608/364303-20160815231938828-201985819.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg">
<meta property="og:image" content="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg">
<meta property="og:image" content="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215306696">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215332079">
<meta property="og:image" content="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140849">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200138896">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200139219">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200139703">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140021">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140375">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190915131156673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190915142010343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png">
<meta property="og:image" content="https://img-blog.csdn.net/20160202144116303">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkpVTcOZj4JJSyYlSMyiaC66pP2q1QiafglrtO0tmZHCkBB0RvCsfVOTIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkTX5icicl09hKPabMh2LHcfiapeTumDtOUB3fydDdsIGuNKI0uUWia4k5oA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk87ABj8vKWeQANrKVHpm7xNZRTbgFPOicpy74mD65ia3rGgMaIo6G1ntQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkZoTKofqkOibHicWGJPwsCjZGRpG077zmMMnRibkVqcVocZz1PxeIuLLMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkr9Pf9QeM2EhturaF3WFbL7AFYHJvKexk3As6s2vg1NiaUh5AplRmqyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkLicVe0iaPt3taOrowrLDwibhmGZsic0H8ic1Dv0Z3EMVtk80qzQOOib2CUew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img-blog.csdn.net/20170407165752062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzYxNjk0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcjvgSoF3zeGINoyibX5tpfgfQwBABm2KMEnohSmkRXjzicCuQtt4IWsc9fniahl1mW39gS674icZibqibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568283339430.91a72ae3.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180524102010286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180524111634561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568790013316.97bfddcb.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568790430010.9e25f59d.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568796886603.87101025.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568796161225.0a85de7d.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568796172902.50a3f779.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181130165347546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzA4MDI3,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568704529477.08a8d8a2.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568797056445.aa1412a3.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568797480363.f8ec5647.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568288257688.197541c0.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568635687315.e67e9b59.png">
<meta property="og:image" content="https://img-blog.csdn.net/20150730120353079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1627759/201906/1627759-20190615112708629-638195014.jpg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5YING7tophKDYrYreRzSvGN0BlJ6LibtW2mK4QTTckvpm3408gax7XUg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5hTnk3S5XJBVElZdWeB6U8lrMlyY9iaPZFj7WKE1OeSw3E3TNUj9Nz3A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img-blog.csdn.net/20171123102431734">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq1.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq3.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq4.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq5.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq6.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq7.png">
<meta property="og:updated_time" content="2021-01-05T14:04:32.014Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="后台开发知识点汇总">
<meta name="twitter:description" content="后台开发知识点汇总 C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;g">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/11/17/后台开发知识点汇总/">





  <title>后台开发知识点汇总 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/11/17/后台开发知识点汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">后台开发知识点汇总</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-17T17:46:00+08:00">
                2020-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面经/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#后台开发知识点汇总">后台开发知识点汇总</a><ul>
<li><a href="#c基础">C++基础</a><ul>
<li><a href="#c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</a><ul>
<li><a href="#互斥锁mutex">互斥锁(Mutex)</a></li>
<li><a href="#条件变量condition_variable">条件变量(condition_variable)</a></li>
<li><a href="#自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</a></li>
<li><a href="#读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</a></li>
<li><a href="#递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</a></li>
<li><a href="#定时锁time_mutex">定时锁(time_mutex)</a></li>
<li><a href="#两种基本的锁类型">两种基本的锁类型</a><ul>
<li><a href="#条件变量中只能使用unique_lock-stdmutex">条件变量中只能使用unique_lock&lt; std::mutex &gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c中原子类型">C++中原子类型</a></li>
<li><a href="#c中thread操作">C++中thread操作</a><ul>
<li><a href="#stdthread构造">std::thread构造</a></li>
<li><a href="#join">join()</a></li>
<li><a href="#detach">detach()</a></li>
<li><a href="#wait成员函数">wait()成员函数</a></li>
<li><a href="#wait_for成员函数">wait_for()成员函数</a></li>
<li><a href="#notify_allnotify_one">notify_all/notify_one</a></li>
<li><a href="#虚假唤醒">虚假唤醒</a></li>
</ul>
</li>
<li><a href="#c多态">C++多态</a><ul>
<li><a href="#多态有哪几种">多态有哪几种？</a></li>
<li><a href="#虚函数的实现">虚函数的实现</a></li>
<li><a href="#动态绑定">动态绑定</a></li>
<li><a href="#为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</a></li>
<li><a href="#为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</a></li>
<li><a href="#为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</a></li>
<li><a href="#静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</a></li>
<li><a href="#友元可以继承吗">友元可以继承吗？</a></li>
<li><a href="#虚函数virtual可以是内联函数inline吗">虚函数(virtual)可以是内联函数(inline)吗？</a></li>
<li><a href="#多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</a></li>
<li><a href="#类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</a></li>
<li><a href="#钻石继承问题">钻石继承问题</a></li>
</ul>
</li>
<li><a href="#c的四种cast">C++的四种cast</a><ul>
<li><a href="#static_cast">static_cast</a></li>
<li><a href="#const_cast">const_cast</a></li>
<li><a href="#reinterpret_cast">reinterpret_cast</a></li>
<li><a href="#dynamic_cast">dynamic_cast</a></li>
<li><a href="#哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</a></li>
</ul>
</li>
<li><a href="#c智能指针">C++智能指针</a><ul>
<li><a href="#auto_ptr弃用">auto_ptr(弃用)</a></li>
<li><a href="#unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
<li><a href="#weak_ptr">weak_ptr</a></li>
<li><a href="#智能指针是线程安全的吗">智能指针是线程安全的吗？</a></li>
</ul>
</li>
<li><a href="#c对象的内存模型">C++对象的内存模型</a><ul>
<li><a href="#普通对象模型">普通对象模型</a></li>
<li><a href="#派生类的对象模型">派生类的对象模型</a></li>
<li><a href="#vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</a></li>
</ul>
</li>
<li><a href="#volitale关键字">Volitale关键字</a><ul>
<li><a href="#volatile指针">volatile指针</a></li>
<li><a href="#可见性">可见性</a><ul>
<li><a href="#什么是可见性">什么是可见性？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c中指针和引用的区别">C++中指针和引用的区别</a></li>
<li><a href="#c中new与malloc的区别">C++中new与malloc的区别</a></li>
<li><a href="#c-内存对齐">C++ 内存对齐</a></li>
<li><a href="#c存储类型">C++存储类型</a><ul>
<li><a href="#auto-自动变量">auto 自动变量</a></li>
<li><a href="#register-寄存器变量">register 寄存器变量</a></li>
<li><a href="#static-关键字">static 关键字</a></li>
<li><a href="#extern关键字">extern关键字</a></li>
<li><a href="#mutable-存储类">mutable 存储类</a></li>
<li><a href="#thread_local-存储类">thread_local 存储类</a></li>
</ul>
</li>
<li><a href="#stdmove语义">std::move()语义</a></li>
<li><a href="#右值引用">右值引用</a><ul>
<li><a href="#左值引用">左值引用</a></li>
<li><a href="#右值引用-1">右值引用</a></li>
<li><a href="#右值引用有办法指向左值吗">右值引用有办法指向左值吗</a></li>
<li><a href="#完美转发-stdforward">完美转发 std::forward()</a></li>
<li><a href="#auto也是这个意思">auto&amp;&amp;也是这个意思</a></li>
</ul>
</li>
<li><a href="#c内联函数">C++内联函数</a><ul>
<li><a href="#内联函数有什么优点">内联函数有什么优点？</a></li>
<li><a href="#缺点">缺点</a></li>
<li><a href="#将内联函数放入头文件">将内联函数放入头文件</a></li>
<li><a href="#内联函数与宏定义的区别">内联函数与宏定义的区别？</a></li>
<li><a href="#explicit关键字">explicit关键字</a></li>
<li><a href="#union-联合体">union 联合体</a></li>
</ul>
</li>
<li><a href="#深拷贝与浅拷贝">深拷贝与浅拷贝</a></li>
<li><a href="#必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</a></li>
<li><a href="#定位内存泄露及检测">定位内存泄露及检测</a></li>
<li><a href="#手写strcpymemcpystrcatstrcmp等函数">手写strcpy，memcpy，strcat，strcmp等函数</a><ul>
<li><a href="#strcpy">strcpy</a></li>
<li><a href="#memcpy">memcpy</a></li>
<li><a href="#strlen">strlen</a></li>
<li><a href="#strcat">strcat</a></li>
<li><a href="#strcmp">strcmp</a></li>
</ul>
</li>
<li><a href="#memmove">memmove</a></li>
<li><a href="#手写单例模式">手写单例模式</a></li>
<li><a href="#三个线程交替打印">三个线程交替打印</a></li>
<li><a href="#类模板和模板类的区别">类模板和模板类的区别？</a></li>
<li><a href="#海量数据问题">海量数据问题</a><ul>
<li><a href="#十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</a></li>
<li><a href="#十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</a></li>
</ul>
</li>
<li><a href="#布隆过滤器">布隆过滤器</a><ul>
<li><a href="#什么情况下需要布隆过滤器">什么情况下需要布隆过滤器？</a></li>
<li><a href="#布隆过滤器的原理">布隆过滤器的原理。</a></li>
<li><a href="#位图bitmap">位图(bitmap)</a></li>
<li><a href="#布隆过滤器大小计算">布隆过滤器大小计算</a></li>
<li><a href="#布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</a></li>
</ul>
</li>
<li><a href="#stl">STL</a><ul>
<li><a href="#hash-map冲突如何解决">Hash Map冲突如何解决？</a><ul>
<li><a href="#哈希函数">哈希函数</a></li>
<li><a href="#哈希冲突解决方案">哈希冲突解决方案</a></li>
</ul>
</li>
<li><a href="#hash_map扩容发生什么">Hash_map扩容发生什么</a></li>
<li><a href="#unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</a><ul>
<li><a href="#map与unordered_map的区别">map与unordered_map的区别</a></li>
<li><a href="#为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？红黑树查询效率为什么快？</a></li>
</ul>
</li>
<li><a href="#为何map和set的插入删除效率比用其他序列容器高">为何map和set的插入删除效率比用其他序列容器高？</a><ul>
<li><a href="#为什么每次insert之后以前保存的iterator不会失效">为什么每次insert之后，以前保存的iterator不会失效</a></li>
</ul>
</li>
<li><a href="#vector相关">vector相关</a><ul>
<li><a href="#vector空间的动态增长">vector空间的动态增长</a></li>
<li><a href="#vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</a></li>
</ul>
</li>
<li><a href="#stl里的内存池实现">STL里的内存池实现</a><ul>
<li><a href="#内存的分配和回收">内存的分配和回收</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</a></li>
<li><a href="#操作系统的四大特性">操作系统的四大特性</a></li>
<li><a href="#死锁活锁饥饿">死锁/活锁/饥饿</a><ul>
<li><a href="#死锁">死锁</a><ul>
<li><a href="#死锁预防方式">死锁预防方式：</a></li>
<li><a href="#银行家算法">银行家算法</a></li>
</ul>
</li>
<li><a href="#活锁">活锁</a><ul>
<li><a href="#解决方法">解决方法</a></li>
</ul>
</li>
<li><a href="#饥饿">饥饿</a><ul>
<li><a href="#解决方法-1">解决方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#进程和线程的区别和联系">⭐进程和线程的区别和联系</a></li>
<li><a href="#多进程和多线程的区别">多进程和多线程的区别？</a><ul>
<li><a href="#优劣">优劣</a></li>
</ul>
</li>
<li><a href="#临界区进程同步">临界区(进程同步)</a></li>
<li><a href="#原子操作">原子操作</a><ul>
<li><a href="#cas原子操作compare-and-swap">CAS原子操作(compare and swap)</a></li>
</ul>
</li>
<li><a href="#进程间如何通信">进程间如何通信？</a><ul>
<li><a href="#应用场景">应用场景</a></li>
<li><a href="#管道">管道</a><ul>
<li><a href="#无名管道pipe">无名管道(pipe)</a></li>
<li><a href="#有名管道fifo">有名管道(FIFO)</a></li>
</ul>
</li>
<li><a href="#信号signal">信号(signal)</a></li>
<li><a href="#消息队列message-queue">消息队列(message queue)</a></li>
<li><a href="#共享内存shared-memory">共享内存(shared memory)</a></li>
<li><a href="#信号量semophore">信号量(semophore )</a><ul>
<li><a href="#信号量工作原理">信号量工作原理</a></li>
</ul>
</li>
<li><a href="#套接字socket">套接字(socket)</a></li>
</ul>
</li>
<li><a href="#进程线程的上下文">进程/线程的上下文</a><ul>
<li><a href="#进程的上下文可以分为哪几个部分">进程的上下文可以分为哪几个部分？</a></li>
<li><a href="#为什么切换线程比切换进程开销小">为什么切换线程比切换进程开销小</a></li>
</ul>
</li>
<li><a href="#多线程间通信和同步">多线程间通信和同步</a></li>
<li><a href="#协程">⭐协程</a><ul>
<li><a href="#libco库">libco库</a></li>
</ul>
</li>
<li><a href="#五种io模型">五种IO模型</a><ul>
<li><a href="#阻塞io">阻塞IO</a></li>
<li><a href="#非阻塞io">非阻塞IO</a></li>
<li><a href="#io多路复用">IO多路复用</a></li>
<li><a href="#信号驱动的io模型">信号驱动的IO模型</a></li>
<li><a href="#异步io模型">异步IO模型</a></li>
</ul>
</li>
<li><a href="#两种io事件处理模式">两种IO事件处理模式</a><ul>
<li><a href="#reactor模式同步的">Reactor模式(同步的)</a></li>
<li><a href="#proactor模式-异步">Proactor模式 (异步)</a></li>
</ul>
</li>
<li><a href="#io多路复用selectpollepoll同步阻塞">⭐IO多路复用：select/poll/epoll(同步/阻塞)</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a><ul>
<li><a href="#epoll-函数">epoll 函数</a></li>
<li><a href="#工作模式">工作模式</a></li>
<li><a href="#epoll的优点">epoll的优点：</a></li>
<li><a href="#mmap实现共享内存">mmap实现共享内存：</a></li>
<li><a href="#边缘触发的io应该怎么写">边缘触发的IO应该怎么写？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#内存管理">内存管理</a><ul>
<li><a href="#虚拟内存">虚拟内存</a></li>
<li><a href="#内存分段">内存分段</a></li>
<li><a href="#内存分页">内存分页</a><ul>
<li><a href="#多级页表">多级页表</a></li>
<li><a href="#64位系统用到的是四级目录">64位系统用到的是四级目录</a></li>
<li><a href="#tlbtranslation-lookaside-buffer-页表缓存">TLB(<em>Translation Lookaside Buffer</em>) 页表缓存</a></li>
<li><a href="#段页式内存管理">段页式内存管理</a></li>
</ul>
</li>
<li><a href="#linux内存管理">Linux内存管理</a><ul>
<li><a href="#用户空间的内存分布">用户空间的内存分布</a></li>
</ul>
</li>
<li><a href="#mmap内存映射原理">mmap内存映射原理：</a></li>
</ul>
</li>
<li><a href="#缺页中断page_fault">缺页中断(page_fault)</a><ul>
<li><a href="#页面置换算法">页面置换算法</a></li>
</ul>
</li>
<li><a href="#cpu调度算法进程调度算法">CPU调度算法/进程调度算法</a><ul>
<li><a href="#先到先服务算法fcfs-first-come-first-served">先到先服务算法(FCFS, First-Come First-Served)</a></li>
<li><a href="#最短作业优先sjf-shortest-job-first">最短作业优先(SJF, Shortest Job First)</a></li>
<li><a href="#优先级算法">优先级算法</a></li>
<li><a href="#高响应比优先调度算法hrrn">高响应比优先调度算法(HRRN)</a></li>
<li><a href="#最短剩余时间优先-srtf-shortest-remaining-time-first">最短剩余时间优先 (SRTF, Shortest Remaining Time First)</a></li>
<li><a href="#rrround-robin调度器">RR(Round Robin)调度器</a></li>
<li><a href="#多级反馈队列mfq">多级反馈队列(MFQ)：</a></li>
</ul>
</li>
<li><a href="#用户态与内核态">用户态与内核态</a><ul>
<li><a href="#三种情况会导致用户态到内核态的切换">三种情况会导致用户态到内核态的切换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#计算机网络">计算机网络</a><ul>
<li><a href="#tcpudp运输层">TCP/UDP/运输层</a><ul>
<li><a href="#udp和tcp的差别">⭐UDP和TCP的差别</a></li>
<li><a href="#tcpudp数据发送和接收过程">TCP/UDP数据发送和接收过程</a><ul>
<li><a href="#发送端"><strong>发送端</strong></a></li>
<li><a href="#接收端"><strong>接收端</strong></a></li>
<li><a href="#复用与分用">复用与分用</a></li>
</ul>
</li>
<li><a href="#tcp协议的可靠性体现在哪里">TCP协议的可靠性体现在哪里</a><ul>
<li><a href="#校验和">校验和</a></li>
<li><a href="#序列号ack和确认应答">序列号(ACK)和确认应答</a></li>
</ul>
</li>
<li><a href="#超时重传">超时重传</a></li>
<li><a href="#流量控制">流量控制</a></li>
<li><a href="#滑动窗口以字节为单位">滑动窗口(以字节为单位)</a></li>
<li><a href="#拥塞控制">拥塞控制</a><ul>
<li><a href="#慢开始"><strong>慢开始</strong></a></li>
<li><a href="#拥塞避免"><strong>拥塞避免</strong></a></li>
<li><a href="#快重传"><strong>快重传</strong></a></li>
<li><a href="#快恢复"><strong>快恢复</strong></a></li>
</ul>
</li>
<li><a href="#tcp-报文段首部格式20byte">TCP 报文段首部格式(20Byte)</a></li>
<li><a href="#停止等待-arq-协议">停止等待 ARQ 协议</a></li>
<li><a href="#三次握手四次挥手">三次握手四次挥手</a><ul>
<li><a href="#三次握手">三次握手</a></li>
<li><a href="#四次挥手">四次挥手</a></li>
</ul>
</li>
<li><a href="#tcp三次握手如果第三次客户端发出的信息服务器没收到怎么办">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</a></li>
<li><a href="#什么是socket">什么是Socket</a><ul>
<li><a href="#socket函数">socket函数</a></li>
<li><a href="#bind函数">bind函数</a></li>
<li><a href="#listenconnect函数">listen/connect函数</a></li>
<li><a href="#accept函数">accept函数</a></li>
</ul>
</li>
<li><a href="#readwrite函数">read/write函数</a></li>
<li><a href="#socket通信中tcp-udp数据包大小的确定">SOCKET通信中TCP、UDP数据包大小的确定</a><ul>
<li><a href="#mtu最大传输单元">MTU最大传输单元</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ip网络层">IP/网络层</a><ul>
<li><a href="#地址解析协议-arp">地址解析协议 ARP</a><ul>
<li><a href="#计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</a></li>
</ul>
</li>
<li><a href="#icmpigmp">ICMP/IGMP</a><ul>
<li><a href="#网际控制报文协议-icmp">网际控制报文协议 <strong>ICMP</strong></a></li>
</ul>
</li>
<li><a href="#icmp-报文种类">ICMP 报文种类</a><ul>
<li><a href="#网际组管理协议-igmp">网际组管理协议 <strong>IGMP</strong></a></li>
</ul>
</li>
<li><a href="#ip-数据报的格式">IP 数据报的格式</a><ul>
<li><a href="#首部固定字段">首部固定字段</a></li>
<li><a href="#首部可变部分">首部可变部分</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http">HTTP</a><ul>
<li><a href="#http状态码">HTTP状态码</a></li>
<li><a href="#https的通信过程">⭐HTTPS的通信过程</a><ul>
<li><a href="#非对称加密算法对称加密算法">非对称加密算法+对称加密算法</a></li>
<li><a href="#数字证书-防止中间人攻击">数字证书—防止中间人攻击</a></li>
<li><a href="#数字摘要算法">数字摘要算法</a></li>
<li><a href="#证书内置">证书内置</a></li>
</ul>
</li>
<li><a href="#getpost-区别">get/post 区别</a></li>
<li><a href="#httphttps-09-10-11-20-30的特点和区别">http/https 0.9、1.0、1.1、2.0、3.0的特点和区别</a><ul>
<li><a href="#http09">Http0.9</a></li>
<li><a href="#http10">Http1.0</a></li>
<li><a href="#http11">Http1.1</a></li>
<li><a href="#http20">Http2.0</a></li>
<li><a href="#http30">Http3.0</a></li>
</ul>
</li>
<li><a href="#http的无状态性">HTTP的无状态性</a><ul>
<li><a href="#cookie">Cookie</a></li>
<li><a href="#session">Session</a></li>
<li><a href="#session和cookie的关系">Session和Cookie的关系</a></li>
</ul>
</li>
<li><a href="#http请求种类">HTTP请求种类</a></li>
<li><a href="#从浏览器输入url到出现页面经过了哪些阶段">从浏览器输入URL到出现页面经过了哪些阶段</a></li>
</ul>
</li>
<li><a href="#cache的结构与工作原理">Cache的结构与工作原理</a></li>
</ul>
</li>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#mysql相关">Mysql相关</a><ul>
<li><a href="#事务的特性acid">事务的特性(ACID)</a></li>
<li><a href="#如果不考虑隔离性会发生什么事呢">如果不考虑隔离性，会发生什么事呢？</a></li>
<li><a href="#四种隔离级别">四种隔离级别</a><ul>
<li><a href="#什么是快照读-当前读">什么是快照读、当前读</a></li>
<li><a href="#mysql如何解决幻读问题">MySql如何解决幻读问题</a></li>
</ul>
</li>
<li><a href="#数据库三范式">数据库三范式</a></li>
<li><a href="#索引是个什么样的数据结构呢">索引是个什么样的数据结构呢?</a><ul>
<li><a href="#b树">B+树</a></li>
<li><a href="#myisam与innodb-的区别">MyISAM与InnoDB 的区别</a></li>
</ul>
</li>
<li><a href="#什么是聚簇索引">什么是聚簇索引?</a></li>
</ul>
</li>
<li><a href="#最左匹配">最左匹配</a></li>
<li><a href="#redis">Redis</a><ul>
<li><a href="#redis相比memcached有哪些优势">Redis相比memcached有哪些优势</a></li>
<li><a href="#redis常用的五种数据类型">Redis常用的五种数据类型</a><ul>
<li><a href="#string字符串">string字符串</a></li>
<li><a href="#list列表">list列表</a></li>
<li><a href="#set集合">set集合</a></li>
<li><a href="#sorted-setzset有序集合">sorted set(zset)有序集合</a></li>
<li><a href="#hash哈希表">hash哈希表</a></li>
</ul>
</li>
<li><a href="#redis持久化">Redis持久化</a><ul>
<li><a href="#rdbredis-database-半持久化模式">RDB(Redis DataBase) 半持久化模式</a></li>
<li><a href="#aofappend-only-file-全持久化模式">AOF(Append-only file) 全持久化模式</a></li>
<li><a href="#存储结构">存储结构</a></li>
</ul>
</li>
<li><a href="#redis架构模式">Redis架构模式</a><ul>
<li><a href="#1-单机版">1. 单机版</a></li>
<li><a href="#2-主从复制">2. 主从复制</a></li>
<li><a href="#3-哨兵">3. 哨兵</a></li>
<li><a href="#4-集群proxy型">4. 集群(proxy型)</a></li>
<li><a href="#5-集群直连型">5. 集群(直连型)</a></li>
</ul>
</li>
<li><a href="#redis是单线程的但redis为什么这么快">Redis是单线程的，但Redis为什么这么快？</a></li>
<li><a href="#为什么redis用跳表不用红黑树">为什么redis用跳表不用红黑树</a></li>
<li><a href="#为什么redis不用b树">为什么redis不用b+树</a></li>
<li><a href="#redis的用途是什么">Redis的用途是什么？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#其他">其他</a><ul>
<li><a href="#从两个文件各含50亿个url中找出共同的url">从两个文件(各含50亿个url)中找出共同的url</a></li>
<li><a href="#git中merge和rebase的区别">git中Merge和rebase的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h1><span id="后台开发知识点汇总">后台开发知识点汇总</span></h1><h2><span id="c基础">C++基础</span></h2><h3><span id="c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</span></h3><p>C++线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong> 这几种。需要在进入临界区之前对互斥量 <code>lock</code> ，退出临界区时对互斥量 <code>unlock</code> ；当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。</p>
<h4><span id="互斥锁mutex">互斥锁(Mutex)</span></h4><p>互斥锁用于<strong>控制多个线程对他们之间共享资源互斥访问的一个信号量</strong>。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。</p>
<p>在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以<strong>阻塞方式</strong>进行等待。</p>
<p><strong>互斥锁是是一种sleep-waiting的锁</strong>。假设线程 <code>T1</code> 获取互斥锁并且正在 <code>core1</code> 上运行时，此时线程 <code>T2</code> 也想要获取互斥锁 (pthread_mutex_lock)，但是由于 <code>T1</code> 正在使用互斥锁使得 <code>T2</code> 被阻塞。当 <code>T2</code> 处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器 <code>core2</code> 会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p>
<p><strong>用法：</strong>在C++中，通过构造 <code>std::mutex</code> 的实例创建互斥元，调用成员函数 <code>lock()</code> 来锁定它，调用 <code>unlock()</code> 来解锁，不过一般不推荐这种做法，标准C++库提供了std::lock_guard类模板，实现了互斥元的 <code>RAII</code> 惯用语法。<code>std::mutex</code> 和 <code>std::lock_guard</code> 。都声明在 <code>&lt;mutex&gt;</code> 头文件中。</p>
<p><code>lock_guard</code> 对象通常用于管理某个锁(Lock)对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用互斥元保护列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list;</span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(some_mutex);</span><br><span class="line">    some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="条件变量condition_variable">条件变量(condition_variable)</span></h4><p>条件锁就是所谓的条件变量，某一个线程因为某个条件<strong>未满足</strong>时可以使用 <code>条件锁</code> 使该程序处于 <code>阻塞状态</code> 。</p>
<p>一旦条件满足，可以以 <code>信号量</code> 的方式唤醒一个因为该条件而被阻塞的线程。</p>
<p>条件变量的作用不是用来管理互斥量的，它的作用是用来<strong>同步线程</strong>，它的用法相当于编程中常见的 <code>flag</code> 标志（A、B两个人约定 <code>flag=true</code> 为行动号角，默认 <code>flag</code> 为 <code>false</code> ，A不断的检查 <code>flag</code> 的值,只要 <code>B</code> 将 <code>flag</code> 修改为 <code>true</code> ，<code>A</code> 就开始行动）。类比到 <code>condition_variable</code>，A、B两个人约定 <code>notify_one</code> 为行动号角，<code>A</code>就等着（调用 <code>wait()</code> ，阻塞）,只要 <code>B</code> 一调用 <code>notify_one</code> ，A就开始行动（不再阻塞）。</p>
<p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为 <code>任务队列为空</code> 这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用std::condition_variable等待数据</span></span><br><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);   <span class="comment">//这里使用unique_lock是为了后面方便解锁</span></span><br><span class="line">        data_cond.wait(lk,&#123;[]<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面，<code>wait()</code> 的实现接下来检查条件，并在满足时返回。如果条件不满足，wait()解锁互斥元，并将该线程置于阻塞或等待状态。当来自数据准备线程中对 <code>notify_one()</code> 的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从wait()返回值，互斥元仍被锁定。如果条件不满足，该线程解锁互斥元，并恢复等待。</p>
<hr>
<h4><span id="自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</span></h4><p><em>自旋锁需要与互斥锁一起来比较理解。</em></p>
<p><strong>自旋锁是一种busy-waiting的锁</strong>。也就是说，如果 <code>T1</code> 正在使用自旋锁，而 <code>T2</code> 也去申请这个自旋锁，此时 <code>T2</code> 肯定得不到这个自旋锁。与互斥锁相反的是，此时运行 <code>T2</code> 的处理器 <code>core2</code> 会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p>
<p>从 <code>自旋锁</code> 的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一直占用 <code>CPU</code> 请求这个自旋锁使得 <code>CPU</code> 不能去做其他的事情，直到获取这个锁为止，这就是 <code>自旋</code> 的含义。</p>
<p>当发生阻塞时，互斥锁可以让 <code>CPU</code> 去处理其他的任务；而自旋锁让 <code>CPU</code> 一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道 <code>自旋锁</code> 是比较耗费 <code>CPU</code> 的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(<span class="keyword">spinlock_t</span> *x);<span class="comment">//初始化</span></span><br><span class="line">spin_lock(x);   			  <span class="comment">//只有在获得锁的情况下才返回，否则一直“自旋”</span></span><br><span class="line">spin_trylock(x);  			  <span class="comment">//如立即获得锁则返回真，否则立即返回假</span></span><br><span class="line">spin_unlock(x);				  <span class="comment">//释放锁</span></span><br><span class="line">spin_is_locked(x)			  <span class="comment">//该宏用于判断自旋锁x是否已经被某执行单元保持（即被锁），如果是，   返回真，否则返回假。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</span></h4><p><code>std::shared_mutex</code>有两种访问级别：</p>
<ul>
<li><strong>共享：</strong>多个线程可以共享这个锁的拥有权。一般用于数据的<strong>读操作</strong>，防止数据被写修改。</li>
<li><p><strong>互斥：</strong>仅仅一个线程可以拥有这个锁。一般用于<strong>写操作</strong>。</p>
</li>
<li><p>如果一个线程已经获取了 <code>互斥锁</code> ，则其他线程都无法获取该锁。</p>
</li>
<li>如果一个线程已经获取了 <code>共享锁</code> ，则其他任何线程都无法获取 <code>互斥锁</code> ，但是可以获取 <code>共享锁</code> 。</li>
</ul>
<hr>
<h4><span id="递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</span></h4><p>我们都知道，一般的互斥量对于同一个线程只能同时加锁一次（调用 <code>lock</code> ），如果连续调用两次以上便会出现死锁。但设想这样一个场景，如果在一个函数内给互斥量上了锁还没有解开，然后又调用了另一个函数，这个被调用的函数也去给互斥量上锁，这种情境下就会出现死锁。</p>
<p>对于互斥锁，分为递归锁和非递归锁。在不同的线程中调用已锁定的互斥锁，必然会导致死锁。但是在<strong>同一个线程中，如果想要多次获得一个锁，只能使用递归锁</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MutexLock mutex;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    mutex.unlock();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    foo();  </span><br><span class="line">    mutex.unlock();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，引入了递归锁的概念。</p>
<p><strong>递归锁</strong>，顾名思义，<strong>如果因为多次函数调用而导致出现多次上锁的情况，只有第一次会去真正加锁，后面的加锁操作会被自动忽略。</strong></p>
<p><strong>recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁）</strong>，来获得对互斥量对象的<strong>多层所有权</strong>，<code>recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和 <code>unlock()</code> 次数相同，除此之外，<code>recursive_mutex</code> 的特性和<code>mutex</code> 大致相同。</p>
<hr>
<h4><span id="定时锁time_mutex">定时锁(time_mutex)</span></h4><p><code>std::time_mutex</code> 比 <code>std::mutex</code> 多了两个成员函数，<code>try_lock_for()</code> ，<code>try_lock_until()</code> 。</p>
<p><strong>try_lock_for</strong> 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 <code>std::mutex</code> 的 <code>try_lock()</code> 不同，<code>try_lock</code> 如果被调用时没有获得锁则直接返回 <code>false</code>），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code>。</p>
<p><strong>try_lock_until</strong> 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code> 。</p>
<hr>
<h4><span id="两种基本的锁类型">两种基本的锁类型</span></h4><p>C++11 标准为我们提供了两种基本的锁类型，分别如下：</p>
<ul>
<li><strong>std::lock_guard</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁。<ul>
<li><strong>lock_guard</strong> 对象通常用于管理某个锁( <code>Lock</code> )对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源 )。</li>
<li>在 <code>lock_guard</code> 对象构造时，传入的 <code>Mutex</code> 对象(即它所管理的 <code>Mutex</code> 对象)会被<strong>当前线程</strong>锁住。在<code>lock_guard</code> 对象被析构时，它所管理的 <code>Mutex</code> 对象会自动解锁，由于不需要程序员手动调用 <code>lock</code> 和 <code>unlock</code> 对 <code>Mutex</code> 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 <code>Mutex</code> 对象可以正确进行解锁操作，极大地简化了程序员编写与 <code>Mutex</code> 相关的异常处理代码。</li>
<li>值得注意的是，<code>lock_guard</code> 对象并不负责管理 <code>Mutex</code> 对象的生命周期，<code>lock_guard</code> 对象只是简化了 <code>Mutex</code> 对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁。</li>
</ul>
</li>
<li><strong>std::unique_lock</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。<ul>
<li><strong>unique_lock</strong> 提供了更好的上锁和解锁控制。顾名思义，<code>unique_lock</code> 对象以独占所有权的方式(unique owership)管理 <code>mutex</code> 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权。</li>
<li>在构造(或移动(move)赋值)时，<code>unique_lock</code> 对象需要传递一个 <code>Mutex</code> 对象作为它的参数，新创建的 <code>unique_lock</code> 对象负责传入的 <code>Mutex</code> 对象的上锁和解锁操作。</li>
</ul>
</li>
</ul>
<h5><span id="条件变量中只能使用unique_locklt-stdmutex-gt">条件变量中只能使用unique_lock&lt; std::mutex &gt;</span></h5><p><code>unique_lock</code> 和 <code>lock_guard</code> 都是管理锁的辅助类工具，都是 <code>RAII(资源定义即初始化)</code> 风格；它们是在定义时获得锁，在析构时释放锁。它们的主要区别在于 <code>unique_lock</code> 锁机制更加灵活，可以再需要的时候进行 <code>lock</code> 或者 <code>unlock</code> 调用，不非得是析构或者构造时。它们的区别可以通过成员函数就可以一目了然。</p>
<hr>
<h3><span id="c中原子类型">C++中原子类型</span></h3><p><strong>std::atomic&lt;&gt;</strong>是一个模板类，使用该模板类实例化的对象，提供了<strong>一些保证原子性的成员函数</strong>来实现共享数据的常用操作。</p>
<p>可以这样理解： 在以前，定义了一个共享的变量 <code>int i=0</code>，多个线程会用到这个变量，那么每次操作这个变量时，都需要 <code>lock</code> 加锁，操作完毕 <code>unlock</code> 解锁，以保证线程之间不会冲突；但是这样每次加锁解锁、加锁解锁就显得很麻烦，那怎么办呢？ 现在，实例化了一个类对象 <code>std::atomic&lt;int&gt; I=0</code> 来代替以前的那个变量（这里的对象 <code>I</code> 你就把它看作一个变量，看作对象反而难以理解了），每次操作这个对象时，就不用 <code>lock</code> 与 <code>unlock</code> ，这个对象自身就具有原子性（相当于加锁解锁操作不用你写代码实现，能自动加锁解锁了），以保证线程之间不会冲突。</p>
<hr>
<h3><span id="c中thread操作">C++中thread操作</span></h3><h4><span id="stdthread构造">std::thread构造</span></h4><table>
<thead>
<tr>
<th>default (1)</th>
<th>thread() noexcept;</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialization (2)</td>
<td>template <class fn,="" class...="" args=""> explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;… args);</class></td>
</tr>
<tr>
<td>copy [deleted] (3)</td>
<td>thread (const thread&amp;) = delete;</td>
</tr>
<tr>
<td>move (4)</td>
<td>thread (thread&amp;&amp; x) noexcept;</td>
</tr>
</tbody>
</table>
<ol>
<li>默认构造函数，创建一个空的 thread 执行对象。</li>
<li>初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</li>
<li>拷贝构造函数(被禁用)，意味着 <strong>thread 不可被拷贝构造</strong>。只能用<strong>右值引用配合move赋值操作</strong>。</li>
<li>move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。</li>
</ol>
<p>注意：可被 <code>joinable</code> 的 <code>thread</code> 对象必须在他们销毁之前被主线程 <code>join</code> 或者将其设置为 <code>detached</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(<span class="built_in">std</span>::move(t3))</span></span>; <span class="comment">// t4 is now running f2(). t3 is no longer a thread</span></span><br></pre></td></tr></table></figure>
<h4><span id="join">join()</span></h4><ul>
<li><p>阻塞主线程，直至 <code>this</code> 所标识的线程完成其执行。<code>this</code> 所标识的线程的完成同步于从 <strong>join()</strong> 的成功返回。</p>
</li>
<li><p>该方法简单暴力，主线程等待子进程期间什么都不能做。<code>thread::join()</code> 会清理子线程相关的内存空间，此后<code>thread object</code> 将不再和这个子线程相关了，即 <code>thread object</code> 不再 <code>joinable</code> 了，所以 <code>join</code> 对于一个子线程来说只可以被调用一次，为了实现更精细的线程等待机制，可以使用条件变量等机制。</p>
</li>
</ul>
<h4><span id="detach">detach()</span></h4><ul>
<li>从调用线程中分离出对象所代表的线程，从而使它们彼此独立执行。两个线程继续运行，而不会阻塞或以任何方式进行同步。</li>
<li>请注意，当任何一个执行结束时，其资源将被释放。</li>
<li>调用此函数后，线程对象变得不可连接，并且可以安全地销毁。</li>
<li>使用 <code>detach</code> ，那么新线程就会与原线程分离，如果原线程先执行完毕，销毁线程对象及局部变量，并且<strong>新线程有共享变量或引用</strong>之类，这样新线程可能使用的变量，就变成未定义，产生异常或不可预测的错误。</li>
</ul>
<h4><span id="wait成员函数">wait()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock )</span></span>;</span><br><span class="line"><span class="comment">//Predicate 谓词函数，可以普通函数或者lambda表达式</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );</span><br></pre></td></tr></table></figure>
<p><code>wait</code>  导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，可选地循环<strong>直至满足某谓词</strong>。条件变量的wait所必须是<strong>unique_lock而</strong>不是lock_guard，因为wait会在内部调用<strong>unique_lock.unlock</strong>先解锁，当被唤醒后，条件满足时，会<strong>unique_lock.lock</strong></p>
<h4><span id="wait_for成员函数">wait_for()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function">cv_status <span class="title">wait_for</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span>, <span class="title">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">wait_for</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span><br><span class="line">               <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span><br><span class="line">               Predicate pred);</span><br></pre></td></tr></table></figure>
<p><code>wait_for</code> 导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，或者<strong>超时返回</strong>。</p>
<p>以上两个类型的<strong>wait函数都在会阻塞时，自动释放锁权限，即调用unique_lock的成员函数unlock（），以便其他线程能有机会获得锁</strong>。这就是条件变量只能和 <code>unique_lock</code> 一起使用的原因，否则当前线程一直占有锁，线程被阻塞。</p>
<h4><span id="notify_allnotify_one">notify_all/notify_one</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则解阻塞（唤醒)全部等待线程。</span></span><br></pre></td></tr></table></figure>
<h4><span id="虚假唤醒">虚假唤醒</span></h4><p>在正常情况下，<code>wait</code> 类型函数返回时要不是因为被唤醒，要不是因为超时才返回，但是在实际中发现，因此操作系统的原因，<code>wait</code> 类型在不满足条件时，它也会返回，这就导致了虚假唤醒。因此，我们一般都是使用带有谓词参数的 <code>wait</code> 函数，因为这种<code>(xxx, Predicate pred )</code>类型的函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!(xxx条件) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//虚假唤醒发生，由于while循环，再次检查条件是否满足，</span></span><br><span class="line">    <span class="comment">//否则继续等待，解决虚假唤醒</span></span><br><span class="line">    wait();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c多态">C++多态</span></h3><p><strong>封装，继承，多态是面向对象设计的三个特征</strong>，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。</p>
<h4><span id="多态有哪几种">多态有哪几种？</span></h4><p>多态是面向对象的重要特性之一，它是一种行为的封装，是同一种事物所表现出的多种形态，简单地说是”一个接口多种实现“。多态的实现主要分为<strong>静态多态</strong>和<strong>动态多态</strong>：</p>
<ul>
<li><p>静态多态主要是<strong>重载</strong>，在编译的时候就已经确定。</p>
<ul>
<li><strong>函数重载</strong></li>
<li><strong>运算符重载</strong></li>
<li><strong>模板</strong></li>
</ul>
</li>
<li><p>动态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。</p>
</li>
</ul>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，<strong>在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数</strong>。在子类中重新定义父类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<hr>
<h4><span id="虚函数的实现">虚函数的实现</span></h4><p>在有虚函数的类中，<strong>类的最开始部分是一个虚函数表的指针</strong>，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在 <code>代码段(.text)</code> 中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<p>虚表是一个<strong>指针数组</strong>，其元素是<strong>虚函数的指针</strong>，每个元素对应一个<strong>虚函数的函数指针</strong>。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。虚表内的条目，即<strong>虚函数指针的赋值发生在编译器的编译阶段</strong>，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<p>虚表是<strong>属于类</strong>的，而不是属于某个具体的对象，<strong>一个类只需要一个虚表</strong>即可。<strong>同一个类的所有对象都使用同一个虚表。</strong></p>
<p>⭐<code>Linux</code> 下虚表存储位置在<strong>只读数据段中(rodata)</strong>，<code>windows</code> 是在存储位置应该是<strong>常量区域。</strong> </p>
<p>为了指定对象的虚表，对象内部包含一个<strong>虚表的指针</strong>，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>void** __vfptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg" alt="img"></p>
<hr>
<h4><span id="动态绑定">动态绑定</span></h4><p>如果将基类的成员函数声明为 <code>virtual</code> 的，然后用<strong>指向派生类对象的基类指针或者引用</strong>来<strong>调用该成员函数</strong>，那么程序会<strong>在运行时选择该派生类的函数而不是基类的函数</strong>，这种特性成为<strong>运行时绑定</strong>（<strong>动态绑定</strong>、<strong>晚绑定</strong>）。</p>
<p>派生类虚函数要达成运行时动态绑定的效果，必须和基类的函数名、参数列表完全相同，否则仅仅是对基类虚函数的<strong>隐藏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类 <code>A</code> 是基类，类 <code>B</code> 继承类 <code>A</code> ，类 <code>C</code> 又继承类 <code>B</code> 。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> ，其对象模型如下图所示。由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（<code>A vtbl</code>），类B的虚表（<code>B vtbl</code>），类C的虚表（<code>C vtbl</code>）。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> 对象都拥有一个虚表指针<code>*__vptr</code>，用来指向自己所属类的虚表。</p>
<p><strong>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</strong>。</p>
<p><strong>生成子类虚表的过程：</strong></p>
<ol>
<li>将父类虚表内容拷贝到子类虚表上。</li>
<li>将子类重写的虚函数覆盖掉表中父类的虚函数。</li>
<li>如果子类有新增加的虚函数,按声明次序加到最后。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg" alt="img"></p>
<p>我们把经过虚表调用虚函数的过程称为<strong>动态绑定</strong>，其表现出来的现象称为<strong>运行时多态</strong>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为<strong>静态绑定</strong>，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p>
<ol>
<li><p>通过<strong>指针或引用</strong>来调用函数</p>
</li>
<li><p>指针<strong>upcast</strong>向上转型（继承类向基类的转换称为 <code>upcast</code> ，也就是用一个基类指针指向派生类对象）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base *base = <span class="keyword">new</span> Derived();<span class="comment">//upcast, cast Derived to Base</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用的是虚函数</p>
</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<hr>
<h4><span id="为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</span></h4><p>将<strong>可能会被继承的父类</strong>的析构函数设置为虚函数，可以保证当我们 <code>new</code> 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<hr>
<h4><span id="为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</span></h4><p>C++默认的析构函数不是虚函数是因为虚函数<strong>需要额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是<strong>只有当需要当作父类时，设置为虚函数。</strong></p>
<hr>
<h4><span id="为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</span></h4><p>1.<strong>从存储空间角度：</strong> 虚函数对应一个 <code>vtable</code> ，这个 <code>vtable</code> 其实是存储在<strong>对象的内存空间</strong>的。问题出来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到<code>vtable</code> ，所以构造函数不能是虚函数。<br><strong>2，从使用角度：</strong> 构造函数本身就是要<strong>初始化实例</strong>，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。<strong>虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数</strong>。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。<br><strong>3、构造函数不需要是虚函数，也不允许是虚函数：</strong>因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过基类的指针或引用去访问它。<br><strong>4、从实现上看，</strong><code>vtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数。</p>
<hr>
<h4><span id="静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</span></h4><p>⭐<strong>静态数据成员和静态成员函数可以被继承！</strong>具体如下：</p>
<ol>
<li>父类的 <code>static</code> 变量和函数在派生类中依然可用，但是<strong>受访问性控制</strong>（比如，父类的 <code>private</code> 域中的就不可访问），而且对 <code>static</code> 变量来说，派生类和父类中的 <code>static</code> 变量是<strong>共用空间</strong>的，这点在利用 <code>static</code> 变量进行引用计数的时候要特别注意。</li>
<li><code>static</code> 函数没有“虚函数”一说。因为 <code>static</code> 函数实际上是<strong>加上了访问控制的全局函数</strong>，全局函数哪来的什么虚函数的概念？</li>
<li>派生类的 <code>friend</code> 函数可以访问派生类本身的一切变量，包括从父类继承下来的 <code>protected</code> 域中的变量。但是对父类来说，他并不是 <code>friend</code> 的。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。所以 <code>static</code> 成员的这种应该算是继承。</li>
</ol>
<hr>
<h4><span id="友元可以继承吗">友元可以继承吗？</span></h4><p>⭐<strong>不能！</strong></p>
<p>友元只是能访问<strong>指定类的私有和保护成员的自定义函数</strong>，<strong>不是被指定类的成员</strong>，自然不能继承。 使用友元类时注意：</p>
<ol>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>A</code> 不一定是类 <code>B</code> 的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>C</code> 是 <code>B</code> 的友元，类 <code>C</code> 不一定是类 <code>A</code> 的友元，同样要看类中是否有相应的声明。</li>
</ol>
<hr>
<h4><span id="虚函数virtual可以是内联函数inline吗">虚函数(virtual)可以是内联函数(inline)吗？</span></h4><ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li><strong>内联是在编译器建议编译器内联</strong>，而<strong>虚函数的多态性在运行期</strong>，编译器无法知道运行期调用哪个代码，因此<strong>虚函数表现为多态性时（运行期）不可以内联</strong>。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：<strong>编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生</strong>。(上面第二种情况就是发生了运行期多态，是采用对象的指针或者引用、<code>upcast</code> 调用了对象的函数)</li>
</ul>
<hr>
<h4><span id="多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</span></h4><ol>
<li>基类对象首先被创建。</li>
<li>派生类构造函数应通过<strong>成员初始化列表</strong>（<strong>调用顺序和继承顺序相关</strong>）将基类信息传递给基类构造函数 ，可以使用初始化列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。</li>
<li>派生类构造函数<strong>应初始化派生类新增的数据成员</strong>。派生类对象析构时，程序<strong>首先调用派生类析构函数，再调用基类析构函数。</strong></li>
</ol>
<hr>
<h4><span id="类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</span></h4><ul>
<li><strong>函数重载：重载函数通常用来命名一组 <code>功能相似</code> 的函数</strong><ul>
<li>函数要在 <code>相同的类域</code></li>
<li>函数的 <code>名字要相同</code> </li>
<li>函数的 <code>参数列表或返回值不同</code> </li>
</ul>
</li>
<li><strong>函数重写/覆盖：覆盖是指 <code>派生类函数覆盖基类函数</code> </strong><ul>
<li>函数是要在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>基类函数 <code>必须是虚函数</code></li>
<li>两个函数的 <code>参数相同</code> </li>
</ul>
</li>
<li><strong>函数重定义/隐藏：指派生类的函数屏蔽了与其同名的基类函数</strong><ul>
<li>两个函数在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>两个函数的 <code>参数不同</code> </li>
<li><strong>如果派生类函数与基类函数参数相同，但是在基类函数中没有virtual关键字，发生函数隐藏</strong></li>
</ul>
</li>
</ul>
<hr>
<h4><span id="钻石继承问题">钻石继承问题</span></h4><p>为了解决上述菱形继承带来的问题，C++中引入了虚基类，其作用是在<strong>间接继承共同基类时只保留一份基类成员</strong>。虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态。对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象，共享基类子对象称为虚基类。虚基类用virtual声明继承关系就行了。这样一来，D就只有A的一份拷贝。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():a(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span>  <span class="keyword">public</span> B ,  <span class="keyword">public</span> C &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">	D d;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(d);</span><br><span class="line">	d.a=<span class="number">10</span>;</span><br><span class="line">	d.printA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c的四种cast">C++的四种cast</span></h3><h4><span id="static_cast">static_cast</span></h4><p>在C++语言中 <code>static_cast</code> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。例如将整型数据转换为浮点型数据。</p>
<p>主要用法有如下几种：</p>
<ol>
<li><p>用于类层次结构中基类和派生类之间指针或引用的转换。</p>
<p>进行<strong>上行转换</strong>（把派生类的指针或引用转换成基类表示）是<strong>安全</strong>的<br>进行<strong>下行转换</strong>（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，是<strong>不安全</strong>的</p>
</li>
<li><p>用于基本数据类型之间的转换，如把 <code>int</code> 转换成 <code>char</code> 。这种转换的安全也要开发人员来保证。</p>
</li>
<li><p>把空指针转换成目标类型的空指针。</p>
</li>
<li><p>把任何类型的表达式转换为 <code>void</code> 类型。</p>
</li>
</ol>
<ul>
<li>注意：<code>static_cast</code> 不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</li>
<li><code>static_cast</code> : 可以实现C++中内置基本数据类型之间的相互转换。</li>
<li>如果涉及到类的话，<code>static_cast</code> 只能在<strong>有相互联系的类型</strong>中进行相互转换,不一定包含虚函数。</li>
</ul>
<hr>
<h4><span id="const_cast">const_cast</span></h4><p><strong>const_cast&lt;type_id&gt; (expression)</strong></p>
<p><code>const_cast</code> 用于强制去掉 <code>const</code> 这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是<strong>去除指向常数对象的指针或引用的常量性</strong>，其去除常量性的对象必须为指针或引用。用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li>
<li>常量对象被转换成非常量对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> *q =<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    *q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="string">" "</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=10 *p=20 *q=20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，原来的 <code>a</code> 的常量性并没有被去除，而指向常量的指针 <code>p</code> 被转化成非常量指针，并且仍然指向原来的对象，并且指向的值被 <code>q</code> 改变成 <code>20</code> 。</p>
<hr>
<h4><span id="reinterpret_cast">reinterpret_cast</span></h4><p><strong>reinterpret_cast&lt;type_id&gt; (expression) </strong>主要有三种强制转换用途：</p>
<ol>
<li>改变指针或引用的类型。</li>
<li>将指针或引用转换为一个足够长度的整形。</li>
<li>将整型转换为指针或引用类型。</li>
</ol>
<p>其中， <code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。<code>reinterpret_cast</code> 可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。整型指针通过 <code>reinterpret_cast</code> 强制转换成了双精度浮点型指针如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code> 可以将指针或引用转换为一个足够长度的整形，此中的足够长度具体长度需要多少则取决于操作系统，如果是32位的操作系统，就需要4个字节及以上的整型，如果是64位的操作系统则需要8个字节及以上的整型。</p>
<hr>
<h4><span id="dynamic_cast">dynamic_cast</span></h4><p><strong>用法：dynamic_cast&lt;type_id&gt; (expression)</strong></p>
<ol>
<li><p>其他三种都是<strong>编译时完成</strong>的，dynamic_cast是<strong>程序运行</strong>时处理的，运行时要进行<strong>类型检查</strong>。</p>
</li>
<li><p>不能用于内置的基本数据类型的强制转换。</p>
</li>
<li><p><code>dynamic_cast</code> 转换如果成功的话返回的是<strong>指向类的指针或引用</strong>，转换失败的话则会返回 <code>NULL</code> 。</p>
</li>
<li><p><code>dynamic_cast</code>涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换</p>
</li>
<li><p>使用 <code>dynamic_cast</code> 进行转换的，<strong>基类中一定要有虚函数，否则编译不通过</strong>。<br>基类中需要检测有虚函数的原因：</p>
<ul>
<li>类中存在虚函数，就说明它有想<strong>要让基类指针或引用指向派生类对象</strong>的情况，此时转换才有意义。<br> 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。</li>
</ul>
</li>
<li><p>在类的转换时，在类层次间进行<strong>上行转换</strong> (子类指针转为父类指针) 时，<code>dynamic_cast</code> 和 <code>static_cast</code> 的效果是一样的。在进行<strong>下行转换</strong> (父类指针转为子类指针) 时，<code>dynamic_cast</code> 具有类型检查的功能，比 <code>static_cast</code> 更安全。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base* pB = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">if</span>(Derived* pD = <span class="keyword">static_cast</span>&lt;Derived*&gt;(pB))&#123;&#125;</span><br><span class="line"><span class="comment">//下行转换是不安全的(坚决抵制这种方法)</span></span><br><span class="line"></span><br><span class="line">Derived* pD = <span class="keyword">new</span> Derived();</span><br><span class="line"><span class="keyword">if</span>(Base* pB = <span class="keyword">static_cast</span>&lt;Base*&gt;(pD))&#123;&#125;</span><br><span class="line"><span class="comment">//上行转换是安全的</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li>在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。<code>dynamic_cast</code> 操作符则可以在运行期对可能产生问题的类型转换进行检查。这个检查主要来自<em>虚函数(virtual function)</em> 。在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名(function siguature)的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。</li>
</ol>
<hr>
<h4><span id="哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</span></h4><p>C风格的强制转换(Type Cast)容易理解,不管什么类型的转换都可以使用使用下面的方式.：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeName b = (TypeName)a;</span><br></pre></td></tr></table></figure>
<p><strong>static_cast</strong> 作用和C语言风格强制转换的效果基本一样，都没有运行时的类型检查来保证转换的安全性。</p>
<hr>
<h3><span id="c智能指针">C++智能指针</span></h3><p><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a></p>
<p>C++提出了智能指针，有以下四种<code>auto_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>, <code>unique_ptr</code>。其中后三个是 <code>C++11</code> 支持的，第一个已经被 <code>C++11</code> 弃用。</p>
<p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是<strong>栈上</strong>的对象，所以当函数（或程序）结束时<strong>会自动被释放通过智能指针管理分配的内存单元</strong>。</p>
<h4><span id="auto_ptr弃用">auto_ptr(弃用)</span></h4><p><code>auto_ptr</code> 采用<strong>所有权模式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，相当于 <code>p2</code> 剥夺了 <code>p1</code> 的所有权，但是当程序运行时访问 <code>p1</code> 将会报错。所以 <code>auto_ptr</code> 的缺点是：存在潜在的内存崩溃问题。</p>
<hr>
<h4><span id="unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</span></h4><p><code>unique_ptr</code> 实现<strong>独占式拥有或严格拥有</strong>概念，保证<strong>同一时间内只有一个智能指针</strong>可以指向该对象。它对于避免资源泄露 (例如“以new创建对象后因为发生异常而忘记调用delete”) 特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;</span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>同时，当程序试图将一个 <code>unique_ptr</code> 赋值给另一个时，如果源 <code>unique_ptr</code> 是个临时右值，编译器允许这么做；如果源 <code>unique_ptr</code> 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                          <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));       <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>#1</code> 留下悬挂的 <code>unique_ptr(pu1)</code> ，这可能导致危害。而 <code>#2</code> 不会留下悬挂的 <code>unique_ptr</code> ，因为它调用 <code>unique_ptr</code> 的构造函数，该构造函数创建的临时对象在其所有权让给 <code>pu3</code> 后就会被销毁</p>
<p>如果想要完成上面 <code>#1</code> 的操作，需要将一个 <code>unique_ptr</code> 赋给另一个，可以使用 <code>std::move()</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">std</span>::move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="shared_ptr">shared_ptr</span></h4><p><code>shared_ptr</code> 实现共享式拥有概念：多个智能指针可以指向相同对象，该对象和其相关资源会在<strong>最后一个引用被销毁</strong>时候释放。</p>
<p><code>shared_ptr</code> 使用计数机制来表明资源被几个指针共享。可以通过成员函数 <code>use_count()</code> 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 <code>auto_ptr</code> , <code>unique_ptr</code> , <code>weak_ptr</code> 来构造。当我们调用 <code>release()</code> 时，当前指针会释放资源所有权，计数减一。当计数等于 <code>0</code> 时，资源会被释放。</p>
<p>成员函数：</p>
<ul>
<li><p><code>use_count()</code> 返回引用计数的个数</p>
</li>
<li><p><code>unique()</code> 返回是否是独占所有权(use_count为 1 )</p>
</li>
<li><p><code>swap</code> 交换两个 <code>shared_ptr</code> 对象(即交换所拥有的对象)</p>
</li>
<li><p><code>reset</code> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li><p><code>get</code> 返回内部对象(指针), 由于已经重载了 <code>()</code> 方法, 因此和直接使用对象是一样的。</p>
<p>如 <code>shared_ptr&lt;int&gt; sp(new int(1));</code>  sp 与 sp.get() 是等价的。</p>
</li>
</ul>
<p><strong>引用计数带来的副作用</strong> <code>循环引用问题</code><br>A对象的指针指向B对象，B对象的指针指向了A对象。两个指针相互指向。<code>造成堆里的内存无法正常回收，造成内存泄漏。</code> 这个时候就需要 <code>weak_ptr</code> 了。</p>
<hr>
<h4><span id="weak_ptr">weak_ptr</span></h4><p><code>weak_ptr</code> 是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象，进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code> 。</p>
<p><code>weak_ptr</code> 只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 工作, <strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>, 它的构造和析构不会引起引用记数的增加或减少。</p>
<p><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题：</strong></p>
<p>如果两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。<code>weak_ptr</code> 是对对象的一种弱引用，不会增加对象的引用计数。</p>
<p><code>weak_ptr</code> 和 <code>shared_ptr</code> 之间可以相互转化，<code>shared_ptr</code> 可以直接赋值给<code>weak_ptr</code> ，<code>weak_ptr</code> 也可以通过调用 <code>lock</code> 函数来获得 <code>shared_ptr</code> 。</p>
<p>具体栗子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会只输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>出现了循环引用，当要跳出函数时，智能指针 <code>pa</code> ，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code> ，导致跳出函数时资源没有被释放(A\B的析构函数没有被调用)，如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 <code>A</code> 里面的 <code>shared_ptr pb_;</code> 改为 <code>weak_ptr pb_;</code> 运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">B delete</span><br><span class="line">A delete</span><br></pre></td></tr></table></figure>
<p>资源 <code>B</code> 的引用开始就只有 <code>1</code> ，当 <code>pb</code> 析构时，<code>B</code> 的计数变为 </p>
<p>​    <code>0</code> ，<code>B</code> 得到释放，<code>B</code> 释放的同时也会使 <code>A</code> 的计数减一，同时 <code>pa</code> 析构时使 <code>A</code> 的计数减一，那么 <code>A</code> 的计数为 <code>0</code> ， <code>A</code> 得到释放。</p>
<p>注意的是我们不能通过 <code>weak_ptr</code> 直接访问对象的方法，比如 <code>B</code> 对象中有一个方法 <code>print()</code> ,我们不能这样访问，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;pb_-&gt;print()</span><br></pre></td></tr></table></figure>
<p><code>pb_</code> 是一个 <code>weak_ptr</code> ，应该先调用 <code>lock()</code> 函数把它转化为 <code>shared_ptr</code> ，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> p = pa-&gt;pb_.lock();</span><br><span class="line">p-&gt;print();</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>如何判断weak_ptr的对象是否失效？</strong></p>
<ol>
<li><code>expired()</code> ：检查被引用的对象是否已删除。</li>
<li><code>lock()</code> 会返回 <code>shared_ptr</code> 指针，判断该指针是否为空。</li>
<li><code>use_count()</code> 也可以得到 <code>shared_ptr</code> 引用的个数，但速度较慢。</li>
</ol>
<hr>
<p><strong>shared_ptr 和 unique_ptr 区别</strong></p>
<p><code>unique_ptr</code> 具有唯一性，对指向的对象值存在唯一的 <code>unique_ptr</code> 。<code>unique_ptr</code> 不可复制，赋值，但是<code>std::move()</code> 可以转换对象的所有权，局部变量的返回值除外。与 <code>shared_ptr</code> 相比，若自定义删除器，<code>unique_ptr</code>需要在声明处指定删除器类型，而 <code>shared_ptr</code> 不需要，<code>shared_ptr</code> 自定义删除器只需要指定删除器对象即可；在赋值时，<code>shared_ptr</code> 可以随意赋值，删除器对象也会被赋值给新的对象。因为在 <code>unique_ptr</code> 的实现中，删除器对象是作为 <code>unique_ptr</code> 的一部分，而 <code>shared_ptr</code> 的删除器对象保存在<code>control_block</code> 中。</p>
<hr>
<h4><span id="智能指针是线程安全的吗">智能指针是线程安全的吗？</span></h4><p><code>shared_ptr</code> 本身不是 <code>100%</code> 线程安全的。</p>
<p>它的引用计数本身是安全且无锁的，智能指针的引用计数在手段上使用了<strong>atomic原子操作</strong>，只要 <code>shared_ptr</code> 在拷贝或赋值时增加引用，析构时减少引用就可以了。首先原子是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的。</p>
<p>但对象的读写则不是，因为<code>shared_ptr</code> 有<strong>两个数据成员</strong>，读写操作不能原子化：一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象，当智能指针发生拷贝的时候，标准库的实现是<strong>先拷贝智能指针</strong>，<strong>再拷贝引用计数对象</strong>（拷贝引用计数对象的时候，会使 <code>use_count++</code>），这两个操作并不是原子操作，隐患就出现在这里。<strong>两个线程中智能指针的引用计数同时++或–，这个操作不是原子的，假设引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了，违背了原子性。</strong></p>
<p>根据 <code>boost</code> 文档，<code>shared_ptr</code> 的线程安全级别和内建类型、标准库容器、<code>std::string</code> 一样，即：</p>
<ul>
<li>一个 <code>shared_ptr</code> 对象实体可被多个线程同时读取；</li>
<li>两个 <code>shared_ptr</code> 对象实体可以被两个线程同时写入，<code>析构</code> 算写操作；</li>
<li>如果要从多个线程读写同一个 <code>shared_ptr</code> 对象，那么需要加锁。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>读</code> 是安全的。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>写</code> 是不安全的。</li>
<li>同一个 <code>shared_ptr</code> 对象不能被多线程直接修改，但可以通过原子函数完成。</li>
<li>共享引用计数的不同的 <code>shared_ptr</code> 被多个线程 <code>写</code>  是安全的。</li>
</ul>
<hr>
<h3><span id="c对象的内存模型">C++对象的内存模型</span></h3><h4><span id="普通对象模型">普通对象模型</span></h4><p>对象是如何在内存中布局的？</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>存放位置</th>
<th>访问范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>非静态数据成员</td>
<td>每一个对象体内</td>
<td>为该对象专有</td>
</tr>
<tr>
<td>静态数据成员</td>
<td>程序的静态存储区内，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>成员函数（静态/非静态）</td>
<td>程序的代码段中，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>类内嵌套的各种类型（typedef、class、struct、enum等）</td>
<td>与放在类外面定义的类型除了定义域之外没有本质区别</td>
<td>遵循类内部的访问规则</td>
</tr>
</tbody>
</table>
<p>因此，构成对象本身的<strong>只有数据</strong>，类的成员函数不属于任何一个对象。<strong>非静态成员函数与对象之间的关系是通过this指针绑定的</strong>。</p>
<h4><span id="派生类的对象模型">派生类的对象模型</span></h4><p>派生类的对象是如何在内存中布局的？</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承自基类的非静态数据成员</td>
<td>作为对象自己专用的数据</td>
</tr>
<tr>
<td>继承自基类的非静态成员函数</td>
<td>作为类的成员函数一样访问</td>
</tr>
<tr>
<td>虚函数（继承的或者新增的）</td>
<td>所有虚函数的地址都存放在vtable里</td>
</tr>
<tr>
<td>多态类每一个对象中的vptr</td>
<td>函数指针的指针，指向所属类的vtable</td>
</tr>
<tr>
<td>继承自基类的vptr</td>
<td>继承和重用该vptr</td>
</tr>
<tr>
<td>多重继承的多个分支</td>
<td>每个分支都继承一个vptr并生成一个对应的vtable</td>
</tr>
</tbody>
</table>
<p><code>vptr</code> 在派生类对象中的相对位置不会随着继承的层次改变而改变，一般编译器会将 <code>vptr</code> 放在所有数据成员的最前面。为了支持 <code>RTTI</code> ，编译器会为每一个多态类创建一个 <code>type_info</code> 对象，并把其地址保存在该类 <code>vtable</code> 中的第一个位置。</p>
<h4><span id="vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</span></h4><ol>
<li>如果虚函数是第一次出现，则把它的函数地址指针依次插入到 <code>vtable</code> 的尾部。</li>
<li>如果派生类改写了基类的虚函数，则这个函数的地址在派生类 <code>vtable</code> 中的位置与其在基类 <code>vtable</code> 中的位置一致，而与其在派生类中的声明位置无关。也就是说<strong>一旦虚函数指针在 <code>vtable</code> 的位置确定，则它的位置就不会因为继承层次的改变而改变。</strong></li>
<li>派生类没有改写的基类虚函数被继承，位置与原先在 <code>vtable</code> 中的位置相同。</li>
</ol>
<hr>
<h3><span id="volitale关键字">Volitale关键字</span></h3><p> <code>volatile</code> 关键字直译应该是 <code>易变的</code> ，也就是它修饰的对象有可能突然发生不可预期的改变。被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p>
<p><code>volatile</code> 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>，从而可以<strong>提供对特殊地址的稳定访问</strong>。</p>
<p><code>volatile</code> 可理解为编译器警告指示字；<code>volatile</code> 用于告诉编译器必须每次去内存中取变量值；<code>volatile</code>主要修饰可能被多个线程访问的变量；<code>volatile</code> 也可以修饰可能被未知因数更改的变量。</p>
<p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在<strong>主存(物理内存)</strong>当中的，这时就存在一个问题，由于CPU执行速度很快，而<strong>从内存读取数据</strong>和<strong>向内存写入数据</strong>的过程跟<strong>CPU执行指令的速度</strong>比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。</p>
<p>为了处理这个问题，在CPU里面就有了<strong>高速缓存(Cache)</strong>的概念。当程序在运行过程中，会将运算需要的数据<strong>从主存复制一份到CPU的高速缓存当中</strong>，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将<strong>高速缓存中的数据刷新到主存当中</strong>。</p>
<p>这一过程在单线程运行是没有问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存。这时就会出现同一个变量在两个高速缓存中的<strong>值</strong>不一致问题了。例如：两个线程分别读取了 <code>t</code> 的值，假设此时 <code>t</code> 的值为0，并且把 <code>t</code> 的值存到了各自的高速缓存中，然后线程1对 <code>t</code> 进行了加1操作，此时 <code>t</code> 的值为1，并且把 <code>t</code> 的值写回到主存中。但是线程2中高速缓存的值还是0，进行加1操作之后，<code>t</code> 的值还是为1，然后再把 <code>t</code> 的值写回主存。此时，就出现了 <code>线程不安全</code> 问题了。</p>
<p>按照 <a href="https://link.zhihu.com/?target=http%3A//web.archive.org/web/20180120044239/http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html" target="_blank" rel="noopener">Hans Boehm &amp; Nick Maclaren 的总结</a>，<code>volatile</code> 只在三种场合下是合适的。</p>
<ul>
<li><ul>
<li>和信号处理（signal handler）相关的场合；</li>
<li>和内存映射硬件（memory mapped hardware）相关的场合；</li>
<li>和非本地跳转（<code>setjmp</code> 和 <code>longjmp</code>）相关的场合。换句话说也就是</li>
</ul>
</li>
</ul>
<p>也就是：</p>
<p><strong>1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；</strong></p>
<p><strong>2) 多任务环境下各任务间共享的标志应该加volatile；</strong></p>
<p><strong>3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</strong></p>
<h4><span id="volatile指针">volatile指针</span></h4><p>和 <code>const</code> 修饰词类似，<code>const</code> 有常量指针和指针常量的说法，<code>volatile</code> 也有相应的概念：</p>
<ul>
<li>修饰由指针指向的对象、数据是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span>* vpch;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针自身的值——一个代表地址的整数变量，是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>(1) 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</strong></p>
<p>(2) 除了基本类型外，对用户定义类型也可以用 <code>volatile</code> 类型进行修饰。</p>
<p>(3) C++中一个有 <code>volatile</code> 标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用<code>const_cast</code> 来获得对类型接口的完全访问。此外，<code>volatile</code> 像 <code>const</code> 一样会从类传递到它的成员。</p>
<h4><span id="可见性">可见性</span></h4><h5><span id="什么是可见性">什么是可见性？</span></h5><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的<strong>工作空间</strong>中读取。<br>例如我们上面说的，当线程1对 <code>t</code> 进行了加1操作并把数据写回到主存之后，线程2就会知道它自己工作空间内的 <code>t</code> 已经被修改了，当它要执行加1操作之后，就会去主存中读取。这样，两边的数据就能一致了。<br>假如一个变量被声明为 <code>volatile</code> ，那么这个变量就具有了<strong>可见性</strong>的性质了。这就是 <code>volatile</code> 关键的作用之一了。</p>
<hr>
<p><strong>静态全局变量</strong>：注意使用 <code>static</code> 修饰变量，就不能使用 <code>extern</code> 来修饰，即 <code>static</code> 和 <code>extern</code> 不可同时出现。<code>static</code> 修饰的全局变量的声明与定义同时进行，即当你在头文件中使用 <code>static</code> 声明了全局变量，同时它也被定义了。</p>
<hr>
<h3><span id="c中指针和引用的区别">C++中指针和引用的区别</span></h3><ol>
<li><p>指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li><p>使用 <code>sizeof</code> 看一个指针的大小是 <code>4</code> ，而引用则是被引用对象的大小；</p>
</li>
<li><p>指针可以被初始化为 <code>NULL</code> ，而引用必须被初始化且必须是一个已有对象的引用；</p>
</li>
<li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
</li>
<li><p>可以有 <code>const</code> 指针，但是没有 <code>const</code> 引用；</p>
<ul>
<li><p><strong>指针常量</strong> <code>int *const P1</code>：指针常量约束的是该指针所指的地址，即指针变量本身，而并不是对象本身，地址不能够改变，但是对象值可以改变。<code>const</code> 在 <code>*</code> 后，表示约束的量是指针的地址。</p>
</li>
<li><p><strong>指向常量的指针</strong> <code>const int *P1</code> ：用 <code>const</code> 约束指针对所指对象进行访问时，这个指针称为指向常量的指针。<code>const</code> 在 <code>*</code> 前，表示约束的是指针量本身。<strong>指向常量的指针可以获取变量的地址，但限制用指针间址访问对象方式为“只读</strong>。</p>
</li>
</ul>
</li>
<li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p>
</li>
<li><p>指针可以有多级指针（<code>**p</code>），而引用只有一级；</p>
</li>
<li><p>指针和引用使用 <code>++</code> 运算符的意义不一样：引用自增被引用对象的值，指针自增内存地址</p>
</li>
<li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起<strong>内存泄露</strong>。</p>
</li>
</ol>
<hr>
<h3><span id="c中new与malloc的区别">C++中new与malloc的区别</span></h3><p><code>new</code> 和 <code>malloc</code> 的内存是分配在堆上的。也有说 <code>new</code> 是分配在自由存储区而 <code>malloc</code> 分配在堆上，自由存储区可以是堆也可以不是，具体要看 <code>new</code> 内部的实现。操作系统在堆上维护一个空闲内存链表，当需要分配内存的时候，就查找这个表，找到一块内存大于所需内存的区域，分配内存并将剩余的内存空间返还到空闲链表上(如果有剩余的话)。</p>
<ol>
<li><p><code>malloc</code> 和 <code>free</code> 是<strong>库函数</strong>，而 <code>new</code> 和 <code>delete</code> 是 <code>C++</code> <strong>操作符</strong>；</p>
</li>
<li><p><code>new</code> 自己计算需要的空间大小，比如 <code>int * a = new</code> ，<code>malloc</code> 需要指定大小，例如 <code>int * a = malloc(sizeof(int));</code> </p>
</li>
<li><p><code>new</code> 在动态分配内存的时候可以初始化对象，调用其构造函数，<code>delete</code> 在释放内存时调用对象的析构函数。而 <code>malloc</code> 只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回 <code>NULL</code> 。</p>
</li>
<li><p><code>new</code> 是 <code>C++</code> 操作符，是关键字，而 <code>operate new</code> 是 <code>C++</code> 库函数</p>
</li>
<li><p><code>opeartor new</code> / <code>operator delete</code> 可以重载，而 <code>malloc</code> 不行</p>
</li>
<li><p><code>new</code> 可以调用 <code>malloc</code> 来实现，但是 <code>malloc</code> 不能调用 <code>new</code> 来实现</p>
</li>
<li><p>对于数组，C++定义 <code>new[]</code> 专门进行动态数组分配，用 <code>delete[]</code> 进行销毁。<code>new[]</code> 会一次分配内存，然后多次调用构造函数；<code>delete[]</code> 会先多次调用析构函数，然后一次性释放。</p>
</li>
<li><strong>malloc能够直观地重新分配内存</strong>：使用 <code>malloc</code> 分配的内存后，如果在使用过程中发现内存不足，可以使用<code>realloc</code> 函数进行内存重新分配实现内存的扩充。<code>realloc</code> 先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域；<code>new</code> 没有这样直观的配套设施来扩充内存。</li>
</ol>
<hr>
<h3><span id="c-内存对齐">C++ 内存对齐</span></h3><p>现代计算机中内存空间都是按照 <code>byte</code> 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的<strong>首地址的值</strong>是某个数 <code>k</code> （通常它为4或8）的倍数，这就是所谓的内存对齐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，32位系统下，<code>int</code> 占 <code>4 byte</code> ，<code>char</code> 占一个 <code>byte</code> ，那么将它们放到一个结构体中应该占<code>4+1=5byte</code>；但是实际上，<code>sizeof(s)</code> 得到的结果是 <code>8 byte</code> ，这就是内存对齐所导致的。</p>
<p><strong>为什么要内存对齐？</strong></p>
<p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，四字节，<code>8</code> 字节，<code>16</code> 字节甚至 <code>32</code> 字节为单位来存取内存，我们将上述这些存取单位称为<strong>内存存取粒度</strong>。</p>
<p>现在考虑 <code>4</code> 字节存取粒度的处理器取 <code>int</code> 类型变量（<code>32</code> 位系统），该处理器只能从地址为 <code>4</code> 的倍数的内存开始读取数据。这样处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p>
<p>每个特定平台上的编译器都有自己的默认<strong>对齐系数</strong>（也叫对齐模数）。<code>gcc</code> 中默认 <code>#pragma pack(4)</code> ，可以通过预编译命令 <code>#pragma pack(n)</code> ，<code>n = 1,2,4,8,16</code> 来改变这一系数。</p>
<p>有效对其值：是给定值 <code>#pragma pack(n)</code> 和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p><strong>内存对齐规则：</strong></p>
<ul>
<li><p>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 <code>offset</code> 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
</li>
<li><p><strong>结构体的总大小</strong>为有效对齐值的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">&#125;x3;</span><br></pre></td></tr></table></figure>
<p><code>x1</code> , <code>x2</code> , <code>x3</code> 的 <code>sizeof</code> 结果分别是 <code>8</code> ,  <code>12</code> , <code>8</code> 。</p>
<p>内存结构分别如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg" alt="img"></p>
<hr>
<h3><span id="c存储类型">C++存储类型</span></h3><p>C++中<strong>存储类型的说明符</strong>有四个：<strong>auto</strong>, <strong>register</strong>, <strong>static</strong>和<strong>extern</strong>。前两者称为<code>自动</code>类型，后两者分别为<code>静态</code>和<code>外部</code>类型。此外还有 <code>mutable存储类</code> 和 <code>thread_local 存储类</code> 。</p>
<hr>
<h4><span id="auto-自动变量">auto 自动变量</span></h4><p>用 <code>auto</code> 说明的变量，通常 <code>auto</code> 省略。局部变量都是自动类型。其生命期开始于块的执行，结束于块的结束。</p>
<p>自动变量的空间分配在<strong>栈</strong>中，在程序运行过程中，块开始执行时系统<strong>自动</strong>分配空间（未初始化时值为随机数），块执行结束时系统<strong>自动</strong>释放空间。因此，自动变量的<strong>生命期和作用域是一致的</strong>。</p>
<hr>
<h4><span id="register-寄存器变量">register 寄存器变量</span></h4><p>用 <code>register</code> 说明的变量，如 <code>register int i</code> ; 系统将这样说明的变量尽可能保存在寄存器中，以提高程序运行速度。但不同的编译器对哪些变量可以说明为寄存器变量有不同的规定，而且一般的编译器都会对寄存器的使用进行优化，所以不提倡使用寄存器变量。</p>
<hr>
<h4><span id="static-关键字">static 关键字</span></h4><p>静态变量存储在<strong>全局存储区(静态存储区)</strong>，在整个程序运行期间一直存在。如果程序未显式给出初始化值，系统自动初始化为全 <code>0</code>，且初始化只进行一次。静态变量占有的空间要到整个程序执行结束才释放，故静态变量具有<strong>全局生命期</strong>。</p>
<p>静态变量根据定义位置的不同还分为 <code>局部静态变量</code> 和 <code>全局静态变量</code> ，</p>
<ol>
<li><p><strong>局部静态变量：</strong></p>
<p>是指在块中定义的静态变量，当块第一次被执行的时候，编译器在<strong>全局存储区</strong>为其开辟空间并保存数据，该空间一直到整个程序结束才释放。该变量具有<strong>局部作用域</strong>，但却具有<strong>全局生命期</strong>。当定义它的函数或者语句块结束的时候，作用域结束。:star:但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且变量的值不变。</p>
</li>
<li><p><strong>全局静态变量：</strong></p>
<p>全局静态变量在声明他的文件之外是不可见的，作用域是从定义之处-&gt;文件结尾。</p>
</li>
<li><p><strong>静态函数：</strong></p>
<p>在函数返回类型前加 <code>static</code> ，函数就定义为静态函数。函数的定义和声明在默认情况下都是<code>extern</code> 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用 <code>static</code> 修饰，那么这个函数只可在本 <code>cpp</code> 内使用，不会同其他 <code>cpp</code> 中的同名函数引起冲突。</p>
<p>注意：不要在头文件中声明 <code>static</code> 的全局函数，不要在 <code>cpp</code> 内声明非 <code>static</code> 的全局函数，如果你要在多个 <code>cpp</code> 中复用该函数，就把它的声明提到头文件里去，否则 <code>cpp</code> 内部声明需加上static修饰。</p>
</li>
<li><p><strong>类的静态成员：</strong></p>
<p>在类中，静态成员可以实现多个对象之间的<strong>数据共享</strong>，并且使用静态数据成员还<strong>不会破坏隐藏的原则</strong>，即保证了安全性。因此，静态成员是<strong>类的所有对象中共享的成员</strong>，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
</li>
<li><p><strong>类的静态函数：</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)。</p>
<ol>
<li>静态成员函数<strong>是类的一个特殊的成员函数</strong></li>
<li>静态成员函数<strong>属于整个类所有，没有this指针</strong></li>
<li>静态成员函数<strong>只能直接访问静态成员变量和静态成员函数</strong></li>
<li><strong>可以通过类名直接访问类的公有静态成员函数</strong></li>
<li><strong>可以通过对象名访问类的公有静态成员函数</strong></li>
<li><strong>定义静态成员函数，直接使用static关键字修饰即可</strong></li>
</ol>
<p>这里面有一种很常见的情况是，在 <code>sort()</code> 函数中，<code>sort</code> 函数的参数 <code>cmp</code> 的调用要求不带 <code>this</code> 指针，对于类内函数，他们都有一个隐式的 <code>this</code> 指针在第一个参数内，因此要么把 <code>cmp</code> 写在类外，要么加上 <code>static</code> 声明，<code>static</code> 声明后的成员函数不带有 <code>this</code> 指针。所以要写成如下形式：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="extern关键字">extern关键字</span></h4><p><code>extern</code> 是一种<strong>外部声明</strong>的关键字，字面意思就是<strong>在此处声明</strong>某种变量或函数，<strong>在外部定义</strong>。</p>
<p><code>extern</code> 关键字的主要作用是<strong>扩大变量/函数的作用域</strong>，使得其它源文件和头文件可以复用同样的变量/函数，也起到类似“分块储存”的作用，划分代码。如图所示，在一个头文件里做了外部声明，就能把变量的定义部分和函数体的实现部分转移到其它地方了。</p>
<p><img src="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png" alt="img"></p>
<p>此外 <code>extern</code> 也可用来进行<strong>链接指定</strong>：当它与 <code>C</code> 一起连用时，如: <code>extern &quot;C&quot; void fun(int a, int b);</code> 则告诉编译器在编译 <code>fun</code> 这个函数名时按着 <code>C</code> 的规则去翻译相应的函数名而不是 <code>C++</code> 的，<code>C++</code> 的规则在翻译这个函数名时会把 <code>fun</code> 这个名字变得面目全非，可能是 <code>fun@aBc_int_int#%$</code> 也可能是别的，因为 <code>C++</code> 支持函数的重载。</p>
<p><strong>对于extern关键字：只在头文件中做声明，真理总是这么简单</strong>。</p>
<hr>
<h4><span id="mutable-存储类">mutable 存储类</span></h4><p><strong>mutable</strong> 说明符仅适用于类的对象。它允许对象的成员替代常量。也就是说，<code>mutable</code> 成员可以通过 <code>const</code> 成员函数修改。</p>
<hr>
<h4><span id="thread_local-存储类">thread_local 存储类</span></h4><p><code>thread_local</code> 变量是 <code>C++11</code> 新引入的一种存储类型。它会影响变量的存储周期( <code>Storage duration</code> )。只有<code>thread_local</code> 关键字修饰的变量具有线程周期( <code>thread duration</code> )，这些变量(或者说对象）在线程开始的时候被生成( <code>allocated</code> )，在线程结束的时候被销毁( <code>deallocated</code> )。并且每 一个线程都拥有一个独立的变量实例。<code>thread_local</code> 可以和<code>static</code> 与 <code>extern</code>关键字联合使用，这将影响变量的链接属性。</p>
<hr>
<h3><span id="stdmove语义">std::move()语义</span></h3><p>在 <code>C++11</code> 中，标准库在 <code>&lt;utility&gt;</code> 中提供了一个有用的函数 <code>std::move</code> ，<code>std::move</code> 并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。  </p>
<hr>
<h3><span id="右值引用">右值引用</span></h3><p><strong>左值与右值</strong></p>
<p>左值可以取地址、位于等号左边；而右值没法取地址，位于等号右边。</p>
<p>有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<h4><span id="左值引用">左值引用</span></h4><p><strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure>
<p>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。但是，<strong>const左值引用</strong>是可以指向右值的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<p><code>const</code> 左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用 <code>const &amp;</code> 作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p>
<h4><span id="右值引用">右值引用</span></h4><p>右值引用的标志是 <code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>
<h4><span id="右值引用有办法指向左值吗">右值引用有办法指向左值吗</span></h4><p>可以通过 <code>std::move()</code> 实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>
<p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>。</p>
<p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参是个右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span> </span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// ref_a_left是个左值引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// ref_a_right是个右值引用</span></span><br><span class="line"> </span><br><span class="line">    change(a); <span class="comment">// 编译不过，a是左值，change参数要求右值</span></span><br><span class="line">    change(ref_a_left); <span class="comment">// 编译不过，左值引用ref_a_left本身也是个左值</span></span><br><span class="line">    change(ref_a_right); <span class="comment">// 编译不过，右值引用ref_a_right本身也是个左值</span></span><br><span class="line">     </span><br><span class="line">    change(<span class="built_in">std</span>::move(a)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_right)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_left)); <span class="comment">// 编译通过</span></span><br><span class="line"> </span><br><span class="line">    change(<span class="number">5</span>); <span class="comment">// 当然可以直接接右值，编译通过</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    <span class="comment">// 打印这三个左值的地址，都是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::move()</code> 会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以 <code>move</code> 返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：</p>
<p><strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p>
<p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 </p>
<p><strong>总的来说：</strong></p>
<ol>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以<strong>避免拷贝</strong>。</li>
<li>右值引用可以直接指向右值，也可以通过 <code>std::move</code> 指向左值；而左值引用只能指向左值( <code>const</code> 左值引用也能指向右值)。</li>
<li>作为函数形参时，右值引用更灵活。虽然 <code>const</code> 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// 编译失败，const左值引用不能修改指向变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> &amp;&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">5</span>);</span><br><span class="line">    f2(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际场景中，右值引用和 <code>std::move</code> 被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。在 <code>STL</code> 的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如 <code>std::vector</code> 的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<p>移动构造函数即：把被拷贝者的数据移动过来，被拷贝者后边就不要这个数据了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2：std::vector和std::string的实际例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"aacasxs"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.push_back(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.emplace_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.emplace_back(<span class="string">"axcsddcas"</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::vector方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有些 <code>STL</code> 类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_a = <span class="built_in">std</span>::make_unique&lt;A&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = <span class="built_in">std</span>::move(ptr_a); <span class="comment">// unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = ptr_a; <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<h4><span id="完美转发-stdforward">完美转发 std::forward()</span></h4><p>和<code>std::move</code>一样，<code>std::forward</code>也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换。</p>
<p>与 <code>move</code> 相比，<code>forward</code> 更强大，<code>move</code> 只能转出来右值，<code>forward</code> 都可以。</p>
<blockquote>
<p>std::forward<t>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</t></p>
</blockquote>
<h4><span id="autoampamp也是这个意思">auto&amp;&amp;也是这个意思</span></h4><p>迭代器中如果使用 <code>auto&amp;&amp;</code> 代表着接受任何初始化程序，无论它是左值表达式还是右值表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>         =&gt; will copy the <span class="built_in">vector</span>, but we wanted a reference</span><br><span class="line"><span class="keyword">auto</span>&amp;        =&gt; will only bind to modifiable lvalues</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;  =&gt; will bind to anything but make it <span class="keyword">const</span>, giving us const_iterator</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; =&gt; will bind only to rvalues</span><br></pre></td></tr></table></figure>
<p>所以说大部分情况下，<code>auto</code> 和 <code>auto&amp;&amp;</code> 能够解决大部分问题。</p>
<hr>
<h3><span id="c内联函数">C++内联函数</span></h3><h4><span id="内联函数有什么优点">内联函数有什么优点？</span></h4><ol>
<li><code>inline</code> 函数代码是被放到<strong>符号表</strong>中，使用时像宏一样展开，没有调用的开销，效率很高；</li>
<li><code>inline</code> 函数是真正的函数，所以要进行一系列的数据类型检查；</li>
<li><code>inline</code> 函数作为类的成员函数，可以使用类的保护成员及私有成员；</li>
</ol>
<p>C++中支持内联函数，其目的是为了<strong>提高函数的执行效率</strong>：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。用关键字 <code>inline</code> 放在函数定义(<strong>注意是定义而非声明</strong>)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上<strong>内联地</strong>展开，假设我们将 <code>max</code> 定义为内联函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>cout&lt;&lt;max(a, b)&lt;&lt;endl;</code> 的时候，编译时会展开为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;(a &gt; b ? a : b)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>Effective C++</code> 中，<code>Prefer consts，enums，and inlines to #defines</code>，建议我们用内联函数来替代宏定义。</p>
<h4><span id="缺点">缺点</span></h4><ol>
<li><strong>代码膨胀：</strong>内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li><strong>inline 函数无法随着函数库升级而升级</strong>：inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li><strong>是否内联，程序员不可控</strong>：内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4><span id="将内联函数放入头文件">将内联函数放入头文件</span></h4><p>关键字 <code>inline</code> 必须与函数定义体放在一起才能使函数成为内联，仅将 <code>inline</code> 放在函数声明前面不起任何作用。定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125;   <span class="comment">// 自动地成为内联函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 <code>inline</code> 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p>
<p>当然内联函数定义也可以放在源文件中，但此时<strong>只有定义的那个源文件可以用它</strong>，而且<strong>必须为每个源文件拷贝一份定义</strong>(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。</p>
<h4><span id="内联函数与宏定义的区别">内联函数与宏定义的区别？</span></h4><ol>
<li><p>内联函数在<strong>编译时展开</strong>，宏在<strong>预编译时展开</strong>；</p>
</li>
<li><p>内联函数直接<strong>嵌入到目标代码中</strong>，宏是简单的做<strong>文本替换</strong>；</p>
<p>所以这时候宏定义会出意想不到的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= ADD(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//所得的结果却是210</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------其实本质就是--------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= x + y * <span class="number">10</span>;  <span class="comment">//编译器并不会给其加括号</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内联函数有<strong>类型检测、语法判断</strong>等功能，宏没有；</p>
</li>
<li><p><code>inline</code> 函数是函数，宏不是；</p>
</li>
<li><p>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；</p>
</li>
<li><p>C++中引入了类及类的访问控制，在涉及到<strong>类的保护成员和私有成员</strong>就不能用宏定义来操作。</p>
</li>
</ol>
<hr>
<h4><span id="explicit关键字">explicit关键字</span></h4><ul>
<li><code>explicit</code> 修饰构造函数时，可以<strong>防止隐式转换和复制初始化</strong></li>
<li><code>explicit</code> 修饰转换函数时，可以<strong>防止隐式转换</strong>，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li>
</ul>
<hr>
<h4><span id="union-联合体">union 联合体</span></h4><p>联合(union)是一种节省空间的特殊的类，一个 <code>union</code> 可以有多个数据成员，但是<strong>在任意时刻只有一个数据成员可以有值</strong>。<strong>当某个成员被赋值后其他成员变为未定义状态</strong>。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li><strong>不能含有引用类型的成员</strong></li>
<li><strong>不能继承自其他类，不能作为基类</strong></li>
<li>不能含有虚函数</li>
<li>匿名 <code>union</code> 在定义所在作用域可直接访问 <code>union</code> 成员</li>
<li>匿名 <code>union</code> 不能包含 <code>protected</code> 成员或 <code>private</code> 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<hr>
<h3><span id="深拷贝与浅拷贝">深拷贝与浅拷贝</span></h3><p>C++中类的拷贝有两种：<strong>深拷贝</strong>，<strong>浅拷贝</strong>：当出现类的等号赋值时，即会调用拷贝函数。<br><strong>深拷贝与浅拷贝的区别</strong></p>
<ol>
<li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但<strong>当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂</strong>现象，所以，此时，必须采用深拷贝。</li>
<li>深拷贝与浅拷贝的区别就在于深拷贝<strong>会在堆内存中另外申请空间来储存数据</strong>，从而也就解决了指针悬挂的问题。简而言之，当<strong>数据成员中有指针时，必须要用深拷贝</strong>。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。</p>
<p>深拷贝的实现一般如下，即自己定义拷贝构造函数来实现深拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student();</span><br><span class="line">	~Student();</span><br><span class="line">	Student(<span class="keyword">const</span> Student &amp;s);<span class="comment">//深拷贝构造函数，const防止对象被改变</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Student::Student() &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">Student::~Student() &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; (<span class="keyword">int</span>)name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> name;</span><br><span class="line">	name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;s) &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(name, s.name, <span class="built_in">strlen</span>(s.name));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="built_in">string</span> &amp;name;</span><br><span class="line">    Address addr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">int</span> grade, <span class="built_in">string</span> name):grade(grade), name(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常量成员</strong>：常量成员只能初始化不能赋值，所以必须放在初始化列表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>引用类型</strong>：引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>对象成员</strong>：成员是其他类的对象，例如上面的 <code>Address  addr</code> 成员。如果把它放在构造函数的初始化列表里，此时会调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>，对这个类对象进行初始化。如果把它放在构造函数体中，会先调用 <code>Address</code> 类的<strong>默认构造函数</strong>，然后再调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>。从性能上考虑，把对象成员的初始化放在初始化列表里性能会更高。</li>
<li><strong>对象成员，并且这个对象只有含参数的构造函数，没有无参数的构造函数：</strong>如果我们有一个<strong>类成员</strong>，它本身是一个类或者是一个结构，而且这个成员它<strong>只有一个带参数的构造函数，而没有默认构造函数</strong>，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。</li>
<li><strong>子类初始化父类的私有成员</strong>，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数。</li>
</ul>
<hr>
<h3><span id="定位内存泄露及检测">定位内存泄露及检测</span></h3><p><a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" target="_blank" rel="noopener">https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html</a></p>
<p>(1)在 <code>windows</code> 平台下通过 <code>CRT</code> 中的库函数进行检测；<br>(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置<br>(3) <code>Linux</code> 下通过工具 <code>valgrind</code> 检测</p>
<hr>
<h3><span id="手写strcpymemcpystrcatstrcmp等函数">手写strcpy，memcpy，strcat，strcmp等函数</span></h3><h4><span id="strcpy">strcpy</span></h4><ol>
<li><p><code>const</code> 修饰：源字符串参数用 <code>const</code> 修饰，防止修改源字符串；</p>
</li>
<li><p>空指针检查：源指针和目的指针都有可能会出现空指针的情况，所以应该对其进行检查；</p>
</li>
<li><p>为什么要设置 <code>ret</code> 指针以及返回 <code>ret</code> 指针的位置，由于目的指针 <code>dst</code> 已经在进行移动了，所以用辅助指针 <code>ret</code> 表明首指针；</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数是没有考虑重叠的</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dst);</span><br><span class="line">    assert(src);</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑重叠</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(src) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dst &gt; src &amp;&amp; dst &lt; src + len) &#123;</span><br><span class="line">        dst = dst + size - <span class="number">1</span>;</span><br><span class="line">        src = src + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">            *dst-- = *src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">            *dst++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="memcpy">memcpy</span></h4><p>对于地址重叠的情况，该函数的行为是未定义的。因此自己动手实现 <code>memcpy()</code> 时就需要考虑地址重叠的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> *ret = dst;</span><br><span class="line">	<span class="keyword">char</span>* pdst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">	<span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">	<span class="keyword">if</span> (pdst &gt; src || pdst &lt; psrc + size) &#123;</span><br><span class="line">		pdst = pdst + size - <span class="number">1</span>;</span><br><span class="line">		psrc = psrc + size - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst-- = *psrc--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst++ = *psrc++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strlen">strlen</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    assert(<span class="literal">NULL</span> != str);</span><br><span class="line">    <span class="keyword">while</span> (*str++ != <span class="string">'\0'</span>) &#123;　</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcat">strcat</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*dst,<span class="keyword">const</span> <span class="keyword">char</span>*src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">while</span> (*dst != <span class="string">'\0'</span>)	</span><br><span class="line">        dst++;<span class="comment">//要在循环体内++；因为要是*strDest最后指向该字符串的结束标志’\0’</span></span><br><span class="line">	<span class="keyword">while</span> ((*dst++ = *src++) != <span class="string">'\0'</span>);<span class="comment">//赋值+自增+判断非结尾</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcmp">strcmp</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!str1 || !str2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (*str1 == *str2 &amp;&amp; str1 != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		str1++;</span><br><span class="line">		str2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="memmove">memmove</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *pdst, <span class="keyword">const</span> <span class="keyword">void</span>* psrc, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pdst || !psrc)   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span>* dst = (<span class="keyword">char</span>*)pdst;</span><br><span class="line">	<span class="keyword">char</span> *src = (<span class="keyword">char</span>*)psrc;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">if</span> (dst &lt; src || dst &gt;(src + n - <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst++) = *(src++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dst = dst + n - <span class="number">1</span>;</span><br><span class="line">		src = src + n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst--) = *(src--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="手写单例模式">手写单例模式</span></h3><p>线程安全懒汉式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // shared_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;  // mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt; Ptr;</span><br><span class="line">    ~Singleton()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"destructor called!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Singleton(Singleton&amp;)=delete;</span></span><br><span class="line">    <span class="comment">//Singleton&amp; operator=(const Singleton&amp;)=delete;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Ptr <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "double checked lock"</span></span><br><span class="line">        <span class="keyword">if</span>(m_instance_ptr==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(m_mutex);</span><br><span class="line">            <span class="keyword">if</span>(m_instance_ptr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">              m_instance_ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructor called!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Ptr m_instance_ptr;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialization static variables out of class</span></span><br><span class="line">Singleton::Ptr Singleton::m_instance_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton::Ptr instance = Singleton::get_instance();</span><br><span class="line">    Singleton::Ptr instance2 = Singleton::get_instance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="三个线程交替打印">三个线程交替打印</span></h3><hr>
<h3><span id="类模板和模板类的区别">类模板和模板类的区别？</span></h3><hr>
<h3><span id="海量数据问题">海量数据问题</span></h3><h4><span id="十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</span></h4><p>类似问题的解决方法思路：首先哈希将数据分成 <code>N</code> 个文件，然后对每个文件建立 <code>K</code> 个元素最小/大堆（根据要求来选择）。最后将文件中剩余的数插入堆中，并维持 <code>K</code> 个元素的堆。最后将 <code>N</code> 个堆中的元素合起来分析。可以采用归并的方式来合并。在归并的时候为了提高效率还需要建一个 <code>N</code> 个元素构成的最大堆，先用 <code>N</code> 个堆中的最大值填充这个堆，然后就是弹出最大值，指针后移的操作了。当然这种问题在现在的互联网技术中，一般就用 <code>map-reduce</code> 框架来做了。<br>大数据排序相同的思路：先哈希（哈希是好处是分布均匀，相同的数在同一个文件中），然后小文件装入内存快排，排序结果输出到文件。最后建堆归并。</p>
<h4><span id="十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></h4><p>在大规模数据处理中，常遇到的一类问题是，在海量数据中找出出现频率最高的前K个数，或者从海量数据中找出最大的前K个数，这类问题通常称为<strong>top K</strong>问题，如：在搜索引擎中，统计搜索最热门的 <code>10</code>个查询词；在歌曲库中统计下载率最高的前10首歌等等。</p>
<p>针对 <strong>top k</strong>类问题，通常比较好的方案是<strong>分治+trie树/hash+小顶堆</strong>，即先将数据集按照 <code>hash</code> 方法分解成多个小数据集，然后使用 <code>trie</code> 树或者 <code>hash</code> 统计每个小数据集中的 <code>query</code> 词频，之后用小顶堆求出每个数据集中出频率最高的前 <code>K</code> 个数，最后在所有 <code>top K</code> 中求出最终的 <code>top K</code> 。</p>
<hr>
<h3><span id="布隆过滤器">布隆过滤器</span></h3><h4><span id="什么情况下需要布隆过滤器">什么情况下需要布隆过滤器？</span></h4><ul>
<li>字处理软件中，需要检查一个英语单词是否拼写正确</li>
<li>在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上</li>
<li>在网络爬虫里，一个网址是否被访问过</li>
<li>yahoo, gmail等邮箱垃圾邮件过滤功能</li>
<li>如果一个黑名单网站包含100亿个黑名单网页，每个网页最多占64B，设计一个系统，判断当前的URL是否在这个黑名单当中，要求额外空间不超过30GB，允许误差率为万分之一。这种情况，如果全都在内存中查询的话，需要的内存是640GB。</li>
</ul>
<h4><span id="布隆过滤器的原理">布隆过滤器的原理。</span></h4><p><strong>布隆过滤器</strong>(Bloom Filter)是由布隆(Burton Howard Bloom)在1970年提出的。它实际上是由<strong>一个很长的二进制向量和一系列随机映射函数</strong>组成。</p>
<p>布隆过滤器可以用于<strong>检索一个元素是否在一个集合</strong>中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p><img src="https://pic1.zhimg.com/80/v2-da022f1196cfbe2f439a21cd64208e10_720w.jpg" alt="img"></p>
<h4><span id="位图bitmap">位图(bitmap)</span></h4><p>布隆过滤器其中重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有1个 <code>bit</code> ，而每个 <code>bit</code> 只有 <code>0</code> 和 <code>1</code> 两种状态。如上图 <code>bit array</code> 所示。<code>bit array</code> 也叫 <code>bitmap</code> ，大小也就是布隆过滤器的大小。</p>
<p>假设我们有 <code>k</code> 个哈希函数，且每个哈希函数的输出范围都大于 <code>m</code> ，接着将输出值对 <code>k</code> 取余（%m）,就会得到 <code>k</code> 个 <code>[0, m-1]</code> 的值，由于每个哈希函数之间相互独立，因此这 <code>k</code> 个数也相互独立，最后将这 <code>k</code> 个数对应到<code>bitarray</code> 上并标记为 <code>1</code> 。</p>
<p>等到要判断某一个元素是否存在时，将输入对象经过这 <code>k</code> 个哈希函数计算得到 <code>k</code> 个值，然后判断对应 <code>bitarray</code> 的 <code>k</code> 个位置是否都为 <code>1</code> ，<strong>如果有一个不为1，那么这个输入对象则不在这个集合中；如果都是黑，那说明在集合中，但有可能会误判</strong>，由于当输入对象过多，而集合也就是 <code>bitarray</code> 过小，则会出现大部分为黑的情况，那样就容易发生误判！因此使用布隆过滤器是需要容忍错误率的，即使很低很低！</p>
<h4><span id="布隆过滤器大小计算">布隆过滤器大小计算</span></h4><p>假设输入对象个数为 <code>n</code> ，<code>bitarray</code> 大小（也就是布隆过滤器大小）为 <code>m</code> ，所容忍的误判率 <code>p</code> 和哈希函数的个数 <code>k</code> 。计算公式如下：（<strong>小数向上取整</strong>）</p>
<p><img src="https://pic1.zhimg.com/80/v2-fc1fb96508a363b17d1bb7737dc51e54_720w.jpg" alt="img"></p>
<p>假设一个网页黑名单有URL为100亿，每个样本为64B，失误率为0.01%，经过上述公式计算后，需要布隆过滤器大小为25GB，这远远小于使用哈希表的640GB的空间。</p>
<p>并且由于是通过 <code>hash</code> 进行查找的，所以基本都可以在 <code>O(1)</code> 的时间完成。</p>
<h4><span id="布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</span></h4><hr>
<h3><span id="stl">STL</span></h3><h4><span id="hash-map冲突如何解决">Hash Map冲突如何解决？</span></h4><p>哈希表（Hash table，也叫散列表）， 是根据关键码值( <code>Key value</code> )而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p><strong>直接定址</strong>与<strong>解决冲突</strong>是哈希表的两大特点。</p>
<h5><span id="哈希函数">哈希函数</span></h5><ol>
<li><strong>直接定制法</strong>：哈希函数为关键字的线性函数如  $H(key)=a\times key+b$</li>
<li><strong>数字分析法</strong>：此种方法通常用于数字位数较长的情况，必须数字存在一定规律，其必须知道数字的分布情况</li>
<li><strong>平方取中法</strong>：如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。这种方法适合<strong>事先不知道数据并且数据长度较小的情况</strong></li>
<li><strong>折叠法</strong>：如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为 <code>hash</code> 地址。</li>
<li><strong>除留余数法</strong>：<code>H(key)=key MOD p</code> (p&lt;=m m为表长) <code>p</code> 应为不大于 <code>m</code> 的质数或是不含 <code>20</code> 以下的质因子的合数，这样可以减少地址的重复(冲突)。</li>
</ol>
<h5><span id="哈希冲突解决方案">哈希冲突解决方案</span></h5><ol>
<li><p><strong>开放定制法</strong></p>
<p>对于哈希函数 <code>H(key)</code> ，如果 $key_1$ 和 $key_i$ 哈希冲突，那么 $key_i$ 存储的位置为 $H_i=(H(key)+d_i)mod (m)$</p>
<ol>
<li><p><strong>线性探测再散列</strong>：$d_i=c∗i$</p>
<p>例如可以取 $d_i=1$，即冲突后存储在冲突后一个位置，如果仍然冲突继续向后线性探测。</p>
</li>
<li><p><strong>平方探测再散列</strong>：$d_i=1^2,-1^2,2^2,-2^2……$</p>
</li>
<li><p>随机探测再散列(双探测再散列)：$d_i$ 是一组伪随机数列</p>
</li>
</ol>
</li>
<li><p><strong>链地址法</strong></p>
<p>产生 <code>hash</code> 冲突后在存储数据后面加一个指针，指向后面冲突的数据(链地址法是可以直接删除元素的)</p>
<p><img src="https://img-blog.csdn.net/20180520012305597" alt="这里写图片描述"></p>
</li>
<li><p><strong>公共溢出区法</strong><br>建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。</p>
</li>
<li><p><strong>再散列法(rehash)</strong></p>
<p>准备若干个 <code>hash</code> 函数，如果使用第一个 <code>hash</code> 函数发生了冲突，就使用第二个 <code>hash</code> 函数，第二个也冲突，使用第三个……</p>
</li>
</ol>
<hr>
<h4><span id="hash_map扩容发生什么">Hash_map扩容发生什么</span></h4><ol>
<li>创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到<em>sqrt</em>(<em>n</em>)范围内的数)  </li>
<li>将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换)</li>
<li>通过swap函数将新桶和旧桶交换，销毁新桶</li>
</ol>
<hr>
<h4><span id="unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</span></h4><p><code>HashSet(unordered_set)</code> 和 <code>HashMap(unordered_map)</code> 都是以 <code>hashtable</code> 作为底层机制，提供与 <code>set</code> 和<code>map</code> 完全相同的操作，但是 <code>Hash</code> 版本的容器不提供自动排序的功能，非 <code>Hash</code> 的版本是以 <code>RB-tree</code> 作为底层机制，也就提供排序的能力。总体来说，<code>hash_map</code> 查找速度会比 <code>map</code> 快，而且查找速度基本和数据数据量大小，属于常数级别；而 <code>map</code> 的查找速度是 <code>log(n)</code> 级别。</p>
<h5><span id="map与unordered_map的区别">map与unordered_map的区别</span></h5><p>他们俩存储时是根据 <code>key</code> 的 <code>hash</code> 值判断元素是否相同，而 <code>unordered_map</code> 内部元素是无序的，<code>map</code> 中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时 <code>map</code> 的 <code>key</code> 需要定义<code>operator&lt;</code>。而 <code>unordered_map</code> 需要定义 <code>hash_value</code> 函数并且重载 <code>operator==</code> 。但是很多系统内置的数据类型都自带这些。总结： <code>map</code> 重载 <code>&lt;</code> 运算符，<code>unordered_map</code> 重载 <code>==</code> 运算符。</p>
<p><strong>set/map</strong>底层实现的机制是<strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，默认是按升序排序的。在红黑树上做查找、插入、删除操作的时间复杂度为 <code>O(logN)</code> 。(<strong>比较稳定</strong>)</p>
<p><strong>红黑树的缺点</strong>：空间占用率高，每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</p>
<p><strong>std::unordered_map</strong>对应哈希表，哈希表的特点就是<strong>查找效率高</strong>，时间复杂度为常数级别<strong>O(1)</strong>，而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 <code>std::unordered_map</code> 容器。而如果对<strong>内存大小比较敏感</strong>或者<strong>数据存储要求有序</strong>的话，则可以用 <code>std::map</code> 容器。</p>
<h5><span id="为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？红黑树查询效率为什么快？</span></h5><p>红黑树不仅是作为 <code>AVL</code> 的工程版本，在增加节点颜色、不严格平滑等特性实现了更高效的插入和删除。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。<strong>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种弱平衡二叉树，相对于要求严格的 <code>AVL</code> 树来说，它的<strong>旋转次数少</strong>，所以对于<strong>搜索，插入，删除操作较多的情况</strong>下，通常使用红黑树。<code>AVL</code> 树是高度平衡的，频繁的插入和删除，会引起频繁的 <code>rebalance</code> ，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多<strong>两次</strong>旋转，删除最多<strong>三次</strong>旋转。</p>
<p>红黑树满足以下特征：</p>
<ol>
<li><strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</strong></li>
<li><strong>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;=2bd</strong></li>
<li><strong>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;=2log(n+1)</strong></li>
</ol>
<h4><span id="为何map和set的插入删除效率比用其他序列容器高">为何map和set的插入删除效率比用其他序列容器高？</span></h4><p>对于<strong>关联容器</strong>来说，不需要做内存拷贝和内存移动。说对了，确实如此。<code>map</code> 和 <code>set</code> 容器内所有元素都是以红黑树节点（如下）的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line">  /  \</span><br><span class="line"> B    C</span><br><span class="line">/ \  /  \</span><br><span class="line">D E  F  G</span><br></pre></td></tr></table></figure>
<p>因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点就OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p>
<h5><span id="为什么每次insert之后以前保存的iterator不会失效">为什么每次insert之后，以前保存的iterator不会失效</span></h5><p><code>iterator</code> 这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于 <code>vector</code> 来说，每一次删除和插入，指针都有可能失效，调用 <code>push_back</code> 在尾部插入也是如此。因为为了保证内部数据的连续存放，<code>iterator</code> 指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时 <code>push_back</code> 的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。</p>
<hr>
<h4><span id="vector相关">vector相关</span></h4><h5><span id="vector空间的动态增长">vector空间的动态增长</span></h5><h5><span id="vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</span></h5><hr>
<h4><span id="stl里的内存池实现">STL里的内存池实现</span></h4><p>首先我们需要明确, 内存池的目的到底是什么?我们每次使用 <code>new T</code> 来初始化类型 <code>T</code> 的时候, 其实发生了<strong>两步</strong>操作：</p>
<p> 第一步是<strong>内存分配</strong>， 这一步使用的其实不是 <code>new</code> 而是 <code>operator new</code> (也可以认为就是C语言中的 <code>malloc</code> )，这一步是直接和操作系统打交道的，操作系统可能需要经过相对繁琐的过程才能将一块指向空闲内存的指针返回给用户，所以这也是 <code>new</code> 比较耗时的一部分。</p>
<p>第二步是<strong>使用构造函数初始化该内存</strong>，这是我们比较熟悉。既然内存分配耗时。那我们很容易想到的就是一次性分配一大块内存，然后在用户需要的时候再划分其中一部分给用户。这样<strong>一次分配，多次使用</strong>， 自然而然提高了效率。而用来<strong>管理这所谓的一大块内存的数据结构</strong>，也就是今天我们要说的<strong>内存池</strong>。另外一个好处在于，频繁地使用 <code>new</code> 将导致系统内存空间碎片化严重，容易导致的后果就是很难找到一块连续的大块内存，空间利用率低。</p>
<p><code>STL</code> 内存分配分为<strong>一级分配器</strong>和<strong>二级分配器</strong>，一级分配器就是采用<strong>malloc分配内存</strong>，二级分配器采用<strong>内存池</strong>。</p>
<p>第二级配置器目的解决小型区块造成的内存碎片问题。</p>
<p>二级分配器设计的非常巧妙，分别给 <code>8byte</code> ，<code>16byte</code> ,…, <code>128byte</code> 等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块 <code>10K</code> 的内存，那么就找到最小的大于等于 <code>10byte</code> 的块，也就是 <code>16byte</code> ，从 <code>16byte</code> 的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。如果要分配的内存大于 <code>128byte</code> 则直接调用一级分配器。为了节省维持链表的开销，内存池采用了一个 <code>union</code> 结构体，分配器使用 <code>union</code> 里的 <code>next</code> 指针来指向下一个节点，而用户则使用 <code>union</code> 的空指针来表示该节点的地址。</p>
<p>使用<strong>自由链表(free-list)技巧</strong>。主动将不论什么小额区块的内存需求量上调至 <code>8</code> 的倍数。如需求 <code>30</code> ，则上调至<code>32</code> 。内存池可以认为由上面的一个<strong>指针数组</strong>和下面的<strong>自由链表</strong>两部分组成, 指针数组中第一个指针指向的是存放内存大小为 <code>8bytes</code> 的节点串接而成的自由链表, 之后依次是内存 <code>16bytes</code> , <code>24bytes</code> 直到 <code>128bytes</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Align = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MaxBytes = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfFreeLists = MaxBytes / Align;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfAddedNodesForEachTime = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span> MemNode &#123;</span><br><span class="line">		MemNode*	_next;</span><br><span class="line">		<span class="keyword">char</span>		_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> obj *freeLists[NumberOfFreeLists];</span><br></pre></td></tr></table></figure>
<p><code>union</code> 每个成员的起始地址都是开头的位置，所以每次仅能使用一个成员，在链表中由<code>_next</code> 指向下个内存块的地址，在分配内存时由 <code>_data</code> 指向内存首地址，长度为1 的数组放在结构体最后一个成员位置，可以访问给结构体多分配的地址空间，这种技术叫做<strong>柔性数组</strong>。这样做的好处减少了对内存块管理时额外的内存损耗。想想我们学习数据结构时实现的链表，都是通过结构体的一个成员来指向下个节点的地址，多出了一个指针 <code>4Byte</code> 的内存消耗。参考 <code>STL</code> ，内存块的管理如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="内存块示意图"></p>
<h5><span id="内存的分配和回收">内存的分配和回收</span></h5><p><img src="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>每次从系统申请内存时都通过一个辅助函数将内存增到为 <code>8</code> 的倍数，上层请求内存时寻找最小能容纳当前请求的头节点索引；当找到索引位置时，如果内存块不为空，则取出当前内存块，将之后的链表节点向前移动，如果内存不够的话，再次向系统请求新的内存。内存回收时与此理相同，通过辅助函数找到索引位置，将内存块放入首部位置，之前的内存块后移。</p>
<hr>
<h2><span id="操作系统">操作系统</span></h2><h3><span id="linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</span></h3><p>物理内存用完就会使用交换空间（<code>swap</code>），会导致应用运行变慢。因为需要频繁在交换空间和内存之间换入换出数据。</p>
<hr>
<h3><span id="操作系统的四大特性">操作系统的四大特性</span></h3><ul>
<li><strong>并发</strong>：程序并发执行</li>
<li><strong>共享</strong>：共享资源</li>
<li><strong>虚拟</strong>：虚拟地址，为物理硬件提供逻辑接口来降低使用难度</li>
<li><strong>异步</strong>：进程走走停停，上下文切换</li>
</ul>
<hr>
<h3><span id="死锁活锁饥饿">死锁/活锁/饥饿</span></h3><h4><span id="死锁">死锁</span></h4><p>一组互相竞争资源的线程因互相等待，导致<strong>永久阻塞</strong>的现象。说白了就是：两个线程互相持有对方所需的资源，互不释放且互相等待。</p>
<p>常见的死锁：</p>
<ul>
<li>线程申请的锁资源被自己的线程锁住并且还没被释放，导致永远挂起</li>
<li>多线程竞争资源陷入循环等待 eg.T1拥有锁L1，T2拥有锁L2。此时T1申请L2，T2申请L1</li>
<li>进程推进顺序不当 eg.T1，T2分别产出D1，D2，并接受D2，D1，如果顺序反过来就会永远挂起。</li>
</ul>
<p><strong>死锁产生的条件</strong>：产生死锁<strong>必须同时满足以下四个条件</strong>，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件</strong>：进程申请的资源在一段时间内只能被一个进程使用</li>
<li><strong>请求与等待条件</strong>：进程已经拥有了一个资源，但是又申请新的资源，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。—-&gt;在进程运行之前就把需要申请的资源一次性申请到位，满足运行，不满足等待。</li>
<li><strong>不可剥夺条件</strong>：在一个进程没有用完，主动释放资源的时候，不能被抢夺</li>
<li><strong>循环等待条件</strong>：多个进程之间存在资源循环链</li>
</ul>
<h5><span id="死锁预防方式">死锁预防方式：</span></h5><ul>
<li>打破互斥条件：<strong>改造独占性资源为虚拟资源</strong>，大部分资源已无法改造。</li>
<li>打破不可抢占条件：<strong>当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源</strong>。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即<strong>进程运行前申请全部资源</strong>，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现<strong>资源有序分配策略</strong>，对所有设备实现分类编号，所有进程只能采用按<strong>序号递增</strong>的形式申请资源。</li>
</ul>
<h5><span id="银行家算法">银行家算法</span></h5><ol>
<li>安全性算法：假设释放一个进程，然后再找下一个能在剩余可用资源中被释放的进程。以此类推，如果都能被释放，系统处于安全状态</li>
<li>资源请求算法：三步判断是否分配资源</li>
</ol>
<ul>
<li>request&lt;=need[i]</li>
<li>request&lt;=available</li>
<li>available-=request; allocation[i]+=request; need[i]-=request 运行安全性算法</li>
</ul>
<h4><span id="活锁">活锁</span></h4><p><strong>活锁：</strong>是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。活锁不会被阻塞，而是不停检测一个永远不可能为真的条件。除去进程本身持有的资源外，活锁状态的进程会持续耗费宝贵的<a href="https://www.baidu.com/s?wd=CPU%E6%97%B6%E9%97%B4&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">CPU时间</a>。</p>
<h5><span id="解决方法">解决方法</span></h5><p><strong>线程谦让时，尝试等待一个随机的时间就可以了</strong>。“<code>等待一个随机时间</code>”的方案虽然很简单，却非常有效，<code>Raft</code> 这样知名的分布式一致性算法中也用到了它。</p>
<p>例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。</p>
<h4><span id="饥饿">饥饿</span></h4><p><strong>饥饿：</strong>是指如果线程 <code>T1</code>占用了资源 <code>R</code> ，线程 <code>T2</code> 又请求锁 <code>R</code> ，于是 <code>T2</code> 等待。<code>T3</code> 也请求资源 <code>R</code> ，当 <code>T1</code> 释放了 <code>R</code> 上的封锁后，系统首先批准了 <code>T3</code> 的请求，<code>T2</code> 仍然等待。然后 <code>T4</code> 又请求封锁 <code>R</code> ，当 <code>T3</code> 释放了 <code>R</code> 上的封锁之后，系统又批准了 <code>T4</code> 的请求……，<code>T2</code> 可能永远等待。也就是<strong>低优先级的线程资源一直被高优先级抢占</strong></p>
<h5><span id="解决方法">解决方法</span></h5><p>下面提供了<code>三种方案</code></p>
<ol>
<li>保证资源充足</li>
<li>公平地分配资源</li>
<li>避免持有锁的线程长时间执行</li>
</ol>
<hr>
<h3><span id="进程和线程的区别和联系">⭐进程和线程的区别和联系</span></h3><p>我们可以说“进程”是包含“线程”的，“线程”是“进程”的一个子集。进程是资源分配的最小单位，线程是程序执行的最小单位。一个程序至少有一个进程,一个进程至少有一个线程。线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。</p>
<p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系<strong>统进行资源分配和调度的基本单位，是操作系统结构的基础</strong>。 在当代面向线程设计的计算机结构中，<strong>进程是线程的容器</strong>。程序是指令、数据及其组织形式的描述，进程是程序的实体。每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。</p>
<p><strong>线程（thread）</strong> 是<strong>操作系统能够进行运算调度的最小单位</strong>。<strong>它被包含在进程之中，是进程中的实际运作单位</strong>。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。不同的线程共享进程的地址空间，全局变量（数据和堆）。在一个进程中，各个线程共享堆区，而进程中的线程各自维持自己的栈。</p>
<p><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160815231938828-201985819.png" alt="img"></p>
<p><strong>进程是由线程+内存+文件/网络句柄构成的</strong>，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。</p>
<p><strong>线程是由栈+PC(程序计数器)+TLS(线程本地存储)组成的。</strong>操作系统真正运行的是一个个的线程，而我们的进程只是它的一个容器。<strong>PC程序计数器是当前执行指令的地址</strong>，而这个指令是放在内存中。每个线程都有一串自己的指针，去指向自己当前所在内存的指针。计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的<br>这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。<strong>TLS</strong>用来存储线程所独有的数据。</p>
<ul>
<li>进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</li>
<li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li>
<li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li>
<li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li>
<li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li>
</ul>
<h3><span id="多进程和多线程的区别">多进程和多线程的区别？</span></h3><p>多进程使用fork()</p>
<p>多线程使用pthread_create()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,   <span class="comment">//新创建的线程ID指向的内存单元。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,  <span class="comment">//线程属性，默认为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), <span class="comment">//新创建的线程从start_rtn函数的地址开始运行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *<span class="keyword">restrict</span> arg <span class="comment">//默认为NULL。若上述函数需要参数，将参数放入结构中并将地址作为arg传入。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>多进程</strong></th>
<th><strong>多线程</strong></th>
<th><strong>总结</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用<strong>IPC</strong>；数据是分开的，<strong>同步简单</strong></td>
<td>因为共享进程数据，<strong>数据共享简单</strong>，但也是因为这个原因导致<strong>同步复杂</strong></td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td><strong>一个线程挂掉将导致整个进程挂掉</strong></td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<h5><span id="优劣">优劣</span></h5><table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<hr>
<h3><span id="临界区进程同步">临界区(进程同步)</span></h3><p>操作系统中，同一时刻内同一段代码可能会有多个<strong>进程</strong>在执行，而像 <code>文件读写</code> 、<code>硬件调用</code> 等操作都是排他性的，因此操作系统更应该做好临界区的设置。</p>
<p>临界区( <code>critical-section</code> )是解决进程协作的一个方法。将<strong>多个进程可能修改同一个共享变量的代码段</strong>设为临界区，当有进程进入临界区后，其他进程会被禁止进入，直到前一个进程离开临界区，其他进程才可以进入。即<strong>同一时刻只允许一个进程位于临界区</strong>内。伪代码形式可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//进入区</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="comment">//退出区</span></span><br><span class="line">	<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<p>临界区的实现需要满足以下三个条件：</p>
<ol>
<li><strong>互斥</strong>，即同一时刻只能有一个进程位于临界区内；</li>
<li><strong>前进</strong>，当多个进程同时等待进入临界区的时候，会有一个进程被选择进入</li>
<li><strong>有限等待</strong>，在进入区等待的进程必须在有限时间后进入临界区。</li>
</ol>
<p><strong>实现方式：</strong>对于操作系统的临界区实现，要分为<strong>抢占内核</strong>和<strong>非抢占内核</strong>来讨论。显然，非抢占内核不存在竞争的问题，因为在临界区内的进程不会被打断，除非进程主动退出。对抢占内核来说，就需要硬件或者软件（算法）上的支持来实现临界区。</p>
<p>软件支持的一个例子是 <code>Peterson</code> 算法。<code>Peterson</code> 算法的精髓在于用两个变量（或数组）来记录当前是否有进程位于临界区以及哪个进程位于临界区，这样通过在进入区检测并设置标记、退出区恢复标记可以实现临界区排他的特性。</p>
<p>硬件支持的方法是 <code>锁</code> ，从底层硬件的层面来看则是实现 <code>原子操作</code> 。进程在进入临界区前检测并申请锁，离开后释放锁。原子操作保证锁的正常运行。<br>Linux下的原子操作的数据结构是 <code>atomic_t</code> ，其定义放在 <code>&lt;linux/types.h&gt;</code> 下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125;<span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>对于单处理器单核系统来说，只要保证操作指令序列不被打断即可实现原子操作。对于简单的原子操作，<code>cpu</code> 实现上会提供单条指令，比如 <code>INC</code> 和 <code>XCHG</code> 。对于复杂的原子操作，需要包含多条指令。执行过程中，出现上下文切换行为，比如任务切换，中断处理等。这里的行为会影响原子操作的原子性。因此需要自旋锁 <code>spinlock</code> 来保证操作指令序列不会在执行的中途受干扰。</p>
<p>但是如果对于多处理器或者多核的系统，原子操作的实现除了需要 <code>spinlock</code> 来保证外，还需要保证不会受到同处理器上其他核，或者其他处理器的影响。当其他核上执行的指令访问的内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。</p>
<p>在 <code>x86架构</code> 中，提供了指令前缀 <code>LOCK</code> 。<code>LOCK</code> 保证了指令不会受其他处理器或 <code>cpu</code> 核的影响。在 <code>PentiumPro</code> 之前，<code>LOCK</code> 的实现，是通过锁住 <code>bus</code> （总线），从而阻止其他 <code>cpu</code> 核的内存访问。可想而知，这种实现是非常低效的。从 <code>PentiumPro</code> 开始，<code>LOCK</code> 只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<p><img src="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg" alt="img"></p>
<p>现在，大多数的 <code>x86</code> 处理器都支持了 <code>CAS</code> 的硬件实现，保证了多处理器多核系统下的原子操作的正确性。<code>CAS</code> 的实现同样无需锁住总线，只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<hr>
<h3><span id="原子操作">原子操作</span></h3><p>原子操作指的是不可再分的指令操作，即在执行原子操作时不可能被打断，要么原子操作没有执行，要么已经执行完毕。原子操作的实现必须需要硬件的支持，操作系统仅仅是在硬件指令的基础之上进行一次封装。对于没有实现原子操作的硬件，则需要操作系统从软件算法层面进行支持。</p>
<h4><span id="cas原子操作compare-and-swap">CAS原子操作(compare and swap)</span></h4><p>如果一个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是原子的(atomic)。</p>
<p><strong>为什么要有CAS：</strong>因为通过锁实现原子操作时，其他线程必须等待已经获得锁的线程运行完以后才能获得资源，这样就会占用系统的大量资源。<code>CAS</code> <strong>可以通过硬件层面的阻塞实现原子操作的安全</strong>。</p>
<p><code>CAS</code> 原子操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">    ATOMIC();</span><br><span class="line">    <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">    <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">    	*reg = newval;</span><br><span class="line">    END_ATOMIC();</span><br><span class="line">    <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了还有如下几个原子操作：</p>
<ul>
<li><strong>Fetch And Add：</strong>一般用来对变量做 <code>+1</code> 的原子操作。</li>
<li><strong>Test-and-set：</strong>写值到某个内存位置并传回其旧值。汇编指令 <code>BST</code> 。</li>
<li><strong>Test and Test-and-set</strong>：用来实现多核环境下相互排斥锁。</li>
</ul>
<p>C++11中的 <code>STL</code> 中的 <code>atomic</code> 类的函数能够跨平台使用。（完整的C++11的原子操作可參看 <a href="http://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">Atomic Operation Library</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( volatile std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br></pre></td></tr></table></figure>
<p>具体使用的时候可以如下实现无锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mutex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unlock = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">test_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!(__sync_bool_compare_and_swap (&amp;mutex,lock, <span class="number">1</span>) )) usleep(<span class="number">100000</span>);</span><br><span class="line">        count++;</span><br><span class="line">        __sync_bool_compare_and_swap (&amp;mutex, unlock, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="进程间如何通信">进程间如何通信？</span></h3><p><img src="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg" alt="6种Linux进程间的通信方式6种Linux进程间的通信方式"></p>
<h4><span id="应用场景">应用场景</span></h4><ol>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ol>
<p>本地的进程间通信（ <code>IPC</code> ）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<h4><span id="管道">管道</span></h4><p><strong>管道的概念</strong></p>
<ul>
<li>管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。</li>
<li>一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。</li>
<li><strong>数据被一个进程读出后，将被从管道中删除</strong>，其它读进程将不能再读到这些数据。</li>
<li>管道提供了简单的流控制机制，<strong>进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞</strong></li>
<li>管道包括<strong>无名管道</strong>和<strong>有名管道</strong>两种，前者<strong>用于父进程和子进程间的通信，后者可用于运行于同一系统中的任意两个进程间的通信</strong>。</li>
</ul>
<h5><span id="无名管道pipe">无名管道(pipe)</span></h5><p>无名管道是一种<strong>半双工</strong>的通信方式，数据只能<strong>单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系一般指的是父子关系。无明管道一般用于<strong>两个不同进程之间的通信</strong>。当一个进程创建了一个管道，并调用 <code>fork</code> 创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。</p>
<p><img src="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg" alt="这里写图片描述"></p>
<p>无名管道创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符(<strong>fd</strong>)：</p>
<ul>
<li><code>filedis[0]</code> 用于读管道。</li>
<li><code>filedis[1]</code> 用于写管道。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161031215306696" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20161031215332079" alt="img"></p>
<ul>
<li>管道通讯是<strong>单向</strong>的，有固定的<strong>读端和写端</strong>。</li>
<li>数据被进程从管道读出后，在管道中该数据就不存在了。</li>
<li>当进程去<strong>读取空管道</strong>的时候，进程会阻塞。</li>
<li>当进程<strong>往满管道写入数据</strong>时，进程会阻塞。</li>
<li>管道容量为 <strong>64KB</strong>(缓存区有限)</li>
<li><strong>必须在系统调用fork( )前调用pipe( )，否则子进程将不会继承文件描述符</strong></li>
</ul>
<hr>
<h5><span id="有名管道fifo">有名管道(FIFO)</span></h5><p>有名管道和无名管道基本相同，但也有不同点：无名管道只能由父子进程使用；但是通过有名管道，<strong>不相关的进程也能交换数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_tmode)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>pathname：FIFO文件名</p>
</blockquote>
<blockquote>
<p>mode：属性（见文件操作章节）</p>
</blockquote>
<p><strong>一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO。</strong></p>
<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
<hr>
<h4><span id="信号signal">信号(signal)</span></h4><ul>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
<hr>
<h4><span id="消息队列message-queue">消息队列(message queue)</span></h4><ul>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>
<li>消息队列<strong>克服了信号传递信息少</strong>、<strong>管道只能承载无格式字节流以及缓冲区大小受限</strong>等缺点。</li>
<li>消息队列 ( <code>message queue</code> )与 <code>PIPE</code> 相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符( <code>message_type</code> )。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照<strong>先进先出</strong>的顺序取出，也可以<strong>只取出符合某个识别符的消息</strong>(有多个这样的消息时，同样按照先进先出的顺序取出)。</li>
<li>消息队列与 <code>PIPE</code> 的另一个不同在于它并不使用文件 <code>API</code> 。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</li>
</ul>
<hr>
<h4><span id="共享内存shared-memory">共享内存(shared memory)</span></h4><ul>
<li>共享内存就是<strong>映射一段能被其他进程所访问的内存</strong>，这段共享内存<strong>由一个进程创建，但多个进程都可以访问</strong>。共享内存是⭐<strong>最快</strong>⭐的 <code>IPC(interprocess communication)</code> 方式，它是<strong>针对其他进程间通信方式运行效率低而专门设计</strong>的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li>
<li>可以用设备驱动模型中的 <code>mmap</code> 函数实现。<ul>
<li>共享内存与多线程共享 <code>global data</code> 和 <code>heap</code> 类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用 <code>semaphore</code> 同步，也可以在共享内存中建立 <code>mutex</code> 或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，<strong>不涉及内核的拷贝</strong>，所以它是效率最高的 <code>IPC</code> 方式。</li>
</ul>
</li>
<li><strong>优点</strong>：无须复制，快捷，信息量大</li>
<li><strong>缺点</strong>：<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题(映射到<strong>文件映射段</strong>)</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
<hr>
<h4><span id="信号量semophore">信号量(semophore )</span></h4><ul>
<li>信号量是一个计数器，可以用来<strong>控制多个线程对共享资源的访问</strong>，它不是用于交换大批数据，而是用于多线程之间的同步。它常作为一种<strong>锁机制</strong>，防止某进程在访问资源时其它进程也访问该资源。因此，<strong>主要作为进程间以及同一个进程内不同线程之间的同步手段</strong>。</li>
<li>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法。比如在任一时刻只能有一个执行线程访问代码的<strong>临界区</strong>。临界区是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说<strong>信号量是用来调协进程对共享资源的访问的</strong>。</li>
<li>信号量是一个特殊的变量，程序对其访问都是<strong>原子操作</strong>，且只允许对它进行等待(<code>P(sv)</code>) 和发送(<code>V(sv)</code>)信息操作。最简单的信号量是只能取 <code>0</code> 和 <code>1</code> 的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。</li>
<li>缺点是<strong>信号量有限</strong>。</li>
</ul>
<h5><span id="信号量工作原理">信号量工作原理</span></h5><p><strong>一个计数器，可以用来控制多个线程对共享资源的访问</strong></p>
<ul>
<li><strong>优点：可以同步进程</strong></li>
<li><strong>缺点：信号量有限</strong></li>
</ul>
<p>由于信号量只能进行两种操作等待和发送信号，即 <code>P(sv)</code> 和 <code>V(sv)</code> ，他们的行为是这样的：</p>
<ul>
<li><strong>P(sv)等待：</strong>如果 <code>sv</code> 的值大于零，就给它减 <code>1</code> ；如果它的值为零，就<strong>挂起</strong>该进程的执行</li>
<li><strong>V(sv)发送：</strong>如果有其他进程因等待 <code>sv</code> 而被挂起，就让它恢复运行，如果没有进程因等待 <code>sv</code> 而挂起，就给它加 <code>1</code> 。</li>
</ul>
<p>举个例子，就是两个进程共享信号量 <code>sv</code> ，一旦其中一个进程执行了 <code>P(sv)</code> 操作，它将得到信号量，并可以进入临界区，使 <code>sv</code> 减1。而第二个进程将被阻止进入临界区，因为当它试图执行 <code>P(sv)</code> 时，<code>sv</code> 为 <code>0</code> ，它会被挂起以等待第一个进程离开临界区域并执行 <code>V(sv)</code> 释放信号量，这时第二个进程就可以恢复执行。</p>
<p>其实从意义上来说，<code>semaphore</code> 就是一个计数锁，它允许被 <code>N</code> 个进程获得。当有更多的进程尝试获得 <code>semaphore</code> 的时候，就必须等待有前面的进程释放锁。当 <code>N</code> 等于 <code>1</code> 的时候，<code>semaphore</code> 与 <code>mutex</code> 实现的功能就完全相同。许多编程语言也使用 <code>semaphore</code> 处理多线程同步的问题。一个 <code>semaphore</code> 会一直存在在内核中，直到某个进程删除它。</p>
<hr>
<h4><span id="套接字socket">套接字(socket)</span></h4><ul>
<li><p>套接字也是一种进程间通信机制，与其他通信机制不同的是，它<strong>可用于不同机器间的进程通信</strong>。</p>
</li>
<li><p><strong>优点：</strong></p>
<ol>
<li>传输数据为<strong>字节级</strong>，传输数据<strong>可自定义</strong>，数据量小效率高</li>
<li>传输数据<strong>时间短</strong>，<strong>性能高</strong></li>
<li>适合于客户端和服务器端之间信息<strong>实时交互</strong></li>
<li>可以<strong>加密</strong>，<strong>数据安全性强</strong></li>
</ol>
</li>
<li><strong>缺点：</strong>需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<hr>
<h3><span id="进程线程的上下文">进程/线程的上下文</span></h3><h4><span id="进程的上下文可以分为哪几个部分">进程的上下文可以分为哪几个部分？</span></h4><ul>
<li><strong>用户级上下文</strong>：正文、数据、用户堆栈以及共享存储区；</li>
<li><strong>寄存器上下文</strong>：通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
<li><strong>系统级上下文</strong>：进程控制块(task_struct)、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
</ul>
<h4><span id="为什么切换线程比切换进程开销小">为什么切换线程比切换进程开销小</span></h4><p>一个程序进行起来后，会使用很多资源，比如使用寄存器，内存，文件等。每当切换进程时，必须要考虑保存当前进程的状态。状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开的文件描述符的集合，这个状态叫做上下文。可见，想要切换进程，保存的状态有很多。</p>
<p>线程是运行在进程上下文中的逻辑流，线程有自己的上下文，包括唯一的<strong>整数线程ID， 栈、栈指针、程序计数器、通用目的寄存器和条件码</strong>等等，线程的上下文是进程的自己，因此在线程切换的时候需要保存和恢复的上下文比线程要少很多，开销也就更小。</p>
<hr>
<h3><span id="多线程间通信和同步">多线程间通信和同步</span></h3><ul>
<li>锁机制：包括互斥锁/量（<code>mutex</code>）、读写锁（ <code>reader-writer lock</code> ）、自旋锁（ <code>spin lock</code> ）、条件变量（ <code>condition variable</code> ）<ul>
<li>互斥锁/量（<code>mutex</code>）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（<code>reader-writer lock</code>）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（<code>spin lock</code>）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（<code>condition</code> ）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。<strong>条件变量始终与互斥锁一起使用</strong>。</li>
</ul>
</li>
<li>信号量机制( <code>Semaphore</code> )<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制( <code>Signal</code> )：类似进程间的信号处理</li>
<li>屏障（ <code>barrier</code> ）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于<strong>线程同步</strong>，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<hr>
<h3><span id="协程">⭐协程</span></h3><p><strong>什么是协程</strong></p>
<p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。在C++20中出现了<strong>coroutine</strong>的库。协程的作用是在<strong>同一个线程中通过保存代码执行段状态，进行代码段的分次执行，以及多个代码段的交织执行</strong>。每个代码段可以成为一个协程。协程的好处是<strong>避免了线程之间的频换切换</strong>、<strong>以及线程安全的优化</strong>（对于同一个变量的访问无需做同步控制）。</p>
<p><strong>协程是非抢占式的，线程是抢占式的。</strong></p>
<p>平时正常的程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。而协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg" alt="img"></p>
<p>协程不是被操作系统内核所管理的，而是<strong>完全由程序所控制</strong>，也就是在<strong>用户态</strong>执行。这样带来的好处是<strong>性能大幅度的提升</strong>，因为不会像线程切换那样消耗资源。</p>
<p>协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p>一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以有多个这样的特殊函数在运行，但是有一点必须明确的是：</p>
<blockquote>
<p><strong>一个线程的多个协程的运行是串行的</strong>。</p>
</blockquote>
<p>如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。<strong>当一个协程运行时，其它协程必须挂起</strong>。</p>
<p>C/C++ 语言本身是不能天然支持协程的。现有的 C++ 协程库均基于两种方案：<strong>利用汇编代码控制协程上下文的切换，以及利用操作系统提供的 API 来实现协程上下文切换</strong>。</p>
<p>在C++里，一个函数如果其函数体实现中包含 <code>co_await</code> 、<code>co_yield</code> 、<code>co_return</code> 中任何一个关键字，那么这个函数就是一个coroutine。其中：</p>
<ol>
<li><code>co_await</code>：挂起当前的coroutine。</li>
<li><code>co_return</code>：从当前coroutine返回一个结果。</li>
<li><code>co_yield</code>：返回一个结果并且挂起当前的coroutine。</li>
</ol>
<h4><span id="libco库">libco库</span></h4><ul>
<li><p><code>co_create_env()</code> 创建协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stStackMem_t</span> &#123;</span></span><br><span class="line">    stCoRoutine_t* occupy_co;  <span class="comment">// 使用该栈的协程</span></span><br><span class="line">    <span class="keyword">int</span> stack_size;            <span class="comment">// 栈大小</span></span><br><span class="line">    <span class="keyword">char</span>* stack_bp;            <span class="comment">// 栈底指针，栈从高地址向低地址增长</span></span><br><span class="line">    <span class="keyword">char</span>* stack_buffer;        <span class="comment">// 栈底</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_resume()</code> 激活协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">( stCoRoutine_t *co )</span> </span>&#123;</span><br><span class="line">    stCoRoutineEnv_t *env = co-&gt;env;</span><br><span class="line">    <span class="comment">// 获取当前正在运行的协程的结构</span></span><br><span class="line">    stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    <span class="keyword">if</span>( !co-&gt;cStart ) &#123;</span><br><span class="line">        <span class="comment">// 为将要运行的 co 布置上下文环境</span></span><br><span class="line">        coctx_make( &amp;co-&gt;ctx,(<span class="keyword">coctx_pfn_t</span>)CoRoutineFunc,co,<span class="number">0</span> );</span><br><span class="line">        co-&gt;cStart = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;pCallStack[ env-&gt;iCallStackSize++ ] = co;  <span class="comment">// 设置co为运行的线程</span></span><br><span class="line">    co_swap( lpCurrRoutine, co );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_swap()</code> 实现上下文切换，<code>co_swap</code> 具体完成三项工作：</p>
<ol>
<li>记录当前协程 <code>curr</code> 的运行栈的栈顶指针，通过 <code>char c; curr_stack_sp=&amp;c</code> 实现，当下次切换回 <code>curr</code>时，可以从该栈顶指针指向的位置继续，执行完 <code>curr</code> 后可以顺利释放该栈。</li>
<li>处理共享栈相关的操作，并且调用函数 <code>coctx_swap</code> 来完成上下文环境的切换。注意执行完 <code>coctx_swap</code>之后，执行流程将跳到新的 coroutine 也就是 pending_co 中运行，后续的代码需要等下次切换回 <code>curr</code> 时才会执行。</li>
<li>当下次切换回 <code>curr</code> 时，处理共享栈相关的操作。</li>
</ol>
</li>
<li><p>对应于 <code>co_resume</code> 函数，协程主动让出执行权则调用 <code>co_yield</code> 函数。<code>co_yield</code> 函数调用了 <code>co_yield_env</code>，将当前协程与当前线程中记录的其他协程进行切换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_env</span><span class="params">( stCoRoutineEnv_t *env )</span> </span>&#123;</span><br><span class="line">    stCoRoutine_t *last = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">2</span> ];</span><br><span class="line">    stCoRoutine_t *curr = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    env-&gt;iCallStackSize--;</span><br><span class="line">    co_swap( curr, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3><span id="五种io模型">五种IO模型</span></h3><p><strong>阻塞IO、非阻塞IO、IO多路复用、信号驱动IO以及异步IO</strong></p>
<p>首先一个 <code>IO</code> 操作其实分成了两个步骤：</p>
<ol>
<li>用户进程向内核发起 <code>IO</code> 请求，等待内核数据准备</li>
<li>实际的 <code>IO</code> 操作,将数据从内核拷贝到进程缓存区中 </li>
</ol>
<p>阻塞IO和非阻塞IO的区别在于第一步，<strong>发起IO请求是否会被阻塞</strong>：如果阻塞直到完成那么就是传统的阻塞IO，</p>
<p>如果不阻塞，那么就是非阻塞IO。即进程/线程要访问的数据是否就绪，进程/线程是否需要等待。</p>
<p>同步IO和异步IO的区别就在于第二个步骤是否阻塞。如果实际的IO读写阻塞请求进程，那么就是同步IO，因此后面可以看到<strong>阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO</strong>；如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。</p>
<p>访问数据的方式：同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。</p>
<p><img src="https://img-blog.csdn.net/20161028200140849" alt="img"></p>
<h4><span id="阻塞io">阻塞IO</span></h4><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p>
<p><img src="https://img-blog.csdn.net/20161028200138896" alt="img"></p>
<p>特点：</p>
<ol>
<li><strong>进程阻塞挂起不消耗CPU资源，及时响应每个操作</strong>；</li>
<li>实现难度低、开发应用较容易；</li>
<li>适用并发量小的网络应用开发；</li>
<li><strong>不适用并发量大的应用</strong>：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</li>
</ol>
<h4><span id="非阻塞io">非阻塞IO</span></h4><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p>
<p><img src="https://img-blog.csdn.net/20161028200139219" alt="img"></p>
<p>典型应用：<strong>socket</strong>是非阻塞的方式（设置为NONBLOCK）</p>
<p><strong>阻塞IO模型是一个阻塞IO调用，而非阻塞IO模型是多个非阻塞IO调用+一个阻塞IO调用，因为多个IO检查会立即返回错误，不会阻塞进程。</strong></p>
<p>特点：</p>
<ol>
<li><strong>进程轮询（重复）调用，消耗CPU的资源</strong>；</li>
<li>实现难度低、开发应用相对阻塞IO模式较难；</li>
<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>
</ol>
<h4><span id="io多路复用">IO多路复用</span></h4><p>多个的进程的IO可以注册到一个复用器(<code>select</code>)上，然后用一个进程调用该 <code>select</code> ， <code>select</code> 会监听所有注册进来的IO；如果 <code>select</code> 监听的IO在内核缓冲区都没有可读数据，<code>select</code> 调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，<code>select</code> 调用就会返回；而后 <code>select</code> 调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。可以看到，<strong>多个进程注册IO后，只有另一个select调用进程被阻塞。</strong></p>
<p><img src="https://img-blog.csdn.net/20161028200139703" alt="img"></p>
<p><strong>典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;</strong></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>专一进程解决多个进程IO的阻塞问题，性能好</strong>；<strong>Reactor模式;</strong></li>
<li>实现、开发应用难度较大；</li>
<li><strong>适用高并发服务应用开发：一个进程（线程）响应多个请求</strong>；</li>
</ol>
<h4><span id="信号驱动的io模型">信号驱动的IO模型</span></h4><p>当进程发起一个IO操作，会向内核注册一个<strong>信号处理函数</strong>，然后进程<strong>返回不阻塞</strong>；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p>
<p><img src="https://img-blog.csdn.net/20161028200140021" alt="img"></p>
<p><strong>特点：回调机制，</strong>实现、开发应用难度大；</p>
<h4><span id="异步io模型">异步IO模型</span></h4><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。<strong>如果IO操作成功则进程直接获取到数据</strong>。</p>
<p><img src="https://img-blog.csdn.net/20161028200140375" alt="img"></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>不阻塞，数据一步到位</strong>；<strong>Proactor模式</strong>；</li>
<li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>
<li>实现、开发应用难度大；</li>
<li>非常适合高性能高并发应用；</li>
</ol>
<hr>
<h3><span id="两种io事件处理模式">两种IO事件处理模式</span></h3><h4><span id="reactor模式同步的">Reactor模式(同步的)</span></h4><p>读取操作：</p>
<ol>
<li>应用程序注册读就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件的发生</li>
<li>当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器</li>
<li>事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190915131156673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>用<strong>Reactor</strong>模式的一个实现方案是：</p>
<ol>
<li>在<strong>Reactor</strong>中注册好感兴趣的事件(IO事件 信号 定时器)</li>
<li>用一个主线程(IO处理单元)负责监听文件描述符上的是否有事件发生除此之外它不做别的实质性的工作 ,采用<strong>io复用</strong>的形式 比如用select epoll  poll这些.</li>
<li>当发生了对应事件  主线程就通知工作进程 (通过请求队列)</li>
<li>在工作线程(逻辑单元)中读写数据  接受新的连接 处理客户请求等等 </li>
</ol>
<h4><span id="proactor模式-异步">Proactor模式 (异步)</span></h4><p><img src="https://img-blog.csdnimg.cn/20190915142010343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的：</p>
<ul>
<li><strong>Reactor模式</strong>中需要应用程序自己读取或者写入数据，真正执行IO操作的(也就是从内核区读取io数据到缓存区的这一步)是事件处理器自身，也就是说在io操作的第二阶段应用程序是阻塞的，所以我们说<strong>Reactor模式是同步的</strong> </li>
<li><strong>Proactor模式</strong>中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备。</li>
</ul>
<hr>
<h3><span id="io多路复用selectpollepoll同步阻塞">⭐IO多路复用：select/poll/epoll(同步/阻塞)</span></h3><p>所谓 <code>I/O</code> 多路复用指的是这样一个过程：</p>
<ol>
<li>我们拿到了一堆文件描述符 <code>fd</code> (不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)</li>
<li>通过调用<strong>某个函数</strong>告诉内核：“<strong>这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回</strong>”</li>
<li>当调用的这个函数返回后我们就能知道哪些文件描述符可以进行 <code>I/O</code> 操作了。</li>
</ol>
<p>也就是说<strong>通过I/O多路复用我们可以同时处理多路I/O</strong>。</p>
<p><code>select</code> ， <code>poll</code> ，<code>epoll</code> 都是 <code>IO</code> 多路复用的机制。<code>I/O</code> 多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步 <code>I/O</code> 则无需自己负责进行读写，异步 <code>I/O</code> 的实现会负责把数据从内核拷贝到用户空间。</p>
<p><code>I/O</code> 多路复用是指内核一旦发现进程指定的一个或者多个 <code>I/O</code> 条件准备读取，它就通知该进程。<code>I/O</code>多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述字时（一般是<strong>交互式输入</strong>和<strong>网络套接口</strong>），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
</ol>
<p><strong>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</strong></p>
<p><strong>select的几大缺点：</strong></p>
<p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>
<p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>
<p><strong>（3）select支持的文件描述符数量太小了，32位默认是1024，64位是2048</strong></p>
<p> <code>poll</code> 的实现和 <code>select</code> 非常相似，只是描述 <code>fd</code> 集合的方式不同，<code>poll</code> 使用 <code>pollfd</code> 结构而不是 <code>select</code> 的<code>fd_set</code> 结构，其他的都差不多。</p>
<ol>
<li><p><strong>select 时间复杂度O(n)</strong></p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
</li>
<li><p><strong>poll 时间复杂度O(n)</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，但是同样有一个缺点：</p>
<p>1、大量的 <code>fd</code> 的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   </p>
<p>2、<code>poll</code> 还有一个特点是<strong>水平触发</strong>，如果报告 <code>fd</code> 后，没有被处理，那么下次 <code>poll</code> 时会再次报告该 <code>fd</code> 。</p>
</li>
<li><p><strong>epoll 时间复杂度O(1)</strong></p>
<p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，<code>epoll</code> 会把哪个流发生了怎样的I/O事件通知我们。所以我们说 <code>epoll</code> 实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
</li>
</ol>
<h4><span id="select">select</span></h4><p><img src="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png" alt="img"></p>
<p><code>select</code> 调用过程如下：</p>
<ol>
<li>使用 <code>copy_from_user</code> 从用户空间拷贝 <code>fd_set</code> 到内核空间</li>
<li>注册回调函数 <code>__pollwait</code> </li>
<li>遍历所有 <code>fd</code> ，调用其对应的 <code>poll</code> 方法（对于 <code>socket</code> ，这个 <code>poll</code> 方法是 <code>sock_poll</code> ， <code>sock_poll</code> 根据情况会调用到 <code>tcp_poll</code> , <code>udp_poll</code> 或者 <code>datagram_poll</code> ）</li>
<li>以 <code>tcp_poll</code> 为例，其核心实现就是<strong>pollwait，也就是上面注册的回调函数。</strong></li>
<li><code>pollwait</code> 的主要工作就是把 <code>current</code> （当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于 <code>tcp_poll</code> 来说，其等待队列是 <code>sk-&gt;sk_sleep</code> （注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 <code>current</code> 便被唤醒了。</li>
<li><code>poll</code> 方法返回时会返回一个描述读写操作是否就绪的 <code>mask</code> 掩码，根据这个 <code>mask</code> 掩码给 <code>fd_set</code> 赋值。</li>
<li>如果遍历完所有的 <code>fd</code> ，还没有返回一个可读写的 <code>mask</code> 掩码，则会调用 <code>schedule_timeout</code> 是调用 <code>select</code> 的进程（也就是 <code>current</code> ）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（ <code>schedule_timeout</code> 指定），还是没人唤醒，则调用 <code>select</code> 的进程会重新被唤醒获得CPU，进而重新遍历 <code>fd</code> ，判断有没有就绪的 <code>fd</code> 。</li>
<li>把 <code>fd_set</code> 从内核空间拷贝到用户空间。</li>
</ol>
<p><img src="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png" alt="img"></p>
<p> <code>select</code> 函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure>
<p>返回值：就绪描述符的数目，超时返回 <code>0</code> ，出错返回 <code>-1</code> 。</p>
<p>函数参数介绍如下：</p>
<ol>
<li><p>第一个参数 <code>maxfdp1</code> 指定待测试的描述字个数，它的值是待测试的最大描述字加 <code>1</code> （因此把该参数命名为<code>maxfdp1</code> ），描述字 <code>0、1、2...maxfdp1 - 1</code> 均将被测试。因为文件描述符是从 <code>0</code> 开始的。</p>
</li>
<li><p>中间的三个参数 <code>readset</code> 、<code>writeset</code> 和 <code>exceptset</code> 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code> 可以理解为一个集合，这个集合中存放的是<strong>文件描述符FD</strong>，可通过以下四个宏进行设置：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 检查集合中指定的文件描述符是否可以读写</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>timeval *timeout</code> 告知内核等待所指定描述字中的任何一个就绪可花多少时间。其 <code>timeval</code> 结构用于指定这段时间的秒数和微秒数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个参数有三种可能：</p>
<p>（1）永远等待下去：仅在有一个描述字准备好 <code>I/O</code> 时才返回。为此，把该参数设置为空指针 <code>NULL</code> 。</p>
<p>（2）等待一段固定时间：在有一个描述字准备好 <code>I/O</code> 时返回，但是不超过由该参数所指向的 <code>timeval</code> 结构中指定的秒数和微秒数。</p>
<p>（3）根本不等待：检查描述字后立即返回，这称为<strong>轮询</strong>。为此，该参数必须指向一个 <code>timeval</code> 结构，而且其中的定时器值必须为 <code>0</code> 。</p>
<hr>
<h4><span id="poll">poll</span></h4><p><strong>“选举出来，立刻返回”</strong></p>
<p><code>poll</code> 的机制与 <code>select</code> 类似，与 <code>select</code> 在本质上没有多大差别，管理多个描述符也是进行<strong>轮询</strong>，根据描述符的状态进行处理，但是 <code>poll</code> <strong>没有最大文件描述符数量的限制</strong>。<code>poll</code> 和 <code>select</code> 同样存在一个缺点就是，<strong>包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</strong></p>
<p>函数格式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pollfd</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;         	  <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents;        <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>每一个 <code>pollfd</code> 结构体指定了一个<strong>被监视的文件描述符</strong>，可以传递多个结构体，指示 <code>poll()</code> 监视多个文件描述符。每个结构体的 <code>events</code> 域是监视该文件描述符的事件掩码，由用户来设置这个域。<code>revents</code> 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。<code>events</code> 域中请求的任何事件都可能在 <code>revents</code> 域中返回。合法的事件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 　　　　　　　　有数据可读。</span><br><span class="line">POLLRDNORM 　　　　  有普通数据可读。</span><br><span class="line">POLLRDBAND　　　　　 有优先数据可读。</span><br><span class="line">POLLPRI　　　　　　　　 有紧迫数据可读。</span><br><span class="line">POLLOUT　　　　　　      写数据不会导致阻塞。</span><br><span class="line">POLLWRNORM　　　　　  写普通数据不会导致阻塞。</span><br><span class="line">POLLWRBAND　　　　　   写优先数据不会导致阻塞。</span><br><span class="line">POLLMSGSIGPOLL 　　　　消息可用。</span><br></pre></td></tr></table></figure>
<p>此外，<code>revents</code> 域中还可能返回下列事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POLLER　　   指定的文件描述符发生错误。</span><br><span class="line">POLLHUP　　 指定的文件描述符挂起事件。</span><br><span class="line">POLLNVAL　　指定的文件描述符非法。</span><br></pre></td></tr></table></figure>
<p><code>timeout</code> 参数指定等待的毫秒数，无论 <code>I/O</code> 是否准备好，<code>poll</code> 都会返回。<code>timeout</code> 指定为负数值表示无限超时，使 <code>poll()</code> 一直挂起直到一个指定事件发生；<code>timeout</code> 为 <code>0</code> 指示 <code>poll</code> 调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，<code>poll()</code> 就像它的名字那样，一旦选举出来，立即返回。</p>
<p><strong>返回值和错误代码</strong><br>成功时，<code>poll()</code> 返回结构体中 <code>revents</code> 域不为 <code>0</code> 的文件描述符个数；如果在超时前没有任何事件发生，<code>poll()</code> 返回 <code>0</code> ；失败时，<code>poll()</code> 返回 <code>-1</code> ，并设置 <code>errno</code> 为下列值之一。</p>
<hr>
<h4><span id="epoll">epoll</span></h4><p><code>epoll</code> 是在 <code>2.6</code> 内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> <strong>使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的 <code>copy</code> 只需一次。</p>
<p><code>epoll</code> 使用 <code>事件</code> 的就绪通知方式，通过 <code>epoll_ctl</code> 注册 <code>fd</code> ，一旦该 <code>fd</code> 就绪，内核就会采用类似 <code>callback</code> 的回调机制来激活该 <code>fd</code> ，<code>epoll_wait</code> 便可以收到通知。</p>
<h5><span id="epoll-函数">epoll 函数</span></h5><p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>int epoll_create(int size);</strong><br> 创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大。这个参数不同于 <code>select()</code> 中的第一个参数，给出最大监听的 <code>fd+1</code> 的值。需要注意的是，当创建好 <code>epoll</code> 句柄后，它就是会占用一个 <code>fd</code> 值，在 <code>linux</code> 下如果查看 <code>/proc/</code> 进程 <code>id/fd/</code> ，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
</li>
<li><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p>
<p> <code>epoll</code> 的事件注册函数， <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里 <code>epoll</code> 是先注册要监听的事件类型。第一个参数是 <code>epoll_create()</code> 的返回值，第二个参数表示动作，用三个宏来表示</p>
<ul>
<li><strong>EPOLL_CTL_ADD</strong>：注册新的 <code>fd</code> 到 <code>epfd</code> 中；</li>
<li><strong>EPOLL_CTL_MOD</strong>：修改已经注册的 <code>fd</code> 的监听事件；</li>
<li><p><strong>EPOLL_CTL_DEL</strong>：从 <code>epfd</code> 中删除一个 <code>fd</code> ；<br>第三个参数是需要监听的 <code>fd</code> ，第四个参数是告诉内核需要监听什么事，<code>struct epoll_event</code> 结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>events</code> 可以是以下几个宏的集合：<br><strong>EPOLLIN</strong> ：表示对应的文件描述符可以读（包括对端 <code>SOCKET</code> 正常关闭）；<br><strong>EPOLLOUT</strong>：表示对应的文件描述符可以写；<br><strong>EPOLLPRI</strong>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br><strong>EPOLLERR</strong>：表示对应的文件描述符发生错误；<br><strong>EPOLLHUP</strong>：表示对应的文件描述符被挂断；<br><strong>EPOLLET</strong>： 将 <code>EPOLL</code> 设为边缘触发(<strong>Edge Triggered</strong>)模式，这是相对于水平触发(<strong>Level Triggered</strong>)来说的。<br><strong>EPOLLONESHOT</strong>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 <code>socket</code> 的话，需要再次把这个 <code>socket</code> 加入到 <code>EPOLL</code> 队列里。</p>
</li>
</ul>
</li>
<li><p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<p> 等待事件的产生，类似于 <code>select()</code> 调用。参数 <code>events</code> 用来从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code> ，参数 <code>timeout</code> 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
</li>
</ul>
<h5><span id="工作模式">工作模式</span></h5><p><code>epoll</code> 对文件描述符的操作有两种模式：<code>LT（level trigger）</code> 和 <code>ET（edge trigger）</code> 。<code>LT</code> 模式是默认模式，<code>LT</code> 模式与 <code>ET</code> 模式的区别如下：</p>
<ul>
<li><strong>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></li>
<li><strong>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。</strong></li>
</ul>
<p><code>ET</code> 模式在很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 <code>LT</code> 模式高。<code>epoll</code> 工作在 <code>ET</code> 模式的时候，必须使用<strong>非阻塞IO</strong>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p><strong>使用epoll是否需要将socket设置为nonblocking?</strong><br>取决于你使用的触发方式， 如果你使用水平触发(Level-triggered) 那么此时的 <code>epoll</code> 相当于高级的 <code>select</code> ， 你的论述是对的， 是不需要一定将 <code>socket</code> 设置为非阻塞的; 然而， 当你使用边缘触发(Edge-triggered) 那么此时从业务的完整性考虑， 是建议将 <code>socket</code> 设置为 <code>nonbocking</code> 模式， 并且在读写触发 <code>EAGAIN</code> 之后再进行<code>epoll_wait</code> 。</p>
<h5><span id="epoll的优点">epoll的优点：</span></h5><ol>
<li>没有最大并发连接的限制，能打开的 <code>FD</code> 的上限远大于1024（1G的内存上能监听约10万个端口）</li>
<li>效率提升，不是轮询的方式，不会随着 <code>FD</code> 数目的增加效率下降。只有活跃可用的 <code>FD</code> 才会调用 <code>callback</code> 函数。即 <code>Epoll</code> 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>Epoll</code> 的效率就会远远高于 <code>select</code> 和 <code>poll</code> 。</li>
<li>内存拷贝，利用 <code>mmap()</code> 文件映射内存加速与内核空间的消息传递；即 <code>epoll</code> 使用 <code>mmap</code> 减少复制开销。</li>
</ol>
<h5><span id="mmap实现共享内存">mmap实现共享内存：</span></h5><p><code>mmap</code> 将一个文件或者其他对象映射进内存，当文件映射到进程后，就可以直接操作这段虚拟地址进行文件的读写等操作。</p>
<p><code>mmap</code> 系统调用使得进程之间通过<strong>映射同一个普通文件</strong>实现<strong>共享内存</strong>，普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用 <code>read</code> 和 <code>write</code> 等。</p>
<p><img src="https://img-blog.csdn.net/20160202144116303" alt="这里写图片描述"></p>
<h5><span id="边缘触发的io应该怎么写">边缘触发的IO应该怎么写？</span></h5><hr>
<h3><span id="内存管理">内存管理</span></h3><h4><span id="虚拟内存">虚拟内存</span></h4><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p>
<p>虚拟内存的重要意义是它<strong>定义了一个连续的虚拟地址空间</strong>，<strong>让每个进程有一种自己在独享主存的错觉</strong>，并且<strong>把内存扩展到硬盘空间上</strong>。</p>
<p>操作系统可以把进程所使用的地址「<strong>隔离</strong>」开来，即让操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提<strong>每个进程都不能访问物理地址</strong>，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</p>
<p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>
<ul>
<li>程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li>
<li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li>
</ul>
<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的<strong>内存管理单元(MMU)</strong>的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkpVTcOZj4JJSyYlSMyiaC66pP2q1QiafglrtO0tmZHCkBB0RvCsfVOTIA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>操作系统是如何管理虚拟地址与物理地址之间的关系的？</p>
<p>主要是通过<strong>内存分段</strong>和<strong>内存分页</strong>来实现的。</p>
<hr>
<h4><span id="内存分段">内存分段</span></h4><p>程序是由若干个逻辑分段组成的，如可由<strong>代码分段、数据分段、栈段、堆段</strong>组成。<strong>不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</strong></p>
<p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。(类似虚函数表的映射，段表相当于虚函数表)</p>
<ul>
<li><strong>段选择因子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkTX5icicl09hKPabMh2LHcfiapeTumDtOUB3fydDdsIGuNKI0uUWia4k5oA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 <strong>4 个段(分别对应堆、栈、数据区、代码区)</strong>，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk87ABj8vKWeQANrKVHpm7xNZRTbgFPOicpy74mD65ia3rGgMaIo6G1ntQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><strong>分段的优点：能够产生连续的内存空间。</strong></p>
<p><strong>分段的缺点：</strong></p>
<ol>
<li><p><strong>内存碎片</strong>：空闲的内存是零散的碎片</p>
<ol>
<li><p><strong>外部内存碎片</strong>：也就是产生了多个<strong>不连续的小物理内存</strong>，导致新的程序无法被装载</p>
<p>解决方法：<strong>内存交换</strong></p>
<p>在 Linux 系统里，也就是我们常看到的 <code>Swap</code> 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
</li>
<li><p><strong>内部内存碎片</strong>：程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</p>
</li>
</ol>
</li>
<li><p><strong>内存交换的效率低</strong></p>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p>
<p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了<strong>内存分页</strong>。</p>
</li>
</ol>
<hr>
<h4><span id="内存分页">内存分页</span></h4><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个<strong>连续并且尺寸固定的内存空间</strong>，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <strong>4KB</strong>。</p>
<p><strong>虚拟地址与物理地址</strong>之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkZoTKofqkOibHicWGJPwsCjZGRpG077zmMMnRibkVqcVocZz1PxeIuLLMg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元</strong> （<strong>MMU</strong>） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>(跟缺页中断不一样)，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<strong>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</strong></p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的 <code>LRU</code> 等<strong>页面置换算法</strong>计算出的的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，<strong>不再需要一次性都把程序加载到物理内存中</strong>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成<strong>页号和偏移量</strong>；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<blockquote>
<p>简单的分页有什么缺陷吗？</p>
</blockquote>
<p>有空间上的缺陷。因为操作系统是可以同时运行非常多的进程的，这就意味着页表会非常的庞大。比如一个页的大小是 <code>4KB</code>，虚拟地址空间有 <code>4GB</code>，那就需要 <code>100w</code> 个页，每个页表需要 <code>4Byte</code> 来存储，那么就需要 <code>4MB</code> 用来存储页表，<code>100</code> 个进程就是 <code>400MB</code> 。</p>
<h5><span id="多级页表">多级页表</span></h5><p>要解决上面的问题，就需要采用的是一种叫作<strong>多级页表</strong>（Multi-Level Page Table）的解决方案。</p>
<p>首先我们要明确一点，我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以<strong>页表一定要覆盖全部虚拟地址空间</strong></p>
<p>但是在一级页表之中，为了映射到所有的地址，需要 <code>100w</code> 个页表项来覆盖全部虚拟地址空间，而二级页表只需要 <code>1024</code> 个页表项就可以覆盖( <code>此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建</code> )。</p>
<p>如果使用了二级分页，一级页表就可以覆盖整个 <code>4GB</code> 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= <code>0.804M</code>，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p>
<h5><span id="64位系统用到的是四级目录">64位系统用到的是四级目录</span></h5><ul>
<li>全局页目录项 <strong>PGD</strong>（<em>Page Global Directory</em>）；</li>
<li>上层页目录项 <strong>PUD</strong>（<em>Page Upper Directory</em>）；</li>
<li>中间页目录项 <strong>PMD</strong>（<em>Page Middle Directory</em>）；</li>
<li>页表项 <strong>PTE</strong>（<em>Page Table Entry</em>）；</li>
</ul>
<h5><span id="tlbtranslation-lookaside-buffer-页表缓存">TLB(<em>Translation Lookaside Buffer</em>) 页表缓存</span></h5><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p>
<p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 <strong>TLB（<em>Translation Lookaside Buffer</em>）</strong> ，通常称为<strong>页表缓存</strong>、<strong>转址旁路缓存</strong>、<strong>快表</strong>等。它可以跟MMU(内存管理单元)进行交互，MMU可以先在TLB中查找页表，如果没有命中再去找页表里找。</p>
<h5><span id="段页式内存管理">段页式内存管理</span></h5><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>
<ul>
<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制(代码段、数据段、栈段、堆段等等)；</li>
<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>
</ul>
<p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。每一个程序一张段表，每个段又建立一张页表，<strong>段表中的地址是页表的起始地址</strong>，<strong>而页表中的地址则为某页的物理页号</strong>。</p>
<h4><span id="linux内存管理">Linux内存管理</span></h4><p>Linux 系统中的每个段都是从 0 地址开始的整个 <code>4GB</code> 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是<strong>线性地址空间（虚拟地址）</strong>，这种做法相当于屏蔽了处理器中的<strong>逻辑地址</strong>概念，段只被用于访问控制和内存保护。</p>
<p>虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkr9Pf9QeM2EhturaF3WFbL7AFYHJvKexk3As6s2vg1NiaUh5AplRmqyA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ul>
<li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li>
<li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。64位其中16位作为保留位，实际上只有48位能用于内存寻址，即2^48约 <code>256T</code> </li>
</ul>
<p>内核空间与用户空间的区别：</p>
<ul>
<li>进程在用户态时，只能访问用户空间内存；</li>
<li>只有进入内核态后，才可以访问内核空间的内存；</li>
</ul>
<p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>
<h5><span id="用户空间的内存分布">用户空间的内存分布</span></h5><p>用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p>
<ul>
<li><strong>程序文件段.text</strong>，包括二进制可执行代码；</li>
<li><strong>已初始化数据段.data</strong>，包括静态常量；</li>
<li><strong>未初始化数据段.bass</strong>，包括未初始化的静态变量；</li>
<li><strong>堆段</strong>，包括动态分配的内存，从<strong>低地址开始向上增长</strong>；</li>
<li><strong>文件映射段</strong>，包括动态库、共享内存等，<strong>从低地址开始向上增长</strong>（跟硬件和内核版本有关）</li>
<li><strong>栈段</strong>，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；栈内的增长是从<strong>高地址向低地址增长的。</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkLicVe0iaPt3taOrowrLDwibhmGZsic0H8ic1Dv0Z3EMVtk80qzQOOib2CUew/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<hr>
<h4><span id="mmap内存映射原理">mmap内存映射原理：</span></h4><ol>
<li><p>调用用户空间mmap函数在当前进程的连续虚拟地址上来形成映射空间</p>
</li>
<li><p>调用内核空间mmap函数来实现文件物理地址到虚拟地址上的一一映射</p>
</li>
<li><p>进程发起对这片映射空间的访问，引起缺页异常，来实现文件内容到物理内存的拷贝</p>
</li>
</ol>
<p>前两步只是创建映射空间，并没有任何的数据拷贝工作，而在第三步中，通过缓存脏回写的机制，直接跳过了从缓存中拷贝到用户空间的传统读写步骤，缩短了很多时间。</p>
<hr>
<h3><span id="缺页中断page_fault">缺页中断(page_fault)</span></h3><p>在请求分页系统中，可以通过查询<strong>页表中的状态位</strong>来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据<strong>页表中的外存地址在外存中找到所缺的一页</strong>，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<ol>
<li>保护CPU现场</li>
<li>分析中断原因</li>
<li>转入缺页中断处理程序进行处理</li>
<li>恢复CPU现场，继续执行</li>
</ol>
<p>但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在<strong>区别</strong>：</p>
<ol>
<li>在指令执行期间产生和处理缺页中断信号</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
<li>缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令</li>
</ol>
<h4><span id="页面置换算法">页面置换算法</span></h4><p>进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区(<strong>SWAP</strong>)。但此时应该把那个页面换出，则需要根据一定的<strong>页面置换算法</strong>（Page Replacement Algorithm)来确定。</p>
<ul>
<li><strong>最佳置换算法（OPT)</strong></li>
<li><strong>先进先出置换算法（FIFO)</strong></li>
<li><strong>最近最久未使用置换算法（LRU）</strong></li>
</ul>
<hr>
<h3><span id="cpu调度算法进程调度算法">CPU调度算法/进程调度算法</span></h3><p><em>非抢占式调度算法</em></p>
<h5><span id="先到先服务算法fcfs-first-come-first-served">先到先服务算法(FCFS, First-Come First-Served)</span></h5><p>这个算法会用到的属性是进程的<strong>到达时间</strong>，也就是启动运行一个进程的时间。<strong>先启动的进程会优先被调度器选中</strong>。</p>
<p><strong>优点：</strong>这个算法有一个很好的性质，就是<strong>任何进程都不会饥饿</strong>，也就是说算法没有会导致任务进程拒绝服务的内在偏向。</p>
<p><strong>缺点：</strong>但由于上面这个性质，响应时间的方差会很大。举个例子，一个长时间任务到达后，后面跟着一个短时间的任务，那么短任务被长作业挡在后面，它的响应时间就会很糟糕，由于护送效应导致低下的CPU利用率。所以这个<strong>算法并没有对短任务给予任何优先考虑</strong>。</p>
<h5><span id="最短作业优先sjf-shortest-job-first">最短作业优先(SJF, Shortest Job First)</span></h5><p>既然 <code>先到先服务</code> 对短任务不是很友好，那么这个算法就是为了让短作业获得更好的响应时间。</p>
<p><strong>优点</strong>：调度器会优先选择时间较短的任务，让短任务获得更好的响应时间；</p>
<p><strong>缺点</strong>：有可能会让一个长时任务饥饿。解决这个缺点有一个方案，<strong>当一个作业的年龄到达一个阈值，调度器忽略SJF, 选择FCFS算法。</strong></p>
<h5><span id="优先级算法">优先级算法</span></h5><p>出于调度的目的，多数 <code>OS</code> 会给每个进程赋予一个属性——优先级。比如，在 <code>UNIX</code> 系统中，每个用户级进程开始时都有一个固定的默认优先级。<code>Ready Queue</code> 中包含多个子队列，每个队列都对应着一个优先级，每个子队列内部采用 <code>FCFS</code> 算法。</p>
<p><strong>优点</strong>：灵活，可以提供差异化服务</p>
<p><strong>缺点：</strong>会产生饥饿，可以根据进程的等待时间来提高优先级</p>
<h5><span id="高响应比优先调度算法hrrn">高响应比优先调度算法(HRRN)</span></h5><p>高响应比优先调度算法主要用于作业调度，该算法是对先来先服务调度算法和短作业优先调度算法的一种综合平衡，<strong>同时考虑每个作业的等待时间和估计的运行时间</strong>。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
<hr>
<p><em>抢占式调度算法</em></p>
<p>抢占式与非抢占式的区别在于：在一个新进程或刚完成 <code>I/O</code> 的进程进入到 <code>ready queue</code> 中时，会重新评估一些属性（比如剩余执行时间），以决定要不要抢占当前正在运行的进程。原则上说，上面讨论到的任何一个非抢占式算法都能改造成抢占式的，比如 <code>FCFS</code> 算法，每次重新进入就绪队列时，调度器可以决定抢占当前正在执行的进程（如果新任务的到达时间比较早），类似的，<code>SJF</code> 和优先级也一样可以。</p>
<h5><span id="最短剩余时间优先-srtf-shortest-remaining-time-first">最短剩余时间优先 (SRTF, Shortest Remaining Time First)</span></h5><p>调度器会估计每个进程的运行时间，当一个进程回到就绪队列，<strong>调度器计算这个任务的剩余处理时间</strong>，根据计算结果，放入 <code>ready queue</code> 中合适的位置。如果<strong>该进程的剩余时间比当前的进程要少，那么调度器就会抢占当前运行的任务，让这个新任务先执行</strong>。跟 <code>FCFS</code> 算法相比，最短剩余时间的平均等待时间一般比较低。</p>
<h5><span id="rrround-robin调度器">RR(Round Robin)调度器</span></h5><p>按时间片来轮转调度：<strong>分时环境</strong>特别适合使用 <code>RR</code> 调度器，即<strong>每个进程都应该得到处理器时间的一部分</strong>。假设有n个就绪的进程，调度器把 <code>CPU</code> 资源分成一个一个时间片，然后分配给各个进程。就绪队列里每个进程都会得到处理器的时间片 <code>q</code> 。当时间片用完了，当前调度的进程会被放入就绪队列的尾部，形成一个 <code>ring</code> 。但考虑到在不通进程切换会有开销，所以选择时间片 <code>q</code> 的适合要考虑上下文切换。</p>
<h5><span id="多级反馈队列mfq">多级反馈队列(MFQ)：</span></h5><p>进程在不同优先级的队列间迁移，首先调度优先级高的队列中的进程，只有优先级高的队列为空时才去调度优先级低的队列中的进程；对于同一个队列中的进程，按照时间片轮转的方式进行调度，如果N个时间片后依然未能完成，则进入优先级低的队列等待；在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU分配给新到达的作业，即抢占式。</p>
<p><img src="https://img-blog.csdn.net/20170407165752062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzYxNjk0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h3><span id="用户态与内核态">用户态与内核态</span></h3><ul>
<li>内核态与用户态是操作系统的两种运行级别，当程序运行在 <code>R3</code> 级特权级上时，就可以称之为运行在用户态。<strong>因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；</strong></li>
<li>当程序运行在 <code>R0</code> 级特权级上时，就可以称之为运行在内核态。</li>
<li>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。</li>
<li>这两种状态的主要差别是<ul>
<li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其<strong>所处于占有的处理器是可被抢占</strong>的</li>
<li>处于内核态执行时，则<strong>能访问所有的内存空间和对象</strong>，且<strong>所占有的处理器是不允许被抢占的</strong>。</li>
</ul>
</li>
</ul>
<h5><span id="三种情况会导致用户态到内核态的切换">三种情况会导致用户态到内核态的切换</span></h5><ul>
<li><p>系统调用</p>
<p><strong>这是用户态进程主动要求切换到内核态的一种方式</strong>，<strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。</strong>比如前例中fork()实际上就是执行了一个创建新进程的系统调用。常见的系统调用还有 <code>read, write, open, create, close, readv, writev, fork, wait, exit, execve, clone</code> 等等</p>
<p>而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>用户程序通常调用库函数，由库函数再调用系统调用，因此<strong>有的库函数会使用户程序进入内核态</strong>（只要库函数中某处调用了系统调用），有的则不会。</p>
</li>
<li><p>异常</p>
<p>当 <code>CPU</code> 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
<li><p>外围设备的中断</p>
<p><strong>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号</strong>，这时<strong>CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，</strong></p>
<p>如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</li>
</ul>
<hr>
<h2><span id="计算机网络">计算机网络</span></h2><p>z<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcjvgSoF3zeGINoyibX5tpfgfQwBABm2KMEnohSmkRXjzicCuQtt4IWsc9fniahl1mW39gS674icZibqibQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h3><span id="tcpudp运输层">TCP/UDP/运输层</span></h3><h4><span id="udp和tcp的差别">⭐UDP和TCP的差别</span></h4><p><strong>UDP：</strong></p>
<ul>
<li><strong>无连接</strong>：减少了开销和发送前时延；</li>
<li><strong>尽最大努力交付</strong>：不保证可靠交付；</li>
<li><strong>面向报文</strong>：对应用层交下来的报文既不合并，也不拆分，保留这些报文的边界。</li>
<li><strong>没有拥塞控制</strong>：网络拥塞不会使源主机发送速率降低，允许在网络拥塞时丢失一些数据，却不允许数据有太大的时延。</li>
<li><strong>支持一对一、一对多、多对一、多对多的交互通信</strong></li>
<li><strong>首部开销小：</strong> 首部长度只有 <strong>8</strong> 字节，比 TCP 的 <strong>20</strong> 字节短。</li>
</ul>
<p><strong>TCP:</strong></p>
<ul>
<li><strong>面向连接：</strong> 传输前需建立连接，传输完成需释放连接；TCP 连接是一条<strong>逻辑连接</strong>。</li>
<li><strong>点对点：</strong> 每一条 TCP 连接只能有两个端点；</li>
<li><strong>提供可靠交付：</strong> 无差错、不丢失、不重复、不失序；</li>
<li><strong>全双工通信：</strong> 设有发送缓存和接收缓存，允许双方随时发送数据。</li>
<li><strong>面向字节流：</strong> TCP 把应用进程交下来的数据看作<strong>一连串的无结构字节流</strong>；</li>
</ul>
<hr>
<h4><span id="tcpudp数据发送和接收过程">TCP/UDP数据发送和接收过程</span></h4><h5><span id="发送端"><strong>发送端</strong></span></h5><p>数据发送是发送到物理链路层的，从<strong>应用层</strong>开始，经过一层层的数据报文的封装，最终封装成<strong>以太网封装格式</strong> 和 <strong>802.x 封装格式的数据包</strong>，通过有线网络或无线网络在以太网上传输<strong>数据帧</strong>（bit流）。</p>
<h5><span id="接收端"><strong>接收端</strong></span></h5><p><img src="https://krahets.gitee.io/assets/img/1568283339430.91a72ae3.png" alt="1568283339430"></p>
<p>接收端和发送端的顺序刚好相反。即分别经过</p>
<ul>
<li>经过数据链路层去掉<strong>以太网的头部</strong>得到<strong>以太网MAC帧</strong></li>
<li>经过网络层去掉<strong>IP的头部</strong>得到<strong>IP数据包</strong></li>
<li>经过传输层去掉 <code>TCP/UDP</code> 的头部得到<strong>报文段/用户数据报</strong></li>
<li>经过应用层得到数据流</li>
</ul>
<p>就完成了整个的数据传输过程。</p>
<h5><span id="复用与分用">复用与分用</span></h5><p>应用层所有应用进程都可以通过运输层传输到 <code>IP</code> 层，称为<strong>复用</strong>；运输层从 <code>IP</code>  层收到发送给各应用进程的数据后，必须分别交付给指明的各应用进程，称为<strong>分用</strong>。</p>
<hr>
<h4><span id="tcp协议的可靠性体现在哪里">TCP协议的可靠性体现在哪里</span></h4><ol>
<li><strong>应用数据被分割成TCP认为最适合发送的数据块</strong>。(这和UDP完全不同，应用程序产生的数据报长度将保持不变)。</li>
<li><strong>超时重传:</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认,将重发这个报文段。</li>
<li>TCP给发送的每一一个包进行编号 ,接收方对数据包进行排序,把有序数据传送给应用层。（TCP报文段作为IP数据报来传输，IP数据报的大刀可能会失序，因此TCP报文段的到达也可能会失序，如果必要，TCP将对收到的数据进行<strong>重新排序</strong>）。</li>
<li><strong>校验和</strong>: TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错, TCP将丢弃这个报文段和不确认收到此报文段。</li>
<li>IP数据报会发生重复，TCP的接收端会<strong>丢弃重复</strong>的数据。</li>
<li><strong>流量控制:</strong> TCP连接的每一方都有固定大小的缓冲空间 , TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据,能提示发送方降低发送的速率,防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li><strong>拥塞控制</strong>：当网络拥塞时,减少数据的发送。</li>
<li><strong>确认响应</strong>：对于一个收到的请求，将发送一个确认。这个确认通常要延迟几分之一秒。</li>
</ol>
<p>TCP协议保证数据传输可靠性的方式主要有：</p>
<h5><span id="校验和">校验和</span></h5><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。<br><strong>发送方</strong>：在发送数据之前计算检验和，并进行校验和的填充。<br><strong>接收方</strong>：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p>
<p><img src="https://img-blog.csdn.net/20180524102010286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h5><span id="序列号ack和确认应答">序列号(ACK)和确认应答</span></h5><p><code>TCP</code> 传输时将每个字节的数据都进行了编号，这就是序列号。确认应答：<code>TCP</code> 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送 <code>ACK</code> 报文。这个 <code>ACK</code> 报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是 <code>TCP</code> 传输可靠性的保证之一。</p>
<h4><span id="超时重传">超时重传</span></h4><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 <code>ACK</code> 报文，并解析 <code>ACK</code> 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的 <code>ACK</code> 报文，这该怎么办呢？而没有收到 <code>ACK</code> 报文的原因可能是什么呢？</p>
<p>首先，发送方没有介绍到响应的 <code>ACK</code> 报文原因可能有两点：</p>
<ol>
<li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本<strong>没有接收</strong>到。</li>
<li>接收方接收到了响应的数据，但是发送的 <code>ACK</code> 报文响应却由于网络原因<strong>丢包</strong>了。</li>
</ol>
<p>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>。简单理解就是发送方在发送完数据后等待一个时间(<strong>500ms的整数倍</strong>)，时间到达没有接收到 <code>ACK</code> 报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行 <code>ACK</code> 应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送 <code>ACK</code> 应答。</p>
<hr>
<h4><span id="流量控制">流量控制</span></h4><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而<strong>TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制</strong>。在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送 <code>ACK</code> 报文时，将自己的即时窗口大小填入，并跟随 <code>ACK</code> 报文一起发送过去。而发送方根据 <code>ACK</code> 报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p><img src="https://img-blog.csdn.net/20180524111634561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h4><span id="滑动窗口以字节为单位">滑动窗口(以字节为单位)</span></h4><ul>
<li>假定 <code>A</code> 收到来自 <code>B</code> 的确认报文段，其中窗口是 20 字节，确认号是 31 (表明 <code>B</code> 期望收到的下一个序号是 31)。根据这两个数据， <code>A</code> 构造出自己的发送窗口。</li>
</ul>
<p><img src="https://krahets.gitee.io/assets/img/1568790013316.97bfddcb.png" alt="1568790013316"></p>
<ul>
<li><p>发送窗口由<strong>前沿</strong>和<strong>后沿</strong>共同确定。发送窗口通常<strong>不断向前移动</strong>，也有<strong>可能不动</strong>（一是没有收到新的确认；二是收到了新的确认但对方通知窗口缩小了，因此只有后沿缩小，前沿正好不动）。</p>
</li>
<li><p>描述一个发送窗口的状态需要<strong>三个指针</strong>：$P_1,P_2,P_3$，指针指向字节序号。</p>
<ul>
<li>小于 $P_1$ 是已经发送并<strong>收到确认</strong>的部分</li>
<li>$P_1 - P_2​$ 是已经发送但<strong>未收到确认</strong>的部分</li>
<li>$P_2 - P_3$ 是<strong>窗口内允许发送</strong>但<strong>尚未发送</strong>的部分</li>
<li>大于 $P_3​$ 是<strong>窗口外不允许发送</strong>的部分</li>
</ul>
<p><img src="https://krahets.gitee.io/assets/img/1568790430010.9e25f59d.png" alt="1568790430010"></p>
</li>
</ul>
<hr>
<h4><span id="拥塞控制">拥塞控制</span></h4><ul>
<li><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p>
<p><img src="https://krahets.gitee.io/assets/img/1568796886603.87101025.png" alt="1568796886603"></p>
</li>
</ul>
<ul>
<li><p>发送方窗口的上限值应取<strong>接收方窗口 rwnd 和拥塞窗口 cwnd 两个变量中的较小值</strong>：</p>
</li>
<li><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p>
</li>
<li><p>TCP拥塞控制由四个部分组成：<strong>慢开始，拥塞避免，快重传，快恢复</strong></p>
<p><img src="https://krahets.gitee.io/assets/img/1568796161225.0a85de7d.png" alt="1568796161225"></p>
</li>
</ul>
<h5><span id="慢开始"><strong>慢开始</strong></span></h5><ul>
<li>在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做<strong>拥塞窗口(cwnd)</strong>的概念。发送刚开始定义拥塞窗口为 <code>1</code>，在传输的过程中以<strong>2的倍数</strong>指数增大 <code>cwnd</code> 直至其大于 <code>ssthreshold</code> ，之后转为<strong>拥塞避免</strong>，<strong>每次收到ACK应答，拥塞窗口加 1</strong>。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</li>
</ul>
<h5><span id="拥塞避免"><strong>拥塞避免</strong></span></h5><ul>
<li>当出现报文丢失时（既发生重传时），认定网络出现拥塞。将 <code>ssthreshold/=2</code> ，并初始化 <code>cwnd=1</code> 重新开始算法。</li>
</ul>
<h5><span id="快重传"><strong>快重传</strong></span></h5><p>让发送方尽早<strong>知道个别报文段的丢失</strong>，以至于<strong>不需超时重传</strong>。使用快重传可以使整个网络吞吐量提升 20% 。</p>
<ul>
<li><p>快重传要求接收方不要等待自己发送数据时才捎带确认，而是<strong>立即发送确认</strong>；即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。</p>
</li>
<li><p>如下图所示，发送方只要<strong>一连收到 3 个重复确认ACK</strong>，就知道接收方没有收到 <code>M3</code> ，而<strong>立即重传 M3</strong> 。</p>
</li>
</ul>
<p>  <img src="https://krahets.gitee.io/assets/img/1568796172902.50a3f779.png" alt="1568796172902"></p>
<h5><span id="快恢复"><strong>快恢复</strong></span></h5><p>当接收到连续 3 个重复确认时，知道只是丢失了个别报文段，于是不启动慢开始，而是执行快恢复。</p>
<ul>
<li>发送方调整门限值 <strong>ssthresh = cwnd / 2</strong>；同时设置 <strong>cwnd = ssthresh</strong> ，立即进入<strong>拥塞避免</strong>。</li>
<li>这样做的好处是<strong>避免个别丢失的报文段被误认为是网络拥塞造成。</strong></li>
</ul>
<hr>
<h4><span id="tcp-报文段首部格式20byte">TCP 报文段首部格式(20Byte)</span></h4><ul>
<li>TCP 报文段首部前 <code>20</code> 字节固定，后面有 <code>4n</code> 字节可根据需要加选项。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181130165347546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzA4MDI3,size_16,color_FFFFFF,t_70" alt="图片来源于网络"></p>
<ul>
<li><strong>源端口和目的端口：</strong> 各占 <strong>2</strong> 字节；TCP 的分用功能通过端口实现。</li>
<li><strong>序号(seq)：</strong> 占 <strong>4</strong> 字节（序号范围 $[0,2^{32}-1]$）；TCP 传送的<strong>字节流</strong>中每一个字节都<strong>按顺序编号</strong>；序号字段代表本报文段发送数据的<strong>第一个字节的序号</strong>，例如一报文段序号 <code>301</code> ，最后一个字节序号 <code>400</code> ，那么下一个报文段的数据序号应当从 <code>401</code> 开始。</li>
<li><strong>确认号(ACK)</strong>：占 <strong>4</strong> 字节；代表<strong>期望收到对方下一个报文段第一个数据字节的序号</strong>；例如 <code>B</code> 正确收到一个报文段，序号字段是 <code>501</code>，数据长度是 <code>200</code> 字节，则 <code>B</code> 期望收到下一个数据序号是 <code>701</code> ，即将发送给 <code>A</code> 的确认报文段中的确认号置为 <code>701</code> 。若确认号 = <code>N</code>，代表直到序号 <code>N-1</code> 的所有数据都已正确收到。</li>
<li><strong>数据偏移</strong>：占 <strong>4</strong> 字节；指出 TCP 报文段<strong>数据起始处</strong>距离 TCP 报文段起始处的距离；能表示的最大十进制数字为 15，因此数据偏移最大值是 60 字节，也是 TCP 首部的最大长度。</li>
<li><strong>保留：</strong> 占 <strong>6</strong> 位，保留今后使用，应设置为 0；</li>
<li><strong>紧急 URG (urgent)：</strong> 当 <strong>URG = 1</strong> 时，表明紧急指针字段有效。发送方 TCP 把紧急数据插入到本报文段数据的<strong>最前面</strong>。</li>
<li><strong>确认 ACK (acknowledgment)</strong>：仅当 <strong>ACK = 1</strong> 时<strong>确认号</strong>字段有效。TCP 规定，在连接建立后所有传送的报文段应将 <code>ACK</code> 置 1 。</li>
<li><strong>推送 PSH (push)：</strong> 当两个应用进程交互式通信时，一段应用进程希望键入一个命令后立即收到对方响应；推送操作很少使用。</li>
<li><strong>复位 RST (reset)：</strong> <code>RST = 1</code> 代表 TCP 出现严重差错（例如主机崩溃），必须释放连接； <code>RST</code> 还用来拒绝一个非法的报文段或拒绝打开一个连接。</li>
<li><strong>同步 SYN (synchronization)：</strong> 连接建立时用来同步序号。当 <code>SYN = 1</code> 而 <code>ACK = 0</code> 时，表明这是一个<strong>连接请求</strong>报文段。<code>SYN = 1</code> 和 <code>ACK = 1</code> 就表示<strong>连接接受</strong>。</li>
<li><strong>终止 FIN (finish)：</strong> 用来释放一个连接。当 <code>FIN = 1</code> 时，表明发送方数据已经发送完毕，并要求<strong>释放连接</strong>。</li>
<li><strong>窗口：</strong> 占 <strong>2</strong> 字节；指发送本报文段的一方的<strong>接收窗口</strong>（窗口大小是由接收方定的，作为发送方设置其发送窗口的依据）。窗口字段明确指出了现在允许对方发送的数据量。窗口值是动态变化的。</li>
<li><strong>检验和：</strong> 占 <strong>2</strong> 字节；检验范围包括<strong>首部和数据</strong>两部分。计算检验和前需要在 TCP 报文段前面加上 12 字节的伪首部，格式与 UDP 伪首部一样，但应把第 4 个字段中的 17 改为 6 （TCP 协议号为 6 ），把第 5 个字段中 UDP 长度改为 TCP 长度。</li>
<li><strong>紧急指针：</strong>占 <strong>2</strong> 字节；仅在 <code>URG = 1</code> 时才有意义，指出本报文段中紧急数据的字节数（紧急数据后都是普通数据），紧急指针指出了紧急数据的末尾所在报文段中的位置；窗口为 0 时也可发紧急数据。</li>
<li><strong>选项：</strong> 长度可变，<strong>最长 40 字节</strong>。<strong>无选项时， TCP 首部长度为 20 字节。</strong></li>
</ul>
<p>相应的，<code>UDP</code> 的报文段只有<strong>源端口+目的端口+长度+检验和：</strong> 各占 <strong>2</strong> 字节，<strong>首部长度为8字节。</strong></p>
<p><strong>长度字段：</strong>占<code>16</code>比特。标明 <code>UDP</code> 头部和 <code>UDP</code> 数据的总长度字节，<code>UDP</code> 首部的长度为固定的 <code>8</code> 个字节，加上 <code>UDP</code> 数据长度就是长度大小，<code>UDP</code> 数据长度可以通过 <code>wireshark</code> 抓包看到。</p>
<p><img src="https://krahets.gitee.io/assets/img/1568704529477.08a8d8a2.png" alt="1568704529477"></p>
<hr>
<h4><span id="停止等待-arq-协议">停止等待 ARQ 协议</span></h4><hr>
<h4><span id="三次握手四次挥手">三次握手四次挥手</span></h4><h5><span id="三次握手">三次握手</span></h5><ul>
<li><strong>防止已失效的连接请求又传送到服务器端，因而产生错误：</strong>假设 <code>A</code> 发出的第一个连接请求报文段没有丢失，而是在网络某处长时间滞留了，本来这是一个失效的连接请求；但后续 <code>B</code> 收到了它，误认为是 <code>A</code> 的连接请求，就向 <code>A</code> 发出确认报文段。若不采用三报文握手，此时一个已经失效的连接已经被建立，网络资源被白白浪费了。</li>
</ul>
<table>
<thead>
<tr>
<th>握手次数</th>
<th>A 确认</th>
<th>B 确认</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一次</td>
<td></td>
<td>A 发送正常，B 接收正常</td>
</tr>
<tr>
<td>第二次</td>
<td>A 发送正常， B 接收正常；A接收正常，B发送正常</td>
<td></td>
</tr>
<tr>
<td>第三次</td>
<td></td>
<td>A 发送正常， B 接收正常；A接收正常，B发送正常</td>
</tr>
</tbody>
</table>
<p><img src="https://krahets.gitee.io/assets/img/1568797056445.aa1412a3.png" alt="1568797056445"></p>
<h5><span id="四次挥手">四次挥手</span></h5><ol>
<li><code>A</code> 发送 TCP 连接释放报文，进入 <strong>FIN-WAIT-1</strong> 状态，<strong>等待 B 的确认</strong>；</li>
<li><code>B</code> 收到报文段后立即发出确认，并进入 <strong>CLOSE-WAIT</strong> 状态；此时 <code>A</code> 到 <code>B</code> 的单向连接已经被释放， TCP 连接处于<strong>半关闭状态</strong>；<code>B</code> 继续向 <code>A</code> 传输未完成的数据。</li>
<li><code>A</code> 收到 <code>B</code> 的确认后，进入 <strong>FIN-WAIT-2</strong> 状态，<strong>等待 B 的连接释放报文段</strong>；</li>
<li>若 <code>B</code> 已经将所有数据向 <code>A</code> 发送完毕，则向 <code>A</code> 发送 TCP 连接释放报文，并进入 <strong>LAST-ACK</strong> 状态，<strong>等待 A 的确认</strong>；</li>
<li><code>A</code> 收到 <code>B</code> 的连接释放报文段后，立即发出确认，然后进入 <strong>TIME-WAIT</strong> 状态，必须经过时间等待计时器 设置的时间 <strong>2MSL(4 min)</strong> 后，<code>A</code> 才进入 <strong>CLOSED</strong> 状态，这是因为：<ul>
<li><strong>第一：</strong> 由于 <code>A</code> 到 <code>B</code> 的最后的 <code>ACK</code> 确认报文段有可能丢失，<code>B</code> 可能回超时重传释放连接报文段，而 <code>A</code> 就能在 <code>2MSL</code> 时间内收到这个重传的连接释放报文段，并重传确认且重新启动 <code>2MSL</code> 计时器。</li>
<li><strong>第二：</strong> 防止<strong>“已失效的连接请求报文段”</strong>出现在本连接中， <code>A</code> 等待 <code>2MSL</code> 就可以使本链接持续时间内所产生的所有报文段在网络中小时。</li>
</ul>
</li>
</ol>
<p><img src="https://krahets.gitee.io/assets/img/1568797480363.f8ec5647.png" alt="1568797480363"></p>
<p>#### </p>
<hr>
<h4><span id="tcp三次握手如果第三次客户端发出的信息服务器没收到怎么办">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</span></h4><hr>
<h4><span id="什么是socket">什么是Socket</span></h4><p><img src="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><code>Socket</code> 是应用层与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，<code>Socket</code> 其实就是一个门面模式，它把复杂的 <code>TCP/IP</code> 协议族隐藏在 <code>Socket</code> 接口后面，对用户来说，一组简单的接口就是全部，让<code>Socket</code> 去组织数据，以符合指定的协议。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>先从服务器端说起。服务器端先初始化 <code>Socket</code> ，然后与端口绑定( <code>bind</code> )，对端口进行监听( <code>listen</code> )，调用 <code>accept</code> 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 <code>Socket</code> ，然后连接服务器( <code>connect</code> )，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<h5><span id="socket函数">socket函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<strong>socket()</strong>用于创建一个<strong>socket描述符（socket descriptor）</strong>，它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<ul>
<li><strong>domain</strong>：即<strong>协议域</strong>，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li><strong>type</strong>：<strong>指定socket类型</strong>。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li>
<li><strong>protocol</strong>：<strong>指定协议</strong>。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议等等。</li>
</ul>
<h5><span id="bind函数">bind函数</span></h5><p>正如上面所说 <code>bind()</code> 函数把一个地址族中的特定地址赋给 <code>socket</code> 。例如对应 <code>AF_INET</code> 、<code>AF_INET6</code> 就是把一个 <code>ipv4</code> 或 <code>ipv6</code> 地址和端口号组合赋给 <code>socket</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h5><span id="listenconnect函数">listen/connect函数</span></h5><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h5><span id="accept函数">accept函数</span></h5><p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4><span id="readwrite函数">read/write函数</span></h4><p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read()/write()</span><br><span class="line">recv()/send()</span><br><span class="line">readv()/writev()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="socket通信中tcp-udp数据包大小的确定">SOCKET通信中TCP、UDP数据包大小的确定</span></h4><p><code>UDP</code> 和 <code>TCP</code> 协议利用端口号实现多项应用同时发送和接收数据。数据通过源端口发送出去，通过目标端口接收。有的网络应用只能使用预留或注册的静态端口；而另外一些网络应用则可以使用未被注册的动态端口。因为 <code>UDP</code> 和 <code>TCP</code> 报头使用两个字节存放端口号，所以端口号的有效范围是从 <code>0</code> 到 <code>65535</code> 。动态端口的范围是从 <code>1024</code> 到 <code>65535</code> 。</p>
<h5><span id="mtu最大传输单元">MTU最大传输单元</span></h5><ul>
<li>由于以太网最大的数据帧是 <code>1518Bytes</code> ，刨去以太网帧的帧头（DMAC目的MAC地址<strong>6Bytes</strong>+SMAC源MAC地址<strong>6Bytes</strong>+Type域<strong>2bytes</strong>）<strong>14Bytes</strong>和<strong>帧尾CRC校验部分4Bytes</strong> 那么剩下承载上层协议的地方也就是Data域最大就只能有<strong>1500Bytes</strong>这个值我们就把它称之为<strong>MTU</strong>。</li>
<li>数据链路层规定了<strong>数据帧中数据字段的最大长度 MTU</strong> ，最常用的以太网规定 <strong>MTU = 1500</strong> 字节，若长度超过 <code>MTU</code> 值，就必须把数据报分片处理。</li>
<li>虽然尽可能长的 <code>IP</code> 数据报会使传输效率变高（首部长度占比小），但数据报短路由器转发速度也更快。</li>
</ul>
<p>因此：</p>
<p><strong>UDP</strong> 包的大小就应该是 <strong>1500 - IP头(20) - UDP头(8) = 1472(BYTES)</strong><br><strong>TCP</strong> 包的大小就应该是 <strong>1500 - IP头(20) - TCP头(20) = 1460 (BYTES)</strong></p>
<p>在用 <code>Socket</code> 编程时， <code>UDP</code>协议要求包小于 <code>64K</code> ，<code>TCP</code>没有限定。</p>
<p>不过鉴于Internet上的<strong>标准MTU</strong>值为<strong>576字节</strong>，所以建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在<strong>548字节 (576-8-20)</strong>以内。</p>
<hr>
<h3><span id="ip网络层">IP/网络层</span></h3><h4><span id="地址解析协议-arp">地址解析协议 ARP</span></h4><h5><span id="计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</span></h5><p><img src="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png" alt="1568551356084"></p>
<ul>
<li><strong>APR 协议作用：</strong> 已经知道一个机器的 <strong>IP 地址</strong>，需要找出对应的<strong>硬件地址</strong>。<ul>
<li><strong>RARP 协议</strong>：现在的 <code>DHCP</code> 协议包含逆地址解析协议功能，即从<strong>硬件地址</strong>找出其 <strong>IP 地址</strong>。</li>
</ul>
</li>
<li><strong>ARP 协议工作原理：</strong> 网络层使用 <code>IP</code> 地址，但实际网络链路上传送数据帧时，最终必须使用该网络的硬件地址( <code>MAC</code> )。<code>ARP</code> 解决方法是在<strong>主机 ARP 高速缓存</strong> 中存放一个从 <code>IP</code> 地址到硬件地址的映射表，并实时动态更新（新增或超时删除）。<ul>
<li>当主机 A 要向主机 B 发送 <code>IP</code> 数据报时，就在其 <code>ARP</code> 高速缓存中查看有无主机 B 的 <code>IP</code> 地址，如有就查找并<strong>写入 MAC 帧</strong>，并传输。</li>
<li>有可能查不到主机 B 的 <code>IP</code> 地址，可能主机 B 刚入网，可能主机 A 刚加电（高速缓存为空）。在这种情况下，主机 A 就自动运行 <code>ARP</code>，通过广播请求分组找出主机 B 的硬件地址。</li>
</ul>
</li>
<li><strong>ARP 协议工作流程：</strong><ol>
<li>主机 A 在本局域网上发送一个 <code>ARP</code> 请求分组，在本局域网上所有主机上运行的 <code>ARP</code> 进程都收到此请求分组。</li>
<li>主机 B 收下这个 <code>ARP</code> 请求，并向主机 A 发送响应分组（普通的单播，发送给主机 A ）。同时，把请求分组里 A 的 <code>IP</code> 地址到硬件地址的映射写入主机 B 的 <code>ARP</code> 高速缓存中。</li>
<li>主机 A 收到主机 B 的响应分组后，就在 <code>ARP</code> 高速缓存中写入主机 B 的 <code>IP</code> 地址到硬件地址的映射。</li>
</ol>
</li>
<li><strong>ARP生存时间：</strong> 超过生存时间（例如 10 ~ 20 分钟）的项目从高速缓存中删掉。这样如果 B 更换了设备， A 无法找到原主机 B ，但过了一段时间， A 的 <code>ARP</code> 高速缓存中已经删除了 B 原先硬件地址，于是 A 重新广播发送 <code>ARP</code> 请求分组，找到新的 B 硬件地址。</li>
</ul>
<hr>
<h4><span id="icmpigmp">ICMP/IGMP</span></h4><p><img src="https://krahets.gitee.io/assets/img/1568288257688.197541c0.png" alt="1568288257688"></p>
<h5><span id="网际控制报文协议-icmp">网际控制报文协议 <strong>ICMP</strong></span></h5><ul>
<li><h4><span id="icmp-报文种类">ICMP 报文种类</span></h4><ul>
<li><p><strong>ICMP 差错报告报文和 ICMP 询问报文</strong></p>
<p><img src="https://krahets.gitee.io/assets/img/1568635687315.e67e9b59.png" alt="1568635687315"></p>
</li>
</ul>
</li>
<li><p><strong>ICMP应用：</strong></p>
<ul>
<li><strong>分组网间探测 PING (Packet Internet Groper)</strong>：使用了 <strong>ICMP</strong> 的回送请求和回送回答报文。</li>
</ul>
</li>
</ul>
<h5><span id="网际组管理协议-igmp">网际组管理协议 <strong>IGMP</strong></span></h5><h4><span id="ip-数据报的格式">IP 数据报的格式</span></h4><p><img src="https://img-blog.csdn.net/20150730120353079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h5><span id="首部固定字段">首部固定字段</span></h5><ol>
<li><strong>版本：</strong> 占 4 位；指 IP 协议版本。通信双方使用的 IP 协议版本需一致。</li>
<li><strong>首部长度：</strong> 占 4 位；单位是 32 位字（4 字节）。</li>
<li><strong>区分服务：</strong> 占 8 位；只有在使用区分服务时才使用，一般情况不使用。</li>
<li><strong>总长度：</strong> 占 16 位；指首部和数据长度之和；单位为字节，因此数据报最大长度为 $2^{16}-1=65536$字节<ul>
<li>数据链路层规定了<strong>数据帧中数据字段的最大长度 MTU</strong> ，最常用的以太网规定 MTU = 1500 字节，若长度超过 MTU 值，就必须把数据报分片处理。</li>
<li>虽然尽可能长的 IP 数据报会使传输效率变高（首部长度占比小），但数据报短路由器转发速度也更快。</li>
</ul>
</li>
<li><strong>标识</strong>：占 16 位。 每产生一个 IP 数据报，计数器 +1。<ul>
<li>这个标识并不是序号（网络层不负责按序接收）；</li>
<li>在由于长度超过 MTU 而被分片时，标识字段值被复制到所有分片的标识字段，使各数据报片最后能正确地组装成原来的数据报。</li>
</ul>
</li>
<li><strong>标志</strong>：占 3 位，目前仅前 2 位有意义。<ul>
<li>最低位记为 MF (More Fragment) ，MF = 1 表示后面“还有分片”数据报，MF = 0 表示这是若干数据报片中的最后一个。</li>
<li>中间一位记为 DF (Don’t Fragment) ， DF = 1 表示不能分片，DF = 0 才允许分片。</li>
</ul>
</li>
<li><strong>片偏移：</strong> 占 13 位；表示数据报在分片后，某片在原分组中的相对位置；单位是 8 字节。<ul>
<li>每个分片的长度一定是 8 字节（64 位）的整数倍。</li>
</ul>
</li>
<li><strong>生存时间（TTL）</strong>：占 8 位；表示数据报在网络中的寿命。防止数据报在互联网中无限制兜圈子。<ul>
<li>最初设计 TTL 以秒为单位，消耗时间小于 1s 则将 TTL 减 1 。</li>
<li>目前路由器处理数据报时间一般远远小于 1s ，后来 TTL 字段功能改为<strong>“跳数限制”</strong>，路由器每次转发数据之前把 TTL 减 1 ，当 TTL = 0 就丢失这个数据报。</li>
<li>数据报能在互联网中经过路由器的最大数值是 $255=(2^8 - 1)$。若设置 TTL = 1 ，则表示此数据报只能在本局域网中传送。</li>
</ul>
</li>
<li><strong>协议：</strong> 占 8 位；表示此数据报中携带的数据使用何种协议，以便接收方主机 IP 层直到应将数据上交给哪个协议处理。</li>
<li><strong>首部校验和：</strong> 占 16 位；只检验数据报的首部，不包括数据部分（减少计算量）。</li>
<li><strong>源地址：</strong> 占 32 位；</li>
<li><strong>目的地址：</strong> 占 32 位。</li>
</ol>
<h5><span id="首部可变部分">首部可变部分</span></h5><ul>
<li>IP 数据报首部的可变部分就是一个<strong>选项字段</strong>，用来支持<strong>排错、测量、安全措施</strong>等。</li>
<li>长度 <strong>1 - 40</strong> 字节，取决于选择的项目。</li>
<li>可变部分是用来增加 IP 数据报的功能，实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 <strong>IPv6 就将 IP 数据报的首部长度做成固定的</strong>。</li>
</ul>
<hr>
<h3><span id="http">HTTP</span></h3><h4><span id="http状态码">HTTP状态码</span></h4><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p><strong>HTTP状态码列表:</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/" target="_blank" rel="noopener">客户端</a>应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
<hr>
<h4><span id="https的通信过程">⭐HTTPS的通信过程</span></h4><p><code>HTTPS</code> 是一种通过计算机网络进行安全通信的传输协议。<code>HTTPS</code> 经由 <code>HTTP</code> 进行通信，但利用 <strong>SSL/TLS</strong> 来加密数据包。 <code>HTTPS</code> 的通信过程，充分利用了各种加密算法及其特性。<code>HTTPS</code> 只是在原有的协议接口替换成了<strong>SSL(Secure Socket Layer)</strong>和<strong>TLS(Transport Layer Security)</strong>协议</p>
<p><img src="https://img2018.cnblogs.com/blog/1627759/201906/1627759-20190615112708629-638195014.jpg" alt="img"></p>
<ol>
<li><p>客户端或者浏览器向服务器发送 <code>https</code> 请求</p>
</li>
<li><p>服务器将数字证书(公钥+数字签名)返回给客户端</p>
</li>
<li><p>浏览器接收到服务器公钥</p>
<p>浏览器收到公钥后会对公钥进行一系列的验证，如：颁发机构，过期时间等等。认证失败会有警告，成功的话，<strong>会生成一个随机的对阵密钥作为对称加密的密钥，用服务器返回的公钥对这个随机密钥进行加密</strong></p>
</li>
<li><p>加密后的随机密钥发送到服务器</p>
<p>服务器收到公钥加密后的随机密钥，会拿自己的私钥去解，解开之后得到随机密钥</p>
</li>
<li><p>客户端与服务器进行加密通信</p>
<p>客户端和服务器端信息数据通信，以这个随机密钥进行对称加密。</p>
</li>
</ol>
<h5><span id="非对称加密算法对称加密算法">非对称加密算法+对称加密算法</span></h5><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>非对称加密算法，它有两个密钥：一个是公钥，可以明文传输的。一个是私钥，由发送放保存，其它人都不知道。非对称加密算法的加密和解密算法不同。通过公钥加密的信息只有用私钥才能解开。</p>
<p>主要是由于非对称加密算法运算量大，用非对称加密算法进行通信，其加解密过程特别慢。因此可以第一次用非对称加密算法传递对称加密算法的密钥，后续通信就用对称加密算法。除了第一次用非对称加密算法加解密密钥的时候比较慢外，其它时间都不会慢了。而且也可以保证对称加密算法密钥的安全性。这样可以充分利用非对称加密算法和对称加密算法的各自特点。</p>
<h5><span id="数字证书防止中间人攻击">数字证书—防止中间人攻击</span></h5><p>为了防止在通信过程中有中间人截获两端的非对称密钥，导致两端收到的公钥都是中间人的，可以获取两端的信息然后中转。找个可靠的人做公证人，两端各自把公钥交给他。由他颁布一个证书，证书包含公钥以及两端的身份信息，来证明两端各自的身份。但是这个证书也可以在传递过程中被篡改。</p>
<h5><span id="数字摘要算法">数字摘要算法</span></h5><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p>
<p>为了解决数字证书中中间人攻击的问题，可以让公证人用<strong>数字摘要算法</strong>，把<strong>公钥和身份信息</strong>生成一个摘要。同时用非对称加密算法把对摘要进行加密，生成数字签名。然后把【公钥和身份信息+数字签名】合并，形成数字证书。在获得数字证书的时候，就可以用公钥进行解密生成摘要信息，再用数字摘要算法对公钥和身份信息生成摘要信息，两者比对，如果能匹配，就说明没有被篡改 。</p>
<p>数字证书通常来说是由受信任的数字证书颁发机构<strong>CA</strong>，在验证服务器身份后颁发。</p>
<h5><span id="证书内置">证书内置</span></h5><p>为了防止公证人公钥传输过程也会出现中间人攻击问题，可以把公证人公钥预先加载在操作系统中。微软等公司会根据一些权威安全机构的评估选取一些信誉很好并且通过一定的安全认证的证书发布机构，把这些证书发布机构的证书默认安装在操作系统中，并且设置为操作系统信任的数字证书。</p>
<hr>
<h4><span id="getpost-区别">get/post 区别</span></h4><ul>
<li><code>GET</code> 用于信息获取，是<strong>安全</strong>和<strong>幂等</strong>的，安全代表其不会增删改服务器上的内容，幂等代表多次相同操作返回相同；</li>
<li><code>POST</code> 请求可能修改服务器上资源；</li>
<li><code>GET</code> 请求数据附在 <code>URL</code> 后面，而 <code>POST</code> 在 <code>HTTP</code> 包体内；</li>
<li><code>POST</code> 安全性比 <code>GET</code> 高。</li>
</ul>
<hr>
<h4><span id="httphttps-09-10-11-20-30的特点和区别">http/https 0.9、1.0、1.1、2.0、3.0的特点和区别</span></h4><h5><span id="http09">Http0.9</span></h5><ul>
<li><strong>请求方法支持有限</strong><br>只支持 <code>GET</code> 请求方式，不支持其他请求方式，因此客户端向服务端传输信息的量非常有限，也就是现在常用的 <code>Post</code> 请求无法使用</li>
<li><strong>不支持请求头header</strong><br>不能在请求中指定版本号，服务端只具有返回 <code>HTML</code> 字符串的能力</li>
<li><strong>响应即关闭</strong><br>服务端相响应之后，立即关闭 <code>TCP</code> 连接</li>
</ul>
<hr>
<h5><span id="http10">Http1.0</span></h5><p>1.0版本主要是对0.9版本的强化，效果也比较明显，主要特性和缺点包括：</p>
<ul>
<li><strong>丰富请求方法</strong><br>请求方式新增了 <code>POST</code> ，<code>DELETE</code> ，<code>PUT</code> ，<code>HEADER</code> 等方式，提高了客户端向服务端发送信息的量级</li>
<li><strong>增加请求头和响应头</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，可以在通信中指定了 <code>HTTP</code> 协议版本号，以及其他 <code>header</code> 信息，使得C/S交互更加灵活方便</li>
<li><strong>丰富数据传输内容</strong><br>扩充了传输内容格式包括：<strong>图片、音视频资源、二进制</strong>等都可以进行传输，相比0.9的只能传输 <code>html</code> 内容让<code>http</code> 的应用场景更多。</li>
</ul>
<p><strong>缺点如下：</strong></p>
<ul>
<li><strong>链接复用性差</strong><br>1.0版本中<strong>每个TCP连接只能发送一个请求</strong>，<strong>数据发送完毕连接就关闭</strong>，如果还要请求其他资源，就必须重新建立连接。TCP为了保证正确性和可靠性需要客户端和服务器三次握手和四次挥手，因此建立连接成本很高，基于拥塞控制开始时发送速率较慢，所以1.0版本的<strong>性能并不理想</strong>。</li>
<li><strong>无状态无连接的弊端</strong><br>1.0版本是<strong>无状态且无连接</strong>的，换句话说就是服务器不跟踪不记录请求过的状态，客户端<strong>每次请求都需要建立tcp连接不能复用</strong>，并且1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞后面的请求就会被阻塞。 <strong>丢包和乱序问题</strong>和高成本的链接过程让复用和<strong>队头阻塞</strong>产生很多问题，所以<strong>无连接无状态</strong>是1.0版本的一个<strong>弱肋</strong>。</li>
</ul>
<h5><span id="http11">Http1.1</span></h5><p>1.1版本在1.0版本发布后大约1年就推出了，是<strong>对1.0版本的优化和完善</strong>，1.1版本的主要特点包括：</p>
<ul>
<li><strong>增加长连接</strong><br>新增 <code>Connection</code> 字段，可以设置 <code>keep-alive</code> 值保持连接不断开，即 <code>TCP</code> 连接默认不关闭，可以被多个请求<strong>复用</strong>，这也是1.1版本很重要的优化，在请求首部字段中提出keepalive之后，只要任意一段没有明确提出断开连接，tcp就一直会保持连接状态。但是在S端服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着，仍然存在队头阻塞问题。</li>
<li><strong>管道化</strong><br>在长连接的基础上，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回，即在<strong>同一个TCP连接中，客户端可以同时发送多个请求</strong>，进一步改进了HTTP协议的传输效率。</li>
<li><strong>更多的请求方法</strong><br>增加了 <code>PUT</code>、 <code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code> 等请求方式。</li>
<li><strong>host字段</strong><br><code>Host</code> 字段用来指定服务器的域名，这样就可以将多种请求发往同一台服务器上的不同网站，提高了机器的复用，这个也是重要的优化</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>仍然存在着<strong>队首阻塞</strong>的问题。也就是虽然请求可以同时发送了，但是要是前面的回应特别慢，后面就会有许多请求排队等着，仍然存在队头阻塞问题。</li>
</ul>
<hr>
<h5><span id="http20">Http2.0</span></h5><p><strong>HTTP2.0多路复用+TLS安全加密+TCP拥塞控制</strong></p>
<p>2.0版本是个里程碑式的版本，相比1.x版本有了非常多的优化去适应当前的网络场景，其中几个重要功能点包括：</p>
<ul>
<li><p><strong>二进制格式</strong><br><code>1.x</code> 是文本协议，然而2.0是<strong>以二进制帧为基本单位</strong>，可以说是一个二进制协议，将所有传输的信息分割为<strong>消息和帧</strong>，并采用二进制格式的编码，一帧中包含数据和标识符，使得网络传输变得高效而灵活。</p>
<ul>
<li>二进制分帧层<strong>binary framing layer</strong>在不修改请求方法和语义的基础上，重新设计了<strong>编码机制</strong>。二进制编码机制使得通信可以在<strong>单个TCP连接</strong>上进行，该连接在整个对话期间一直处于活跃状态。<ul>
<li><strong>链接Link</strong><br>就是指一条C/S之间的TCP链接，这是个基础的链路数据的高速公路</li>
<li><strong>数据流Stream</strong><br>已建立的TCP连接内的双向字节流，TCP链接中可以承载一条或多条消息</li>
<li><strong>消息Message</strong><br>消息属于一个数据流，消息就是逻辑请求或响应消息对应的完整的一系列帧，也就是帧组成了消息</li>
<li><strong>帧Frame</strong><br>帧是通信的最小单位，每个帧都包含帧头和消息体，标识出当前帧所属的数据流</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>多路复用</strong><br>这是一个非常重要的改进，1.x中建立多个连接的消耗以及效率都存在问题，2.0版本的多路复用<strong>多个请求共用一个连接，多个请求可以同时在一个TCP连接上并发，主要借助于二进制帧中的标识进行区分实现链路的复用。</strong></p>
<ul>
<li><p>客户端和服务器将交互数据分解为<strong>相互独立的帧</strong>，互不影响地<strong>交错传输</strong>，最后再在对端根据<strong>帧头中的流标识符</strong>把它们<strong>重新组装</strong>起来，从而实现了TCP链接的多路复用。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5YING7tophKDYrYreRzSvGN0BlJ6LibtW2mK4QTTckvpm3408gax7XUg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
</li>
</ul>
</li>
<li><p><strong>头部压缩</strong><br>2.0版本使用使用<strong>HPACK算法</strong>对头部 <code>header</code> 数据进行压缩，从而减少请求的大小提高效率，这个非常好理解，之前每次发送都要带相同的 <code>header</code> ，显得很冗余，<code>2.0</code> 版本对头部信息进行增量更新有效减少了头部数据的传输。</p>
<ul>
<li><p>2.0版本中HPACK算法在C/S中使用<strong>首部表</strong>来存储之前发送的键值对，对于相同的数据通信期间几乎不会改变的通用键值对只需发送一次即可。</p>
</li>
<li><p>极端情况如果请求头每次没有变化，那么传输中则不包含首部，也就是首部开销就是<strong>零字节</strong>。如果首部键值对发生变化了，也<strong>只需要发送变化的数据</strong>，并且将<strong>新增或修改的首部帧会被追加到首部表</strong>，首部表在链接存活期始终存在, 并且由客户端和服务器<strong>共同更新和维护</strong>。</p>
</li>
<li><p>简单说就是客户端和服务端共同维护了一个<strong>key-value</strong>的结构，发生变化时则更新传输，否则就不传输，这样相当于<strong>首次全量传输之后增量更新传输</strong>即可，这个思想在日常开发中也非常普遍，不用想的太复杂。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5hTnk3S5XJBVElZdWeB6U8lrMlyY9iaPZFj7WKE1OeSw3E3TNUj9Nz3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
</li>
</ul>
</li>
<li><p><strong>服务端推送</strong><br>这个功能有点意思，之前 <code>1.x</code> 版本服务端都是收到请求后被动执行，在2.0版本允许服务器主动向客户端发送资源，这样在客户端可以起到加速的作用。</p>
<ul>
<li>在实际的C/S交互中这种<strong>主动推送额外资源</strong>的方法很有效，因为几乎每个网络应用都会包含多种资源，客户端需要全部逐个获取它们，此时如果让服务器提前推送这些资源，从而可以<strong>有效减少额外的延迟时**</strong>间**，因为服务器可以知道客户端下一步要请求什么资源。</li>
</ul>
</li>
<li><p><strong>HTTP2.0存在的不足(主要是TCP的问题)</strong></p>
<ul>
<li>建立连接时间长</li>
<li>队头阻塞问题(HTTP2.0协议的<strong>多路复用机制</strong>解决了HTTP层的队头阻塞问题，但是在<strong>TCP层仍然存在队头阻塞问题</strong>。TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，<strong>如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用</strong>。)</li>
<li>移动互联网领域表现不佳(弱网环境)</li>
</ul>
</li>
</ul>
<hr>
<h5><span id="http30">Http3.0</span></h5><p>HTTP3.0又称为<strong>HTTP Over QUIC</strong>，其<strong>弃用TCP协议</strong>，改为使用<strong>基于UDP协议</strong>的QUIC协议来实现。</p>
<ul>
<li><strong>QUIC</strong>协议(<strong>Quick UDP Internet Connections</strong>)</li>
</ul>
<blockquote>
<p>QUIC提高了当前正在使用TCP的面向连接的Web应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。</p>
</blockquote>
<blockquote>
<p>QUIC的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
</blockquote>
<ul>
<li><strong>基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商</strong>，完成之后才可以真正传输业务数据。但是QUIC则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</li>
<li><strong>使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。首次连接之后传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互。</strong></li>
<li>QUIC协议基于UDP实现摒弃了五元组(SIP+SPort+DIP+DPort+协议号)的概念，使用64位的随机数作为连接的ID，并使用该ID表示连接。基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</li>
<li>QUIC协议的核心思想是将TCP协议在内核实现的诸如可靠传输、流量控制、拥塞控制等功能转移到用户态来实现，同时在加密传输方向的尝试也推动了TLS1.3的发展。</li>
</ul>
<hr>
<h4><span id="http的无状态性">HTTP的无状态性</span></h4><p><code>http</code> 是一种无状态协议，即<strong>不会保存请求和响应之间的通信状态</strong>。好处是<strong>可以加快处理速度，确保协议的可伸缩性</strong>。<code>http</code> 最初的设计是无状态的(stateless)，但是无状态的 <code>http</code> 无法满足互联网日益发展的需求，于是业界扩展了 <code>http</code> 协议，增加了有状态(stateful)协议头，使之变成一个有状态协议。</p>
<p>两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</p>
<h5><span id="cookie">Cookie</span></h5><p>由于HTTP是一种无状态的协议，服务器<strong>单纯从网络连接上</strong>无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p>Cookie实际上是<strong>一小段的文本信息</strong>。客户端请求服务器，如果服务器需要记录该用户状态，就使用 <code>response</code> 向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，<strong>浏览器把请求的网址连同该Cookie一同提交给服务器</strong>。<strong>服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</strong></p>
<p> <em>Cookie具有不可跨域名性</em></p>
<p> 很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p>
<p>答案是否定的。Cookie具有<strong>不可跨域名性</strong>。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p>
<p><strong>Cookie在客户端是由浏览器来管理的</strong>。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。</p>
<h5><span id="session">Session</span></h5><p>由于网页是一种无状态的连接程序，因此无法得知用户的浏览状态。在网上购物的时，把很多商品加入了购物车，而在结账时网站却不知道你购物车有哪些物品。为了解决这个问题，服务器端就为特定用户创建了特定的<code>session</code> ，用于标示并跟踪这个用户，这样才知道购物车里有哪些商品。</p>
<ul>
<li><code>Session</code> 是另一种<strong>记录客户状态的机制</strong>，不同的是 <code>Cookie</code> 保存在客户端浏览器中，而 <code>Session</code> 保存在服务器上。</li>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 <code>Session</code> 。客户端浏览器再次访问时只需要从该 <code>Session</code> 中查找该客户的状态就可以了。</li>
<li>如果说 <code>Cookie</code> 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 <code>Session</code> 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</li>
<li><code>Session</code> 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</li>
</ul>
<h5><span id="session和cookie的关系">Session和Cookie的关系</span></h5><ul>
<li><ul>
<li><code>cookie</code> 是一个实际存在的、具体的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段。</li>
<li><code>session</code> 是一个抽象概念、开发者为了实现中断和继续等操作，将 <code>client</code> 和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念。</li>
<li>即 <code>session</code> 描述的是一种通讯会话机制，而 <code>cookie</code> 只是目前实现这种机制的主流方案里面的一个参与者，它一般是用于保存<strong>session ID</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4><span id="http请求种类">HTTP请求种类</span></h4><ol>
<li><strong>get：</strong>获取资源(多媒体，程序执行结果)</li>
<li><strong>post：</strong>传输实体主体，相比于 <code>get</code> 传输，<code>post</code> 请求的数据会放置在内容实体中而不是 <code>uri(Universal Resource Identifier)</code> 之后，安全性大大增强</li>
<li><strong>put：</strong>传输文件，由于 <code>http1.1</code> 本身不自带验证机制，所以安全性欠佳。一般 <code>web</code> 不使用此方法</li>
<li><strong>head：</strong>获得报文首部，与 <code>get</code> 一样，只是不获取报文主体，用来验证 <code>uri</code> 的有效性</li>
<li><strong>delete：</strong>删除文件 类似 <code>put</code> </li>
<li><strong>options：</strong>询问支持的方法</li>
<li><strong>trace：</strong>追踪路径，让 <code>web</code> 服务器端将之前的请求通信环回给客户端，用来确认连接过程中，代理中转的加工/篡改。</li>
<li><strong>connect：</strong>要求用隧道协议连接代理，主要使用 <code>ssl</code> 和 <code>tsl</code> 把通信内容加密后经网络隧道传输</li>
</ol>
<hr>
<h4><span id="从浏览器输入url到出现页面经过了哪些阶段">从浏览器输入URL到出现页面经过了哪些阶段</span></h4><p><strong>输入网址</strong>：</p>
<p>URL的形式： <code>schema://host:port/path?query#fragment</code></p>
<p>　　<code>-schema</code> : 协议，例如 <code>http</code> , <code>https</code> ,  <code>ftp</code> 等</p>
<p>　　<code>-host</code> : 域名或者 <code>ip</code> 地址</p>
<p>　　<code>-port</code> ： 端口，<code>http</code> 默认端口 <code>80</code> ，可以省略</p>
<p>　　<code>-path</code> ： 路径，例如 <code>/abc</code>   <code>/a/b/c</code> </p>
<p>　　<code>-query</code> : 查询参数，例如 <code>token=sdfs2223fds2&amp;name=sdffaf</code></p>
<p>　　<code>-fragment</code> : 锚点（哈希 <code>Hash</code> ），用于定位页面的某个位置。</p>
<p>符合规则的URL</p>
<p>　　<a href="http://www.baidu.com/java/web?flag=1#function" target="_blank" rel="noopener">http://www.baidu.com/java/web?flag=1#function</a></p>
<p><strong>缓存解析</strong></p>
<p>浏览器获取了这个 <code>url</code> ，它先去缓存当中看看有没有，依次从浏览器缓存-&gt;系统缓存-&gt;路由器缓存当中查看，如果有从缓存当中显示页面，这样是不需要发送 <code>http</code> 请求的。如果没有那就进行步骤3。<br>缓存就是把之前访问的web资源，比如一些js，css，图片什么的保存在本机的内存或者磁盘当中。</p>
<p><strong>域名解析</strong></p>
<p>当缓存中没有这个 <code>url</code> 的时候，就需要发送 <code>http</code> 请求了，那么在发送 <code>http</code> 请求之前，需要先进行<strong>DNS解析</strong>将域名解析成 <code>ip</code> 地址。<strong>DNS解析</strong>存在着多级缓存：</p>
<ul>
<li>浏览器的 <code>DNS</code> 缓存</li>
<li>系统的 <code>DNS</code> 缓存</li>
<li>路由器的 <code>DNS</code> 缓存</li>
<li>网络运营商的 <code>DNS</code> 缓存（中国移动，中国电信）</li>
<li><p>上述都没有找到，则会采取递归+迭代查询的方式</p>
<ul>
<li>主机先向<strong>本地域名服务器</strong>进行递归查询</li>
<li>本地域名服务器采用迭代查询，向一个根域名服务器进行查询</li>
<li>根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的 <code>IP</code> 地址</li>
<li>本地域名服务器向顶级域名服务器进行查询</li>
<li>顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的 <code>IP</code> 地址</li>
<li>本地域名服务器向权限服务器进行查询</li>
<li>权限服务器告诉本地域名服务器所查询的主机的 <code>IP</code> 地址</li>
<li>本地域名服务器最后把查询结果告诉主机</li>
</ul>
</li>
<li><p><strong>递归查询</strong>：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以 <code>DNS</code> 客户机的身份向其它域名服务器查询，直到得到最终的 <code>IP</code> 地址告诉本机</p>
</li>
<li><strong>迭代查询</strong>：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</li>
</ul>
<p><strong>DNS优化</strong></p>
<ul>
<li><strong>DNS缓存</strong><br>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li>
<li><strong>DNS负载均衡</strong><br>DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，</li>
</ul>
<p><strong>tcp链接，三次握手</strong></p>
<p>在域名解析之后，浏览器向服务器发起了http请求，tcp连接，三次握手建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接。</p>
<p>（1）客户端向服务器发送连接请求报文；<br>（2）服务器端接受客户端发送的连接请求后后回复ACK报文，并为这次连接分配资源。<br>（3）客户端接收到ACK报文后也向服务器端发生ACK报文，并分配资源。</p>
<p>这样TCP连接就建立了。<br>在此之后，浏览器开始向服务器发送http请求，请求数据包。请求信息包含一个<strong>请求头部</strong>和一个<strong>请求体</strong>。</p>
<p><strong>服务器收到请求</strong></p>
<p>服务器收到浏览器发送的请求信息，返回一个<strong>响应头</strong>和一个<strong>响应体</strong>。</p>
<p><strong>浏览器页面渲染</strong></p>
<ul>
<li>处理HTML标记并构建DOM树；</li>
<li>处理CSS标记并构建CSSOM树；</li>
<li>将DOM和CSSOM合并为一颗渲染树，通常为了更好的用户体验，渲染会与解析同时进行，将已经解析好的树渲染出来。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息(重排)</li>
<li>将各个结点绘制到屏幕上(重绘)</li>
<li>如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。</li>
</ul>
<p><strong>断开连接，四次挥手</strong></p>
<hr>
<h3><span id="cache的结构与工作原理">Cache的结构与工作原理</span></h3><p><a href="https://blog.csdn.net/baidu_35679960/article/details/78610804" target="_blank" rel="noopener">https://blog.csdn.net/baidu_35679960/article/details/78610804</a></p>
<p>首先，要想理解cache，先理解内存。内存的简单表示如下图，内存里面的内容的查找是根据地址来进行的，也就是说内存包含两点①地址②内存的内容（存的数据），根据地址来找数据。</p>
<p><img src="https://img-blog.csdn.net/20171123102431734" alt="img"></p>
<hr>
<h2><span id="数据库">数据库</span></h2><h3><span id="mysql相关">Mysql相关</span></h3><h4><span id="事务的特性acid">事务的特性(ACID)</span></h4><ol>
<li><strong>原子性（Atomicity）</strong>：原子性是指一个事务中的操作，<strong>要么全部成功，要么全部失败</strong>，如果失败，就回滚到事务开始前的状态。</li>
<li><strong>一致性（Consistency）</strong>：一致性是指<strong>事务必须使数据库从一个一致性状态变换到另一个一致性状态</strong>，也就是说一个事务执行之前和执行之后都必须处于一致性状态。那转账举栗子，A账户和B账户之间相互转账，无论如何操作，A、B账户的总金额都必须是不变的。</li>
<li><strong>隔离性（Isolation）</strong>：<strong>隔离性是当多个用户并发的访问数据库时，如果操作同一张表，数据库则为每一个用户都开启一个事务，且事务之间互不干扰，也就是说事务之间的并发是隔离的</strong>。再举个栗子，现有两个并发的事务T1和T2，T1要么在T2开始前执行，要么在T2结束后执行，如果T1先执行，那T2就在T1结束后在执行。关于数据的隔离性级别，将在后文讲到。</li>
<li><strong>持久性（Durability）</strong>：持久性就是指如果<strong>事务一旦被提交，数据库中数据的改变就是永久性的，即使断电或者宕机的情况下，也不会丢失提交的事务操作。</strong></li>
</ol>
<hr>
<h4><span id="如果不考虑隔离性会发生什么事呢">如果不考虑隔离性，会发生什么事呢？</span></h4><ol>
<li><p><strong>脏读</strong>(select问题)</p>
<p>脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>；</span><br><span class="line">updata t_table <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'wangwu'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">--此时事务2查询id = 1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>；<span class="comment">--未提交</span></span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;        <span class="comment">--查询到 id = 1， name = 'wangwu'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可重复读</strong>(update问题)</p>
<p>不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。</p>
<p>不可重复读和脏读的区别是，<strong>脏读读取到的是一个未提交的数据</strong>，而<strong>不可重复读读取到的是前一个事务提交的数据</strong>。而不可重复读在一些情况也并不影响数据的正确性，比如需要多次查询的数据也是要以最后一次查询到的数据为主。</p>
<p><strong>解决不可重复读的方法是 锁行</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = list, 事务2在此时提交</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = wangwu</span></span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> t_table <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'wangwu'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>幻读</strong>(insert/delete问题)</p>
<p>幻读是<strong>事务非独立执行</strong>时发生的一种现象。例如事务 <code>T1</code> 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 <code>T2</code> 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 <code>T1</code> 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是<strong>不可重复读查询的都是同一个数据项</strong>，而<strong>幻读针对的是一批数据整体</strong>（比如数据的个数）。</p>
<p><strong>解决幻读的方式是 锁表。</strong></p>
</li>
</ol>
<hr>
<h4><span id="四种隔离级别">四种隔离级别</span></h4><p>四种隔离级别主要解决的是脏读、幻读和不可重复读的问题。</p>
<ol>
<li><p><strong>读未提交(Read uncommitted)</strong></p>
<p>这种事务隔离级别下，<code>select</code> 语句不加锁。此时，可能读取到不一致的数据，即<strong>脏读</strong>。这是并发最高，一致性最差的隔离级别。</p>
</li>
<li><p><strong>读已提交(Read committed)</strong></p>
<p>可避免<strong>脏读</strong>的发生，但是会有<strong>幻读</strong>和<strong>不可重复读</strong>的问题。在互联网大数据量，高并发量的场景下，几乎 <strong>不会使用</strong> 上述两种隔离级别。</p>
<p>这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>不然，普通的查询是不会加锁的，若有事务对数据进行更新 <code>UPDATE</code> 操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p>
<blockquote>
<p>那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
</blockquote>
<p>这就要说到另一个机制<strong>快照(snapshot)</strong>，而这种既能保证一致性又不加锁的读也被称为快照读    （<strong>Snapshot Read</strong>）。假设没有“快照读”，那么<strong>当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞</strong>（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而“快照读”就可以完成高并发的查询，不过，读提交只能避免脏读，并不能避免不可重复读和幻读。</p>
</li>
</ol>
<p>​    <strong>快照读</strong>的意思是，数据有多个版本， 当事务并发执行时， 某一事务读取的数据来自其中一个版本（快照）。</p>
<ol start="3">
<li><p><strong>可重复读(Repeatable read)</strong></p>
<p><code>MySql</code> 默认隔离级别。可避免 <strong>脏读</strong> 、<strong>不可重复读</strong> 的发生。不可重复读对应的是修改，即 <code>UPDATE</code> 操作。但是可能还会有幻读问题。因为幻读问题对应的是插入 <code>INSERT</code> 操作，而不是 <code>UPDATE</code> 操作。</p>
<p>在这个级别下，普通的查询同样是使用的<strong>快照读</strong>，但是，和读提交不同的是，当事务启动时，就不允许进行修改操作(<code>Update</code>) 了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。</p>
</li>
<li><p><strong>串行化(Serializable)</strong></p>
<p>可避免 <strong>脏读、不可重复读、幻读</strong> 的发生。 <code>Serializable</code> 是一致性最好的，性能最差的。这种级别下，事务串行化顺序执行，也就是一个一个排队执行。这种级别下，<code>脏读</code> 、<code>不可重复读</code> 、<code>幻读</code> 都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
</li>
</ol>
<p>上面四种隔离级别最高的是 <strong>Serializable</strong> 级别，最低的是 <strong>Read uncommitted</strong> 级别，当然级别越高，执行效率就越低。像 <strong>Serializable</strong> 这样的级别，就是以 <strong>锁表</strong> 的方式(类似于多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。</p>
<h5><span id="什么是快照读-当前读">什么是快照读、当前读</span></h5><ul>
<li><strong>快照读</strong>, 读取专门的快照 (对于 <code>RC</code> ，快照( <code>ReadView</code> )会在每个语句中创建。对于 <code>RR</code> ，快照是在事务启动时创建的)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的select操作即可(不需要加锁,如: select ... lock in share mode, select ... for update)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>针对的也是 <code>select</code> 操作</p>
<ul>
<li><strong>当前读</strong>, 读取最新版本的记录, 没有快照。 在 <code>InnoDB</code> 中，当前读取根本不会创建任何快照。当前读会在搜索的时候加锁<h5><span id="mysql如何解决幻读问题">MySql如何解决幻读问题</span></h5></li>
</ul>
<p>两点需要说明：</p>
<ol>
<li>在可重复读隔离级别下，普通查询是<strong>快照读</strong>，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。</li>
<li>幻读专指新插入的行，读到原本存在行的更新结果不算。因为<strong>当前读的作用就是能读到所有已经提交记录的最新值</strong>。如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。</li>
</ol>
<p><strong>幻读产生的原因</strong></p>
<p>　　行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。 </p>
<p><strong>如何解决幻读？</strong></p>
<ol>
<li><p>在<strong>快照读</strong>读情况下，<code>mysql</code> 通过<strong>mvcc</strong>来避免幻读。</p>
<p><code>SESSION_A</code> 执行一个查询，这个查询可以访问任何表，这个查询的目的是创建一个当前时间点的快照， <code>SESSION_B</code> 再插入一条记录并提交。由于 <code>SESSION_A</code> 第一次的查询开始于 <code>SESSION_B</code> 插入数据前，所以创建了一个以 <code>SELECT</code> 操作的时间为基准点的 <code>read view</code> ，避免了幻读的产生。所以在 <code>SESSION_A</code> 的事务结束前,无法看到 <code>SESSION_B</code> 对表 <code>read_view</code> 做出的任何更改 <code>(insert,delete,update)</code>。</p>
<p>简单的select操作(不包括 select … lock in share mode, select … for update)。</p>
<ul>
<li>Read Committed隔离级别：每次select都生成一个快照读。</li>
<li>Read Repeatable隔离级别：<strong>开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。</strong></li>
</ul>
<p>在RR级别下，<strong>快照读是通过MVVC(多版本控制)和undo log</strong>来实现的，<strong>当前读是通过加record lock(记录锁)和gap lock(间隙锁)</strong>来实现的。</p>
</li>
<li><p>在<strong>当前读</strong>读情况下，<code>mysql</code> 通过<strong>next-key</strong>来避免幻读</p>
<p><strong>Innodb</strong>行锁分为:</p>
<p>| 类型           | 说明                                                         |<br>| ————– | ———————————————————— |<br>| Record Lock:   | 在索引上对单行记录加锁.                                      |<br>| Gap Lock:      | 锁定一个范围的记录,但不包括记录本身.锁加在未使用的空闲空间上,可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间. |<br>| Next-Key Lock: | 行锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。 |</p>
<p>当前读读取的是最新版本, 并且<strong>对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</strong></p>
<p>例如，假设要 <code>update</code> 一条记录，但是另一个事务已经 <code>delete</code> 这条数据并且 <code>commit</code> 了，如果不加锁就会产生冲突。所以 <code>update</code> 的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。</p>
<p>当以当前读模式<code>select * from t5 where id=7 for update;</code>获取 <code>id=7</code> 的数据时,产生了 <code>Next-Key Lock</code> ，锁住了 <code>4-10</code> 范围和 <code>id=7</code> 单个 <code>record</code> ，从而阻塞了 <code>SESSION_B</code> 在这个范围内插入数据，而在除此之外的范围内是可以插入数据的。</p>
<p><strong>尽量使用唯一索引,因为唯一索引会把Next-Key Lock降级为Record Lock</strong></p>
</li>
</ol>
<hr>
<h4><span id="数据库三范式">数据库三范式</span></h4><ol>
<li><p>第一范式(确保每列保持<strong>原子性</strong>)</p>
<p>第一范式是最基本的范式。如果<strong>数据库表中的所有字段值都是不可分解的原子值</strong>，就说明该数据库表满足了第一范式。</p>
</li>
<li><p>第二范式(<strong>确保表中的每列都和主键相关</strong>)</p>
<p>第二范式在第一范式的基础之上更进一层。<strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）</strong>。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。(唯一性 一个表只说明一个事物)</p>
<p>主要是针对<strong>联合主键</strong>而言，比如有两个列都是主键，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式。这种情况需要进行表的拆分。</p>
</li>
<li><p>第三范式(<strong>确保每列都和主键列直接相关,而不是间接相关</strong>)</p>
<p>确保每列都和主键列直接相关,而不是间接相关也就是：<strong>非主键字段不能相互依赖，每列都与主键有直接关系，不存在传递依赖。</strong></p>
</li>
</ol>
<p>主键在一个表里只能存在一个！因为建立主键后，DBMS会默认把建立主键的列建立聚簇索引。但是一个表是允许把几个列一起设为主键的。</p>
<hr>
<h4><span id="索引是个什么样的数据结构呢">索引是个什么样的数据结构呢?</span></h4><p>索引是帮助 <code>MySQL</code> <strong>高效获取数据</strong>的<strong>排好序的数据结构</strong>。</p>
<p>索引主要有以下几种：</p>
<ol>
<li><strong>聚集索引（主键索引）</strong>：在数据库里面，所有行数都会按照主键索引进行排序。</li>
<li><strong>非聚集索引</strong>：就是给普通字段加上索引。</li>
<li><strong>联合索引</strong>：就是好几个字段组成的索引，称为联合索引。(<strong>遵从最左前缀原则</strong>)</li>
</ol>
<p>索引的数据结构和具体存储引擎的实现有关, 在 <code>MySQL</code> 中使用较多的索引有 <code>Hash索引</code> ，<code>B+</code> 树索引等,而我们经常使用的 <code>InnoDB</code> 存储引擎的默认索引实现为：<code>B+</code> 树索引。</p>
<ul>
<li><code>hash索引</code> 底层就是 <code>hash表</code> ，进行查找时，调用一次 <code>hash</code> 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。<code>B+</code> 树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
<li><code>hash索引</code> 进行等值查询更快(一般情况下)，但是却<strong>无法进行范围查询</strong>。因为在 <code>hash索引</code> 中经过 <code>hash函数</code> 建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询；而 <code>B+树</code> 的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</li>
<li><code>hash索引</code> 任何时候都避免不了<strong>回表查询数据</strong>，而 <code>B+树</code> 在符合某些条件(<strong>聚簇索引</strong>，<strong>覆盖索引</strong>等)的时候可以只通过索引完成查询。</li>
<li><code>B+</code> 树单个节点可以存储更多的数据，减少 <code>I/O</code> 的次数。</li>
<li>查找性能更稳定，因为都是要查找到叶子结点。</li>
<li>叶子结点形成了有序链表，便于查询。</li>
</ul>
<p><strong>MyISAM</strong>索引文件和数据文件是分离的(非聚集)</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png" alt="1608640486933"></p>
<p><strong>MyISAM</strong>先查找索引，找到的索引的<strong>value</strong>保存的是数据在磁盘中的地址，所以还要回表查询。</p>
<ul>
<li><strong>InnoDB</strong>索引实现的是聚集的<ul>
<li>表数据文件本身就是按照B+树组织的一个索引结构文件</li>
<li><strong>聚集索引</strong>：叶节点包含了完整的数据记录。(索引跟数据分开像<strong>MyISAM</strong>这样的交非聚集索引，要先查找索引，再回表查询；聚集索引是索引和数据在一起的索引，像<strong>InnoDB</strong>这样的)</li>
<li><strong>InnoDB</strong>必须有主键，并且推荐使用整形的自增主键。如果没有建主键会找一个唯一索引默认建主键；如果找不到的话会加一列隐形的列，来默认维护主键。整形更加方便比较、同时占用空间更小。<strong>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</strong></li>
</ul>
</li>
</ul>
<h5><span id="b树">B+树</span></h5><ul>
<li>非叶子节点不存储 <code>data</code> ，只存储索引(冗余)，可以放更多的索引</li>
<li>叶子节点包含所有的索引字段</li>
<li>叶子节点用指针链接，提高区间访问的性能。</li>
</ul>
<h5><span id="myisam与innodb-的区别">MyISAM与InnoDB 的区别</span></h5><ol>
<li><strong>InnoDB支持事务，MyISAM不支持</strong>，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li><p><strong>InnoDB支持外键，而MyISAM不支持</strong>。对一个包含外键的InnoDB表转为MYISAM会失败； 外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p>
</li>
<li><p><strong>InnoDB是聚集索引</strong>，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
</li>
<li><strong>InnoDB不保存表的具体行数</strong>，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</li>
<li><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></li>
<li>InnoDB表<strong>必须有唯一索引（如主键）</strong>（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</li>
</ol>
<hr>
<h4><span id="什么是聚簇索引">什么是聚簇索引?</span></h4><p>在 <code>B+树</code> 的索引中，叶子节点可能存储了当前的 <code>key</code> 值，也可能存储了当前的 <code>key</code> 值以及整行的数据，这就是<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。在 <code>InnoDB</code> 中，只有<strong>主键索引</strong>是<strong>聚簇索引</strong>，如果没有主键，则挑选一个唯一键建立聚簇索引.如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<hr>
<h3><span id="最左匹配">最左匹配</span></h3><p><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p>
<p><strong>最左匹配原则</strong>都是<strong>针对联合索引</strong>来说的，所以我们有必要了解一下<strong>联合索引</strong>的原理。了解了联合索引，那么为什么会有最左匹配原则这种说法也就理解了。</p>
<p>我们都知道索引的底层是一颗 <code>B+</code> 树，那么联合索引当然还是一颗 <code>B+</code> 树，只不过联合索引的健值数量不是一个，而是多个。构建一颗 <code>B+</code> 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p>
<p><img src="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png" alt="img"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以 <code>b = 2</code> 这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以<strong>最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引</strong>。例如 <code>a = 1</code>  and <code>b = 2</code> a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而 <code>a&gt;1</code> and <code>b=2</code> ，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<p>事务特性</p>
<ul>
<li>持久型数据库怎么实现的</li>
<li>数据库有哪几种日志</li>
<li>分布式下还能满足ACID吗</li>
<li>数据库有哪几种锁</li>
<li>联合索引知道吗</li>
</ul>
<h3><span id="redis">Redis</span></h3><p><strong>Redis(REmote DIctionary Server)是一个基于内存的高性能非关系型key-value数据库，它通常被称为数据结构服务器，因为值(value)可以是字符串(String), 哈希(Map), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。</strong></p>
<p>传统数据库遵循 <code>ACID</code> 规则。而 Nosql(Not Only SQL 的缩写)，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 <strong>CAP</strong> 定理。</p>
<p><strong>CAP定理</strong>(CAP theorem)，又被称作布鲁尔定理(Brewer’s theorem)，是分布式系统中的一个基本定理。<br>它指出任何分布式系统(Distributed System)中，最多具有一致性(Consistence)、可用性(Availability)、分区容错(Partition Tolerance)这三个特性中的两个。也就是说，三个特性无法兼顾，必须有所取舍。</p>
<ul>
<li>舍弃P(选择C/A)：单点的传统关系型数据库 DBMS(MySQL/Oracle)，但如果采用集群就必须考虑P了；</li>
<li>舍弃A(选择C/P)：是分布式系统要保证P，而且保证一致性，如 ZooKeeper / Redis / MongoDB / HBase；</li>
<li>舍弃C(选择A/P)：是分布式系统要保证P，而且保证可用性，如 CoachDB / Cassandra / DynamoDB。</li>
</ul>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于<strong>缓存</strong>，每秒可以处理超过 10 万次读写操作，是已知<strong>性能最快的 Key-Value 数据库</strong>。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p>
<p>同时 <code>Redis</code> 也支持事务，<code>Redis</code> 的所有操作都是原子性的，同时 <code>Redis</code> 还支持对几个操作合并后的原子性执行。</p>
<h4><span id="redis相比memcached有哪些优势">Redis相比memcached有哪些优势</span></h4><ul>
<li><code>memcached</code> 所有的值均是简单的字符串，<code>redis</code> 作为其替代者，支持更为丰富的数据类型</li>
<li><code>redis</code> 的速度比 <code>memcached</code> 快很多</li>
<li><code>redis</code> 可以持久化其数据</li>
</ul>
<h4><span id="redis常用的五种数据类型">Redis常用的五种数据类型</span></h4><p><code>Redis</code> 可以存储键和不同类型的值之间的映射。<strong>键的类型只能为字符串</strong>，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<h5><span id="string字符串">string字符串</span></h5><p><code>string</code> 类型是二进制安全的。意思是 <code>redis</code> 的 <code>string</code> 可以包含任何数据。比如 <code>jpg</code> 图片或者序列化对象 。</p>
<p><code>redis</code> 的 <code>string</code> 是动态数组，也就是说它字符串占的长度，要小于它底层数组的容量。<code>string</code> 扩容的时候会判断字符串的长度，当长度小于 <code>1m</code> 的时候每次扩容都是容量翻倍，当大于 <code>1m</code> 的时候，每次扩容增加一个 <code>1m</code> 的空间，但是有大小限制，<code>redis</code> 中的字符串最大值是 <code>512m</code> </p>
<p><code>redis</code> 中采用这种冗余的预处理机制来扩容主要是为了防止频繁的内存申请，内存的分配是很浪费时间的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个string // 可以同时两次set一个string，就是把它直接颠覆了，</span></span><br><span class="line"><span class="built_in">set</span> googege redis</span><br><span class="line"><span class="comment">// 得到一个string</span></span><br><span class="line">get googege</span><br><span class="line"><span class="comment">// 获取字符串的长度</span></span><br><span class="line"><span class="built_in">strlen</span> googege</span><br><span class="line"><span class="comment">// 对string做切片,getrange string fitst-index end-index</span></span><br><span class="line"><span class="comment">// 并且必须提供后面的两个起始和结束的index，否则报错。</span></span><br><span class="line">getrange googege <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="comment">// 覆盖字符串 setrange string first-index new string.</span></span><br><span class="line">setrange googege <span class="number">1</span> ddddddd</span><br><span class="line"><span class="comment">// 追加字符串 append string xxx</span></span><br><span class="line">append googege ttt</span><br></pre></td></tr></table></figure>
<p>当字符串是整数的时候，也可以将它当成计数器。</p>
<hr>
<h5><span id="list列表">list列表</span></h5><p>list的底层是一个双向链表，所以可以使用这个链表来实现队列或者stack的功能</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p><strong>在 key 对应 list 的头部添加字符串元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush name value</span><br></pre></td></tr></table></figure>
<p><strong>在 key 对应 list 的尾部添加字符串元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush name value</span><br></pre></td></tr></table></figure>
<p><strong>key 对应 list 中删除 count 个和 value 相同的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem name index</span><br></pre></td></tr></table></figure>
<p><strong>返回 key 对应 list 的长度</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen name</span><br></pre></td></tr></table></figure>
<p><strong>获取子链</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush aaa go rust dart2</span><br><span class="line">lindex aaa <span class="number">1</span> <span class="comment">// 获取aaa的第2个元素</span></span><br><span class="line">lrang aaa <span class="number">0</span> <span class="number">2</span> <span class="comment">// 获取子链</span></span><br><span class="line">lrang aaa <span class="number">0</span> <span class="number">-1</span> <span class="comment">// -的意思就是倒着数</span></span><br><span class="line"><span class="comment">// 遍历全部的数据</span></span><br><span class="line">lrang <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 这个时候使用-数不用使用llen了，也是极好的。</span></span><br></pre></td></tr></table></figure>
<p><strong>修改和插入元素</strong></p>
<p>插入数据不是根据的下标的顺序，因为 <code>redis</code> 经常用在分布式的环境中，那么分布式中的下标就没有意义了，所以特别的指定在某个元素后面或者前面插入xx元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush aa go java rust</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">lset aa <span class="number">1</span> t <span class="comment">// 变成了  go t rust</span></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">linsert aa before go tt<span class="comment">// tt go java rust</span></span><br><span class="line">linsert aa after go tt <span class="comment">// go tt java rust</span></span><br></pre></td></tr></table></figure>
<p> <strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpush aa go rust dd</span><br><span class="line">lrem aa <span class="number">1</span> go <span class="comment">// 删除的时候不仅仅要写出来个数还要写出来元素的值</span></span><br></pre></td></tr></table></figure>
<hr>
<h5><span id="set集合">set集合</span></h5><p><strong>增加元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加元素sadd setname value value value value</span></span><br><span class="line">sadd y <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 读取元素 smembers 读取全部元素。 scard 获取set的长度 srandmember获取随机个数的元素，默认是1</span></span><br><span class="line">smembers y</span><br><span class="line">scard y</span><br><span class="line">srandmember y <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素 srem setname 1 2 3 4 删除必须指出来删除谁</span></span><br><span class="line">srem q <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 随机删除一个元素 spop setname</span></span><br><span class="line">spop q</span><br></pre></td></tr></table></figure>
<p><strong>判断元素是否存在</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否存在 sismember setname value</span></span><br><span class="line">sismember q <span class="number">43</span></span><br></pre></td></tr></table></figure>
<hr>
<h5><span id="sorted-setzset有序集合">sorted set(zset)有序集合</span></h5><p><code>zset</code> 实现的是有序集合，内部数据结构是 <strong>map 跳表</strong></p>
<p> <code>hash</code> 是关联元素 <code>key</code> 和权重（key和权重一一对应，其实相当于权重就是它的 <code>value</code> 值），<strong>跳表在于排序value 根据score范围查找元素。</strong></p>
<p><strong>增加删除数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd zsetname 权重 value 权重 value</span></span><br><span class="line">zadd u <span class="number">4.0</span> go </span><br><span class="line"><span class="comment">// 后面跟着的是权重</span></span><br><span class="line">zadd u <span class="number">4.0</span> go <span class="number">1.0</span> java</span><br><span class="line"><span class="comment">// 获取元素个数</span></span><br><span class="line">zcard q</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">//zrem zsetname value</span></span><br><span class="line">zrem u Java</span><br></pre></td></tr></table></figure>
<p><strong>计数器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd zsetname 权重 value</span></span><br><span class="line">zadd q <span class="number">4.0</span> python</span><br><span class="line"><span class="comment">// 获取排名和分数</span></span><br><span class="line">zscore q python</span><br><span class="line"><span class="comment">// zrank获取指定元素的正向排名</span></span><br><span class="line">zrank q python</span><br><span class="line"><span class="comment">// zrerank 反向排名</span></span><br></pre></td></tr></table></figure>
<p><strong>根据排名范围获取元素</strong> </p>
<p>这个原理主要是因为跳表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zrange q <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 获取所有数据</span></span><br><span class="line">zrange q <span class="number">0</span> <span class="number">-1</span> withscores <span class="comment">// 获取数据和他们的权重</span></span><br><span class="line">zrevrange q <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 按照负的顺序去排名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据sore返回获取value</span></span><br><span class="line">zrangebysocre q <span class="number">0</span> <span class="number">5</span><span class="comment">// zrangebyscore zsetname 权重区间</span></span><br><span class="line">zrangebyscore q -inf + inf withscores <span class="comment">// -inf负无穷 +inf 正无穷</span></span><br></pre></td></tr></table></figure>
<p><strong>根据范围移除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangenyrank zsetname scorestart scoreend</span><br></pre></td></tr></table></figure>
<hr>
<h5><span id="hash哈希表">hash哈希表</span></h5><p>跟一般的 <code>hash table</code> 没有区别，使用 <code>哈希函数 + 数组 + 链表</code> 。</p>
<p>哈希函数算出值，然后加入到那个值对应的数组，然后数组中是一个链表，链表表示都是算出来的这个的值的kv结构（这个时候如果链表太长就意味着是hash碰撞了，这也是攻击手段的一种。）</p>
<p><strong>增加查询删除</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hset mapname key value 增加一个</span></span><br><span class="line">hset ui a b</span><br><span class="line"><span class="comment">// hmset mapnae key value key value 增加一堆</span></span><br><span class="line">hmset ui a b c d e f g h</span><br><span class="line"><span class="comment">// 获取一个key hget mapname key</span></span><br><span class="line">hget ui a</span><br><span class="line"><span class="comment">//获取一堆key value hmget mapname key key key</span></span><br><span class="line">hmget ui a c e h</span><br><span class="line"><span class="comment">// 获取全部k-v hgetall mapname</span></span><br><span class="line">hgetall ui</span><br><span class="line"><span class="comment">//获取全部key</span></span><br><span class="line">hkeys mapname</span><br><span class="line"><span class="comment">// 获取全部value</span></span><br><span class="line">hvals mapname</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">hdel mapname key key key</span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line"><span class="comment">// hexists mapname key</span></span><br><span class="line">hexists ui a <span class="comment">// 0表示不存在 1 表示存在</span></span><br></pre></td></tr></table></figure>
<p><strong>计数器hash</strong></p>
<p>每一个k-v都是一个独立的计数器</p>
<p><strong>map的扩容</strong></p>
<p>当<code>hash</code> 碰撞太多的时候（时间复杂度已经从o(1)变成了o(n)）这个时候就该扩容了， 扩容的原则就是直接将数组扩大一倍，并且将各种数据从老的数组中转移到新的数组中；同时为了避免数据迁移带来的巨大损耗，<strong>redis是新旧同时保留，然后在后台使用一个定时的任务，以及hash读写指令，将数据逐步转移到新的数据结构中</strong>，新旧同时保留如何查找数据呢，其实只要在两个数组中都查查就行了。</p>
<hr>
<h4><span id="redis持久化">Redis持久化</span></h4><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p><code>Redis</code> 提供了两种持久化方式：<code>RDB</code> (默认)和 <code>AOF</code></p>
<h5><span id="rdbredis-database-半持久化模式">RDB(Redis DataBase) 半持久化模式</span></h5><p><code>RDB</code> 持久化是指<strong>在指定的时间间隔内将内存中的数据集快照写入磁盘</strong>，实际操作过程是 <code>fork</code> 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。(<strong>半持久化模式</strong>)</p>
<p><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png" alt="img"></p>
<p>功能核心函数<strong>rdbSave</strong>(生成RDB文件)和<strong>rdbLoad</strong>（从文件加载内存）两个函数</p>
<p><img src="https://www.redis.com.cn/images/riq1.png" alt="img"></p>
<hr>
<h5><span id="aofappend-only-file-全持久化模式">AOF(Append-only file) 全持久化模式</span></h5><p>每当执行服务器(定时)任务或者函数时<strong>flushAppendOnlyFile</strong> 函数都会被调用，把每一次数据变化都写入到一个<strong>append only file(aof)</strong>里面。  由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。这个函数执行以下两个工作</p>
<p><strong>aof写入保存：</strong></p>
<ol>
<li><strong>WRITE</strong>：根据条件，将 <code>aof_buf</code> 中的缓存写入到 <code>AOF</code> 文件</li>
<li><strong>SAVE</strong>：根据条件，调用 <code>fsync</code> 或 <code>fdatasync</code> 函数，将 <code>AOF</code> 文件保存到磁盘中。</li>
</ol>
<p>在Redis的配置文件中存在三种<strong>同步方式</strong>，它们分别是：</p>
<ol>
<li>appendfsync always     #每次有数据修改发生时都会写入AOF文件。</li>
<li>appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。</li>
<li>appendfsync no          #从不同步。高效但是数据不会被持久化。</li>
</ol>
<h5><span id="存储结构">存储结构</span></h5><p>持久化存储的内容是 <code>redis</code> 通讯协议( <code>RESP(Redis Serialization Protocol)</code>  )格式的命令文本存储。<code>RESP</code> 是 <code>redis</code> 客户端和服务端之前使用的一种通讯协议；RESP 的特点：<strong>实现简单、快速解析、可读性好</strong></p>
<p>协议如下：</p>
<ul>
<li>客户端以规定格式的形式发送命令给服务器；</li>
<li>服务器在执行最后一条命令后，返回结果。</li>
</ul>
<ol>
<li>简单字符串 <strong>Simple Strings</strong>, 以 “+”加号 开头</li>
</ol>
<p>​      格式：<strong>+</strong> 字符串 \r\n  。字符串不能包含 CR或者 LF(不允许换行)</p>
<p>​      eg: <strong>“+OK\r\n”</strong></p>
<p>​      注意：为了发送二进制安全的字符串，一般推荐使用后面的 <strong>Bulk Strings</strong> 类型</p>
<ol start="2">
<li>错误 <strong>Errors</strong>, 以”<strong>-</strong>“减号 开头</li>
</ol>
<p>　　格式：- 错误前缀 错误信息 \r\n 。错误信息不能包含 CR或者 LF(不允许换行)，Errors与Simple Strings很相似，不同的是Erros会被当作异常来看待</p>
<p>​      eg: <strong>“-Error unknow command ‘foobar’\r\n”</strong></p>
<ol start="3">
<li>整数型 <strong>Integer</strong>， 以 “:” 冒号开头。格式 : 数字 \r\n</li>
</ol>
<p>​      eg: <strong>“:1000\r\n”</strong></p>
<ol start="4">
<li>大字符串类型 <strong>Bulk Strings</strong>, 以 “$”美元符号开头，长度限制512M</li>
</ol>
<p>　　格式：$ 字符串的长度 \r\n 字符串 \r\n  字符串不能包含 CR或者 LF(不允许换行);</p>
<p>​      eg: <strong>“$6\r\nfoobar\r\n”</strong>    其中字符串为 foobar，而6就是foobar的字符长度</p>
<p>​            “$0\r\n\r\n”       空字符串</p>
<p>​            “$-1\r\n”           null</p>
<ol start="5">
<li>数组类型 <strong>Arrays</strong>，以 “*“星号开头。格式：* 数组元素个数 \r\n 其他所有类型 (结尾不需要\r\n)</li>
</ol>
<p>​             注意：只有元素个数后面的\r\n是属于该数组的，结尾的\r\n一般是元素的</p>
<p>​      eg: “*0\r\n”      空数组</p>
<p>​           “*2\r\n2\r\nfoo\r\n2\r\nfoo\r\n3\r\nbar\r\n”      数组包含2个元素，分别是字符串foo和bar</p>
<p>　　　　“*3\r\n:1\r\n:2\r\n:3\r\n”       数组包含3个整数：1、2、3</p>
<p>​           “*5\r\n:1\r\n:2\r\n:3\r\n:4\r\n$6\r\nfoobar\r\n”  包含混合类型的数组</p>
<p>​           “*-1\r\n”         Null数组</p>
<hr>
<h4><span id="redis架构模式">Redis架构模式</span></h4><h5><span id="1-单机版">1. 单机版</span></h5><p><strong>内存容量有限/处理能力有限/无法高可用。</strong></p>
<p><img src="https://www.redis.com.cn/images/riq3.png" alt="img"></p>
<h5><span id="2-主从复制">2. 主从复制</span></h5><p><img src="https://www.redis.com.cn/images/riq4.png" alt="img"></p>
<p><code>Redis</code> 的复制(replication)功能允许用户根据一个 <code>Redis</code> 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而<strong>一直保证主从服务器的数据相同</strong>。</p>
<p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以<strong>避免这种单点故障</strong></p>
<p><strong>复制是高可用Redis的基础</strong>，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及<strong>对于读操作的负载均衡和简单的故障恢复</strong>。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</p>
<p><strong>特点：</strong></p>
<ol>
<li>master/slave 角色</li>
<li>master/slave 数据相同</li>
<li>降低 master <strong>读</strong>压力在转交从库</li>
</ol>
<p><strong>问题：</strong></p>
<ol>
<li>无法保证<strong>高可用</strong></li>
<li>没有解决 <code>master</code> <strong>写的压力</strong></li>
</ol>
<h5><span id="3-哨兵">3. 哨兵</span></h5><p><img src="https://www.redis.com.cn/images/riq5.png" alt="img"></p>
<p><strong>Redis sentinel</strong> 是一个分布式系统中监控 <code>redis</code> 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<ol>
<li><p><strong>监控(Monitoring)</strong>：<strong>Sentinel</strong> 会不断地检查你的主服务器和从服务器是否运作正常。</p>
</li>
<li><p><strong>提醒(Notification)</strong>：当被监控的某个 <strong>Redis</strong> 服务器出现问题时， <strong>Sentinel</strong> 可以通过 <strong>API</strong> 向管理员或者其他应用程序发送通知。</p>
</li>
<li><p><strong>自动故障迁移(Automatic failover)</strong>：当一个主服务器不能正常工作时， <strong>Sentinel</strong> 会开始一次自动故障迁移操作。</p>
</li>
</ol>
<p><strong>特点：</strong></p>
<ol>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>主从模式，切换需要时间丢数据</li>
<li>没有解决 <code>master</code> <strong>写的压力</strong></li>
</ol>
<h5><span id="4-集群proxy型">4. 集群(proxy型)</span></h5><p><img src="https://www.redis.com.cn/images/riq6.png" alt="img"></p>
<h5><span id="5-集群直连型">5. 集群(直连型)</span></h5><p><img src="https://www.redis.com.cn/images/riq7.png" alt="img"></p>
<p>从redis 3.0之后版本支持<strong>redis-cluster</strong>集群，<strong>Redis-Cluster</strong>采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>无中心架构</strong>（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li><strong>可扩展性</strong>，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li><strong>高可用性</strong>，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</li>
<li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，<strong>用投票机制完成 Slave到 Master 的角色提升。</strong></li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>资源<strong>隔离性较差</strong>，容易出现相互影响的情况。</p>
</li>
<li><p>数据通过<strong>异步复制，不保证数据的强一致性</strong></p>
</li>
</ol>
<hr>
<h4><span id="redis是单线程的但redis为什么这么快">Redis是单线程的，但Redis为什么这么快？</span></h4><p>Redis是基于内存的操作，<code>CPU</code> 不是Redis的瓶颈，Redis的瓶颈最有可能是<strong>机器内存的大小或者网络带宽</strong>。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了，毕竟采用多线程会有很多麻烦。Redis采用单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。</p>
<p>Redis单线程但是很快的原因主要如下：</p>
<ol>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li>
<li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li>
<li>采用单线程，<strong>避免了不必要的上下文切换和竞争条件</strong>，也<strong>不存在多进程或者多线程导致的切换而消耗 CPU</strong>，<strong>不用去考虑各种锁的问题</strong>，<strong>不存在加锁释放锁操作</strong>，<strong>没有因为可能出现死锁而导致的性能消耗</strong>；</li>
<li>使用多路I/O复用模型，非阻塞IO；<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</strong>非阻塞IO 内部实现采用 <code>epoll</code> ，采用了 <code>epoll</code> +自己实现的简单的事件框架。<code>epoll</code> 中的读、写、关闭、连接都转化成了事件，然后利用 <code>epoll</code> 的多路复用特性，绝不在io上浪费一点时间。</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ol>
<hr>
<h4><span id="为什么redis用跳表不用红黑树">为什么redis用跳表不用红黑树</span></h4><ul>
<li>跳表范围查找比红黑树好</li>
<li>更好实现</li>
<li>并发状态下锁住的数据比红黑树少</li>
<li>动态更改的时候跳表要更改的数据少，红黑树则需要树化。更改更大</li>
</ul>
<p>跳表如果消耗内存过大，其实可以调节索引的稠密程度，稍微稀疏一点占用的内存就少了。</p>
<hr>
<h4><span id="为什么redis不用b树">为什么redis不用b+树</span></h4><ul>
<li>主要是reids经常在并发高的条件下使用，b+树的化每次数据更改都需要树化，但是跳表锁定的数据很少，很适合并发分布式状态下使用</li>
<li>B树，B+树：它们特点是一样的，是多路查找树，一般用于数据库系统中，为什么，因为它们分支多层数少呗， 都知道磁盘IO是非常耗时的，而像大量数据存储在磁盘中所以我们要有效的减少磁盘IO次数避免磁盘频繁的查找。 这是多路树的作用在磁盘中减少io但是它不适合在并发分布式下，尤其是动态更改数据强烈的状态下使用</li>
</ul>
<hr>
<h4><span id="redis的用途是什么">Redis的用途是什么？</span></h4><ul>
<li><strong>计数器</strong>： 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</li>
<li><strong>缓存</strong>：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</li>
<li><strong>会话缓存</strong>： 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</li>
<li><strong>全页缓存（FPC）</strong>：除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
<li><strong>查找表</strong>：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</li>
<li><strong>消息队列(发布/订阅功能)</strong>：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</li>
<li><strong>分布式锁实现</strong>：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</li>
<li><strong>其它</strong>：Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet可以实现有序性操作，从而实现排行榜等功能。</li>
</ul>
<h2><span id="其他">其他</span></h2><h3><span id="从两个文件各含50亿个url中找出共同的url">从两个文件(各含50亿个url)中找出共同的url</span></h3><blockquote>
<p>给定a、b两个文件，各存放50亿个url，每个url各占用64字节，内存限制是4G，如何找出a、b文件共同的url？</p>
</blockquote>
<p>可以估计每个文件的大小为 <code>5G*64=300G</code> ，远大于 <code>4G</code> 。所以不可能将其完全加载到内存中处理。考虑采取<strong>分而治之</strong>的方法。<br>遍历文件 <code>a</code> ，对每个 <code>url</code> 求取 <code>hash(url)%1000</code>，然后根据所得值将 <code>url</code> 分别存储到 <code>1000</code> 个小文件（设为<code>a0,a1,...a999</code> ）当中。这样每个小文件的大小约为 <code>300M</code> 。遍历文件 <code>b</code> ，采取和 <code>a</code> 相同的方法将 <code>url</code> 分别存储到 <code>1000</code> 个小文件(<code>b0,b1....b999</code>)中。这样处理后，所有可能相同的 <code>url</code> 都在对应的小文件( <code>a0 vs b0, a1 vs b1....a999 vs b999</code> )当中，不对应的小文件（比如 <code>a0 vs b99</code> ）不可能有相同的url。然后我们只要求出 <code>1000</code> 对小文件中相同的 <code>url</code> 即可。<br>比如对于 <code>a0 vs b0</code> ，我们可以遍历 <code>a0</code> ，将其中的 <code>url</code> 存储到 <code>hash_map</code> 当中。然后遍历 <code>b0</code> ，如果 <code>url</code> 在 <code>hash_map</code> 中，则说明此 <code>url</code> 在 <code>a</code> 和 <code>b</code> 中同时存在，保存到文件中即可。<br>如果分成的小文件不均匀( <code>hash</code> 的问题)，导致有些小文件太大（比如大于 <code>2G</code> ），可以考虑将这些太大的小文件再按类似的方法分成小小文件即可。</p>
<hr>
<h3><span id="git中merge和rebase的区别">git中Merge和rebase的区别</span></h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/面经/" rel="tag"># 面经</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/17/1030. 距离顺序排列矩阵单元格/" rel="next" title="Leetcode_1030 距离顺序排列矩阵单元格">
                <i class="fa fa-chevron-left"></i> Leetcode_1030 距离顺序排列矩阵单元格
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/01/705. 设计哈希集合/" rel="prev" title="Leetcode_705 设计哈希集合">
                Leetcode_705 设计哈希集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">343</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">90</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">后台开发知识点汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.</span> <span class="nav-text">C++线程中的几种锁/互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">互斥锁(Mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">条件变量(condition_variable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">自旋锁(spinlock_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">读写锁(shared_mutex)/共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">递归锁(recursive_mutex)/可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">定时锁(time_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">两种基本的锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.7.1.</span> <span class="nav-text">条件变量中只能使用unique_lock&lt; std::mutex &gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.</span> <span class="nav-text">C++中原子类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.</span> <span class="nav-text">C++中thread操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">std::thread构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">detach()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">wait()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">wait_for()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">notify_all/notify_one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">虚假唤醒</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.</span> <span class="nav-text">C++多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">多态有哪几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">虚函数的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">为什么析构函数必须是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">为什么C++默认的析构函数不是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">为什么构造函数不能是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">静态成员及静态成员函数能不能被继承？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.8.</span> <span class="nav-text">友元可以继承吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.9.</span> <span class="nav-text">虚函数(virtual)可以是内联函数(inline)吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.10.</span> <span class="nav-text">多态中构造函数/析构函数调用顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.11.</span> <span class="nav-text">类成员函数中重载/重写/隐藏的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.12.</span> <span class="nav-text">钻石继承问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.</span> <span class="nav-text">C++的四种cast</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">哪种cast更加接近C的强制类型转换？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.</span> <span class="nav-text">C++智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">auto_ptr(弃用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">unique_ptr(替换auto_ptr)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.5.</span> <span class="nav-text">智能指针是线程安全的吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.</span> <span class="nav-text">C++对象的内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">普通对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">派生类的对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">vtable中虚函数指针的排列顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.8.</span> <span class="nav-text">Volitale关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">volatile指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.8.2.1.</span> <span class="nav-text">什么是可见性？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.9.</span> <span class="nav-text">C++中指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.10.</span> <span class="nav-text">C++中new与malloc的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.</span> <span class="nav-text">C++ 内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.</span> <span class="nav-text">C++存储类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">auto 自动变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.2.</span> <span class="nav-text">register 寄存器变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.3.</span> <span class="nav-text">static 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.4.</span> <span class="nav-text">extern关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.5.</span> <span class="nav-text">mutable 存储类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.12.6.</span> <span class="nav-text">thread_local 存储类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.13.</span> <span class="nav-text">std::move()语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.</span> <span class="nav-text">右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.3.</span> <span class="nav-text">右值引用有办法指向左值吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.4.</span> <span class="nav-text">完美转发 std::forward()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.14.5.</span> <span class="nav-text">auto&amp;&amp;也是这个意思</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.</span> <span class="nav-text">C++内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">内联函数有什么优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.3.</span> <span class="nav-text">将内联函数放入头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.4.</span> <span class="nav-text">内联函数与宏定义的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.5.</span> <span class="nav-text">explicit关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.15.6.</span> <span class="nav-text">union 联合体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.16.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.17.</span> <span class="nav-text">必须在构造函数初始化列表里进行初始化的数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.18.</span> <span class="nav-text">定位内存泄露及检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.19.</span> <span class="nav-text">手写strcpy，memcpy，strcat，strcmp等函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.19.1.</span> <span class="nav-text">strcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.19.2.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.19.3.</span> <span class="nav-text">strlen</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.19.4.</span> <span class="nav-text">strcat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.19.5.</span> <span class="nav-text">strcmp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.20.</span> <span class="nav-text">memmove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.21.</span> <span class="nav-text">手写单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.22.</span> <span class="nav-text">三个线程交替打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.23.</span> <span class="nav-text">类模板和模板类的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.</span> <span class="nav-text">海量数据问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.1.</span> <span class="nav-text">十亿整数（随机生成，可重复）中前K最大的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.24.2.</span> <span class="nav-text">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.25.</span> <span class="nav-text">布隆过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.25.1.</span> <span class="nav-text">什么情况下需要布隆过滤器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.25.2.</span> <span class="nav-text">布隆过滤器的原理。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.25.3.</span> <span class="nav-text">位图(bitmap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.25.4.</span> <span class="nav-text">布隆过滤器大小计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.25.5.</span> <span class="nav-text">布隆过滤器可能出现误判，怎么保证无误差？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.1.</span> <span class="nav-text">Hash Map冲突如何解决？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.1.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.1.2.</span> <span class="nav-text">哈希冲突解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.2.</span> <span class="nav-text">Hash_map扩容发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.3.</span> <span class="nav-text">Unordered_map和map底层实现有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.3.1.</span> <span class="nav-text">map与unordered_map的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.3.2.</span> <span class="nav-text">为什么用红黑树？红黑树查询效率为什么快？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.4.</span> <span class="nav-text">为何map和set的插入删除效率比用其他序列容器高？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.4.1.</span> <span class="nav-text">为什么每次insert之后，以前保存的iterator不会失效</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.5.</span> <span class="nav-text">vector相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.5.1.</span> <span class="nav-text">vector空间的动态增长</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.5.2.</span> <span class="nav-text">vector底层数据结构，vector底层是如何删除元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.6.</span> <span class="nav-text">STL里的内存池实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.26.6.1.</span> <span class="nav-text">内存的分配和回收</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.1.</span> <span class="nav-text">Linux的内存不足时会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.2.</span> <span class="nav-text">操作系统的四大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.</span> <span class="nav-text">死锁/活锁/饥饿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">死锁预防方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">银行家算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">活锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">饥饿</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.4.</span> <span class="nav-text">⭐进程和线程的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.</span> <span class="nav-text">多进程和多线程的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.0.1.</span> <span class="nav-text">优劣</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.</span> <span class="nav-text">临界区(进程同步)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.7.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">CAS原子操作(compare and swap)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.</span> <span class="nav-text">进程间如何通信？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.2.1.</span> <span class="nav-text">无名管道(pipe)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.2.2.</span> <span class="nav-text">有名管道(FIFO)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">信号(signal)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.4.</span> <span class="nav-text">消息队列(message queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.5.</span> <span class="nav-text">共享内存(shared memory)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.6.</span> <span class="nav-text">信号量(semophore )</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.6.1.</span> <span class="nav-text">信号量工作原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.7.</span> <span class="nav-text">套接字(socket)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.9.</span> <span class="nav-text">进程/线程的上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.9.1.</span> <span class="nav-text">进程的上下文可以分为哪几个部分？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.9.2.</span> <span class="nav-text">为什么切换线程比切换进程开销小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.10.</span> <span class="nav-text">多线程间通信和同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.11.</span> <span class="nav-text">⭐协程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.11.1.</span> <span class="nav-text">libco库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.12.</span> <span class="nav-text">五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.12.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.12.2.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.12.3.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.12.4.</span> <span class="nav-text">信号驱动的IO模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.12.5.</span> <span class="nav-text">异步IO模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.13.</span> <span class="nav-text">两种IO事件处理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.13.1.</span> <span class="nav-text">Reactor模式(同步的)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.13.2.</span> <span class="nav-text">Proactor模式 (异步)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.</span> <span class="nav-text">⭐IO多路复用：select/poll/epoll(同步/阻塞)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.3.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.3.1.</span> <span class="nav-text">epoll 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.3.2.</span> <span class="nav-text">工作模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.3.3.</span> <span class="nav-text">epoll的优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.3.4.</span> <span class="nav-text">mmap实现共享内存：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.14.3.5.</span> <span class="nav-text">边缘触发的IO应该怎么写？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.1.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.2.</span> <span class="nav-text">内存分段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.3.</span> <span class="nav-text">内存分页</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.3.1.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.3.2.</span> <span class="nav-text">64位系统用到的是四级目录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.3.3.</span> <span class="nav-text">TLB(Translation Lookaside Buffer) 页表缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.3.4.</span> <span class="nav-text">段页式内存管理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.4.</span> <span class="nav-text">Linux内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.4.1.</span> <span class="nav-text">用户空间的内存分布</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.15.5.</span> <span class="nav-text">mmap内存映射原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.16.</span> <span class="nav-text">缺页中断(page_fault)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.16.1.</span> <span class="nav-text">页面置换算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.</span> <span class="nav-text">CPU调度算法/进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.0.1.</span> <span class="nav-text">先到先服务算法(FCFS, First-Come First-Served)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.0.2.</span> <span class="nav-text">最短作业优先(SJF, Shortest Job First)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.0.3.</span> <span class="nav-text">优先级算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.0.4.</span> <span class="nav-text">高响应比优先调度算法(HRRN)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.0.5.</span> <span class="nav-text">最短剩余时间优先 (SRTF, Shortest Remaining Time First)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.0.6.</span> <span class="nav-text">RR(Round Robin)调度器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.17.0.7.</span> <span class="nav-text">多级反馈队列(MFQ)：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.18.</span> <span class="nav-text">用户态与内核态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.18.0.1.</span> <span class="nav-text">三种情况会导致用户态到内核态的切换</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">TCP/UDP/运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">⭐UDP和TCP的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">TCP/UDP数据发送和接收过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">发送端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">接收端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.3.</span> <span class="nav-text">复用与分用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">TCP协议的可靠性体现在哪里</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">校验和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">序列号(ACK)和确认应答</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">滑动窗口(以字节为单位)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.7.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.7.1.</span> <span class="nav-text">慢开始</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.7.2.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.7.3.</span> <span class="nav-text">快重传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.7.4.</span> <span class="nav-text">快恢复</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.8.</span> <span class="nav-text">TCP 报文段首部格式(20Byte)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.9.</span> <span class="nav-text">停止等待 ARQ 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.10.</span> <span class="nav-text">三次握手四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.10.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.10.2.</span> <span class="nav-text">四次挥手</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.11.</span> <span class="nav-text">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.12.</span> <span class="nav-text">什么是Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.12.1.</span> <span class="nav-text">socket函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.12.2.</span> <span class="nav-text">bind函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.12.3.</span> <span class="nav-text">listen/connect函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.12.4.</span> <span class="nav-text">accept函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.13.</span> <span class="nav-text">read/write函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.14.</span> <span class="nav-text">SOCKET通信中TCP、UDP数据包大小的确定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.14.1.</span> <span class="nav-text">MTU最大传输单元</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.</span> <span class="nav-text">IP/网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">地址解析协议 ARP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">计算机网络是如何根据IP地址定位到一台主机的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">ICMP/IGMP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">网际控制报文协议 ICMP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">ICMP 报文种类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.3.1.</span> <span class="nav-text">网际组管理协议 IGMP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">IP 数据报的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.4.1.</span> <span class="nav-text">首部固定字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.4.2.</span> <span class="nav-text">首部可变部分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">⭐HTTPS的通信过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.2.1.</span> <span class="nav-text">非对称加密算法+对称加密算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.2.2.</span> <span class="nav-text">数字证书—防止中间人攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.2.3.</span> <span class="nav-text">数字摘要算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.2.4.</span> <span class="nav-text">证书内置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">get/post 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">http/https 0.9、1.0、1.1、2.0、3.0的特点和区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.4.1.</span> <span class="nav-text">Http0.9</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.4.2.</span> <span class="nav-text">Http1.0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.4.3.</span> <span class="nav-text">Http1.1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.4.4.</span> <span class="nav-text">Http2.0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.4.5.</span> <span class="nav-text">Http3.0</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">HTTP的无状态性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.5.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.5.2.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.5.3.</span> <span class="nav-text">Session和Cookie的关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">HTTP请求种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">从浏览器输入URL到出现页面经过了哪些阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.</span> <span class="nav-text">Cache的结构与工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.</span> <span class="nav-text">Mysql相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">事务的特性(ACID)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">如果不考虑隔离性，会发生什么事呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">四种隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.3.1.</span> <span class="nav-text">什么是快照读、当前读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.3.2.</span> <span class="nav-text">MySql如何解决幻读问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">数据库三范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">索引是个什么样的数据结构呢?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.5.1.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.5.2.</span> <span class="nav-text">MyISAM与InnoDB 的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">什么是聚簇索引?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.2.</span> <span class="nav-text">最左匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Redis相比memcached有哪些优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Redis常用的五种数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">string字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">list列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.2.3.</span> <span class="nav-text">set集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.2.4.</span> <span class="nav-text">sorted set(zset)有序集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.2.5.</span> <span class="nav-text">hash哈希表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.3.1.</span> <span class="nav-text">RDB(Redis DataBase) 半持久化模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.3.2.</span> <span class="nav-text">AOF(Append-only file) 全持久化模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.3.3.</span> <span class="nav-text">存储结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">Redis架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.4.1.</span> <span class="nav-text">1. 单机版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.4.2.</span> <span class="nav-text">2. 主从复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.4.3.</span> <span class="nav-text">3. 哨兵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.4.4.</span> <span class="nav-text">4. 集群(proxy型)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.4.5.</span> <span class="nav-text">5. 集群(直连型)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">Redis是单线程的，但Redis为什么这么快？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">为什么redis用跳表不用红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">为什么redis不用b+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.8.</span> <span class="nav-text">Redis的用途是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.1.</span> <span class="nav-text">从两个文件(各含50亿个url)中找出共同的url</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.2.</span> <span class="nav-text">git中Merge和rebase的区别</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
