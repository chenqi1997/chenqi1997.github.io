<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面经,基础知识,C++,">










<meta name="description" content="后台开发面经汇总 C++基础 C++线程中的几种锁 互斥锁(Mutex) 条件锁(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁   C++中thread操作 join() detach()   C++多态 多态有哪几种？ 虚函数的实现 动态绑定 为什么析构函数必须是">
<meta name="keywords" content="面经,基础知识,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="后台开发面经汇总">
<meta property="og:url" content="http://chenqi1997.github.io/2020/11/17/后台开发面经汇总/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="后台开发面经汇总 C++基础 C++线程中的几种锁 互斥锁(Mutex) 条件锁(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁   C++中thread操作 join() detach()   C++多态 多态有哪几种？ 虚函数的实现 动态绑定 为什么析构函数必须是">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg">
<meta property="og:image" content="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg">
<meta property="og:image" content="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215306696">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215332079">
<meta property="og:image" content="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png">
<meta property="og:image" content="https://img-blog.csdn.net/20171123102431734">
<meta property="og:updated_time" content="2020-12-04T15:35:08.565Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="后台开发面经汇总">
<meta name="twitter:description" content="后台开发面经汇总 C++基础 C++线程中的几种锁 互斥锁(Mutex) 条件锁(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁   C++中thread操作 join() detach()   C++多态 多态有哪几种？ 虚函数的实现 动态绑定 为什么析构函数必须是">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/11/17/后台开发面经汇总/">





  <title>后台开发面经汇总 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/11/17/后台开发面经汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">后台开发面经汇总</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-17T17:46:00+08:00">
                2020-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面经/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#后台开发面经汇总">后台开发面经汇总</a><ul>
<li><a href="#c基础">C++基础</a><ul>
<li><a href="#c线程中的几种锁">C++线程中的几种锁</a><ul>
<li><a href="#互斥锁mutex">互斥锁(Mutex)</a></li>
<li><a href="#条件锁condition_variable">条件锁(condition_variable)</a></li>
<li><a href="#自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</a></li>
<li><a href="#读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</a></li>
<li><a href="#递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</a></li>
</ul>
</li>
<li><a href="#c中thread操作">C++中thread操作</a><ul>
<li><a href="#join">join()</a></li>
<li><a href="#detach">detach()</a></li>
</ul>
</li>
<li><a href="#c多态">C++多态</a><ul>
<li><a href="#多态有哪几种">多态有哪几种？</a></li>
<li><a href="#虚函数的实现">虚函数的实现</a></li>
<li><a href="#动态绑定">动态绑定</a></li>
<li><a href="#为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</a></li>
<li><a href="#为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</a></li>
<li><a href="#为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</a></li>
<li><a href="#静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</a></li>
<li><a href="#友元可以继承吗">友元可以继承吗？</a></li>
<li><a href="#多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</a></li>
<li><a href="#类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</a></li>
<li><a href="#钻石继承问题">钻石继承问题</a></li>
</ul>
</li>
<li><a href="#c的四种cast">C++的四种cast</a><ul>
<li><a href="#static_cast">static_cast</a></li>
<li><a href="#const_cast">const_cast</a></li>
<li><a href="#reinterpret_cast">reinterpret_cast</a></li>
<li><a href="#dynamic_cast">dynamic_cast</a></li>
<li><a href="#哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</a></li>
</ul>
</li>
<li><a href="#c智能指针">C++智能指针</a><ul>
<li><a href="#auto_ptr弃用">auto_ptr(弃用)</a></li>
<li><a href="#unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
<li><a href="#weak_ptr">weak_ptr</a></li>
<li><a href="#智能指针是线程安全的吗">智能指针是线程安全的吗？</a></li>
</ul>
</li>
<li><a href="#stl">STL</a><ul>
<li><a href="#hash-map冲突如何解决">Hash Map冲突如何解决？</a></li>
<li><a href="#unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</a><ul>
<li><a href="#map底层数据结构">map底层数据结构</a></li>
<li><a href="#为什么用红黑树">为什么用红黑树</a></li>
<li><a href="#红黑树查询效率为什么快">红黑树查询效率为什么快</a></li>
</ul>
</li>
<li><a href="#vector相关">vector相关</a><ul>
<li><a href="#vector空间的动态增长">vector空间的动态增长</a></li>
<li><a href="#vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#类模板和模板类的区别">类模板和模板类的区别？</a></li>
<li><a href="#右值引用">右值引用</a></li>
<li><a href="#volitale关键字">Volitale关键字</a></li>
<li><a href="#stdmove语义">std::move语义</a></li>
<li><a href="#三个线程交替打印">三个线程交替打印</a></li>
</ul>
</li>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</a></li>
<li><a href="#进程和线程的区别和联系">⭐进程和线程的区别和联系</a></li>
<li><a href="#临界区进程同步">临界区(进程同步)</a></li>
<li><a href="#原子操作">原子操作</a><ul>
<li><a href="#cas原子操作compare-and-swap">CAS原子操作(compare and swap)</a></li>
</ul>
</li>
<li><a href="#进程间如何通信">进程间如何通信？</a><ul>
<li><a href="#应用场景">应用场景</a></li>
<li><a href="#管道">管道</a><ul>
<li><a href="#无名管道pipe">无名管道(pipe)</a></li>
<li><a href="#有名管道fifo">有名管道(FIFO)</a></li>
</ul>
</li>
<li><a href="#信号signal">信号(signal)</a></li>
<li><a href="#消息队列message-queue">消息队列(message queue)</a></li>
<li><a href="#共享内存shared-memory">共享内存(shared memory)</a></li>
<li><a href="#信号量semophore">信号量(semophore )</a><ul>
<li><a href="#信号量工作原理">信号量工作原理</a></li>
</ul>
</li>
<li><a href="#套接字socket">套接字(socket)</a></li>
</ul>
</li>
<li><a href="#多线程间通信和同步">多线程间通信和同步</a></li>
<li><a href="#协程">⭐协程</a><ul>
<li><a href="#libco库">libco库</a></li>
</ul>
</li>
<li><a href="#selectpollepoll的区别">⭐Select/Poll/Epoll的区别</a><ul>
<li><a href="#缺页中断">缺页中断</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#计算机网络">计算机网络</a><ul>
<li><a href="#udp和tcp的差别">⭐UDP和TCP的差别</a></li>
<li><a href="#三次握手四次挥手">三次握手四次挥手</a></li>
<li><a href="#get和post的区别">get和post的区别</a></li>
<li><a href="#http状态码">HTTP状态码</a></li>
<li><a href="#计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</a><ul>
<li><a href="#地址解析协议-arp">地址解析协议 ARP</a></li>
</ul>
</li>
<li><a href="#https的通信过程">⭐HTTPS的通信过程</a></li>
<li><a href="#从浏览器输入网址到出现页面经过了哪些阶段">从浏览器输入网址到出现页面经过了哪些阶段</a></li>
<li><a href="#cache的结构与工作原理">Cache的结构与工作原理</a></li>
<li><a href="#边缘触发和水平触发区别">边缘触发和水平触发区别</a></li>
</ul>
</li>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#mysql相关">Mysql相关</a></li>
</ul>
</li>
<li><a href="#其他">其他</a><ul>
<li><a href="#从两个文件各含50亿个url中找出共同的url">从两个文件(各含50亿个url)中找出共同的url</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h1><span id="后台开发面经汇总">后台开发面经汇总</span></h1><h2><span id="c基础">C++基础</span></h2><h3><span id="c线程中的几种锁">C++线程中的几种锁</span></h3><p>C++线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong> 这几种</p>
<h4><span id="互斥锁mutex">互斥锁(Mutex)</span></h4><p>互斥锁用于<strong>控制多个线程对他们之间共享资源互斥访问的一个信号量</strong>。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。</p>
<p>在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以<strong>阻塞方式</strong>进行等待。</p>
<p><strong>互斥锁是是一种sleep-waiting的锁</strong>。假设线程 <code>T1</code> 获取互斥锁并且正在 <code>core1</code> 上运行时，此时线程 <code>T2</code> 也想要获取互斥锁 (pthread_mutex_lock)，但是由于 <code>T1</code> 正在使用互斥锁使得 <code>T2</code> 被阻塞。当 <code>T2</code> 处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器 <code>core2</code> 会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p>
<p><strong>用法：</strong>在C++中，通过构造 <code>std::mutex</code> 的实例创建互斥元，调用成员函数 <code>lock()</code> 来锁定它，调用 <code>unlock()</code> 来解锁，不过一般不推荐这种做法，标准C++库提供了std::lock_guard类模板，实现了互斥元的 <code>RAII</code> 惯用语法。<code>std::mutex</code> 和 <code>std::lock_guard</code> 。都声明在 <code>&lt;mutex&gt;</code> 头文件中。</p>
<p><code>lock_guard</code> 对象通常用于管理某个锁(Lock)对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用互斥元保护列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list;</span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(some_mutex);</span><br><span class="line">    some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="条件锁condition_variable">条件锁(condition_variable)</span></h4><p>条件锁就是所谓的条件变量，某一个线程因为某个条件<strong>未满足</strong>时可以使用 <code>条件锁</code> 使该程序处于 <code>阻塞状态</code> 。</p>
<p>一旦条件满足，可以以 <code>信号量</code> 的方式唤醒一个因为该条件而被阻塞的线程。</p>
<p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为 <code>任务队列为空</code> 这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用std::condition_variable等待数据</span></span><br><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);   <span class="comment">//这里使用unique_lock是为了后面方便解锁</span></span><br><span class="line">        data_cond.wait(lk,&#123;[]<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面，<code>wait()</code> 的实现接下来检查条件，并在满足时返回。如果条件不满足，wait()解锁互斥元，并将该线程置于阻塞或等待状态。当来自数据准备线程中对notify_one()的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从wait()返回值，互斥元仍被锁定。如果条件不满足，该线程解锁互斥元，并恢复等待。</p>
<hr>
<h4><span id="自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</span></h4><p><em>自旋锁需要与互斥锁一起来比较理解。</em></p>
<p><strong>自旋锁是一种busy-waiting的锁</strong>。也就是说，如果 <code>T1</code> 正在使用自旋锁，而 <code>T2</code> 也去申请这个自旋锁，此时 <code>T2</code> 肯定得不到这个自旋锁。与互斥锁相反的是，此时运行 <code>T2</code> 的处理器 <code>core2</code> 会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p>
<p>从 <code>自旋锁</code> 的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一直占用 <code>CPU</code> 请求这个自旋锁使得 <code>CPU</code> 不能去做其他的事情，直到获取这个锁为止，这就是 <code>自旋</code> 的含义。</p>
<p>当发生阻塞时，互斥锁可以让 <code>CPU</code> 去处理其他的任务；而自旋锁让 <code>CPU</code> 一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道 <code>自旋锁</code> 是比较耗费 <code>CPU</code> 的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(<span class="keyword">spinlock_t</span> *x);<span class="comment">//初始化</span></span><br><span class="line">spin_lock(x);   			  <span class="comment">//只有在获得锁的情况下才返回，否则一直“自旋”</span></span><br><span class="line">spin_trylock(x);  			  <span class="comment">//如立即获得锁则返回真，否则立即返回假</span></span><br><span class="line">spin_unlock(x);				  <span class="comment">//释放锁</span></span><br><span class="line">spin_is_locked(x)			  <span class="comment">//该宏用于判断自旋锁x是否已经被某执行单元保持（即被锁），如果是，   返回真，否则返回假。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</span></h4><p><code>std::shared_mutex</code>有两种访问级别：</p>
<ul>
<li><strong>共享：</strong>多个线程可以共享这个锁的拥有权。一般用于数据的<strong>读操作</strong>，防止数据被写修改。</li>
<li><p><strong>互斥：</strong>仅仅一个线程可以拥有这个锁。一般用于<strong>写操作</strong>。</p>
</li>
<li><p>如果一个线程已经获取了 <code>互斥锁</code> ，则其他线程都无法获取该锁。</p>
</li>
<li>如果一个线程已经获取了 <code>共享锁</code> ，则其他任何线程都无法获取 <code>互斥锁</code> ，但是可以获取 <code>共享锁</code> 。</li>
</ul>
<hr>
<h4><span id="递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</span></h4><p>我们都知道，一般的互斥量对于同一个线程只能同时加锁一次（调用 <code>lock</code> ），如果连续调用两次以上便会出现死锁。但设想这样一个场景，如果在一个函数内给互斥量上了锁还没有解开，然后又调用了另一个函数，这个被调用的函数也去给互斥量上锁，这种情境下就会出现死锁。</p>
<p>对于互斥锁，分为递归锁和非递归锁。在不同的线程中调用已锁定的互斥锁，必然会导致死锁。但是在<strong>同一个线程中，如果想要多次获得一个锁，只能使用递归锁</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MutexLock mutex;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    mutex.unlock();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    foo();  </span><br><span class="line">    mutex.unlock();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，引入了递归锁的概念。</p>
<p><strong>递归锁</strong>，顾名思义，<strong>如果因为多次函数调用而导致出现多次上锁的情况，只有第一次会去真正加锁，后面的加锁操作会被自动忽略。</strong></p>
<p><strong>recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁）</strong>，来获得对互斥量对象的<strong>多层所有权</strong>，<code>recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和 <code>unlock()</code> 次数相同，除此之外，<code>recursive_mutex</code> 的特性和<code>mutex</code> 大致相同。</p>
<hr>
<h3><span id="c中thread操作">C++中thread操作</span></h3><h4><span id="join">join()</span></h4><p>阻塞当前线程，直至 <code>this</code> 所标识的线程完成其执行。<code>this</code> 所标识的线程的完成同步于从 <strong>join()</strong> 的成功返回。</p>
<p>该方法简单暴力，主线程等待子进程期间什么都不能做。<code>thread::join()</code> 会清理子线程相关的内存空间，此后<code>thread object</code> 将不再和这个子线程相关了，即 <code>thread object</code> 不再 <code>joinable</code> 了，所以 <code>join</code> 对于一个子线程来说只可以被调用一次，为了实现更精细的线程等待机制，可以使用条件变量等机制。</p>
<h4><span id="detach">detach()</span></h4><hr>
<h3><span id="c多态">C++多态</span></h3><p><strong>封装，继承，多态是面向对象设计的三个特征</strong>，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。</p>
<h4><span id="多态有哪几种">多态有哪几种？</span></h4><p>多态是面向对象的重要特性之一，它是一种行为的封装，是同一种事物所表现出的多种形态，简单地说是”一个接口多种实现“。多态的实现主要分为<strong>静态多态</strong>和<strong>动态多态</strong>：</p>
<ul>
<li><p>静态多态主要是<strong>重载</strong>，在编译的时候就已经确定。</p>
<ul>
<li><strong>函数重载</strong></li>
<li><strong>运算符重载</strong></li>
<li><strong>模板</strong></li>
</ul>
</li>
<li><p>动态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。</p>
</li>
</ul>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，<strong>在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数</strong>。在子类中重新定义父类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<hr>
<h4><span id="虚函数的实现">虚函数的实现</span></h4><p>在有虚函数的类中，<strong>类的最开始部分是一个虚函数表的指针</strong>，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在 <code>代码段(.text)</code> 中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<p>虚表是一个<strong>指针数组</strong>，其元素是<strong>虚函数的指针</strong>，每个元素对应一个<strong>虚函数的函数指针</strong>。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。虚表内的条目，即<strong>虚函数指针的赋值发生在编译器的编译阶段</strong>，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<p>虚表是<strong>属于类</strong>的，而不是属于某个具体的对象，<strong>一个类只需要一个虚表</strong>即可。<strong>同一个类的所有对象都使用同一个虚表。</strong></p>
<p>⭐<code>Linux</code> 下虚表存储位置在<strong>只读数据段中(rodata)</strong>，<code>windows</code> 是在存储位置应该是<strong>常量区域。</strong> </p>
<p>为了指定对象的虚表，对象内部包含一个<strong>虚表的指针</strong>，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>void** __vfptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg" alt="img"></p>
<hr>
<h4><span id="动态绑定">动态绑定</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类 <code>A</code> 是基类，类 <code>B</code> 继承类 <code>A</code> ，类 <code>C</code> 又继承类 <code>B</code> 。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> ，其对象模型如下图所示。由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（<code>A vtbl</code>），类B的虚表（<code>B vtbl</code>），类C的虚表（<code>C vtbl</code>）。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> 对象都拥有一个虚表指针<code>*__vptr</code>，用来指向自己所属类的虚表。</p>
<p><strong>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</strong>。</p>
<p><strong>生成子类虚表的过程：</strong></p>
<ol>
<li>将父类虚表内容拷贝到子类虚表上。</li>
<li>将子类重写的虚函数覆盖掉表中父类的虚函数。</li>
<li>如果子类有新增加的虚函数,按声明次序加到最后。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg" alt="img"></p>
<p>我们把经过虚表调用虚函数的过程称为<strong>动态绑定</strong>，其表现出来的现象称为<strong>运行时多态</strong>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为<strong>静态绑定</strong>，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p>
<ol>
<li>通过<strong>指针或引用</strong>来调用函数</li>
<li>指针<strong>upcast</strong>向上转型（继承类向基类的转换称为 <code>upcast</code> ）</li>
<li>调用的是虚函数</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<hr>
<h4><span id="为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</span></h4><p>将<strong>可能会被继承的父类</strong>的析构函数设置为虚函数，可以保证当我们 <code>new</code> 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<hr>
<h4><span id="为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</span></h4><p>C++默认的析构函数不是虚函数是因为虚函数<strong>需要额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是<strong>只有当需要当作父类时，设置为虚函数。</strong></p>
<hr>
<h4><span id="为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</span></h4><p>1.<strong>从存储空间角度：</strong> 虚函数对应一个 <code>vtable</code> ，这个 <code>vtable</code> 其实是存储在<strong>对象的内存空间</strong>的。问题出来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到<code>vtable</code> ，所以构造函数不能是虚函数。<br><strong>2，从使用角度：</strong> 构造函数本身就是要<strong>初始化实例</strong>，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。<strong>虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数</strong>。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。<br><strong>3、构造函数不需要是虚函数，也不允许是虚函数：</strong>因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过基类的指针或引用去访问它。<br><strong>4、从实现上看，</strong><code>vtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数。</p>
<hr>
<h4><span id="静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</span></h4><p>⭐<strong>静态数据成员和静态成员函数可以被继承！</strong>具体如下：</p>
<ol>
<li>父类的 <code>static</code> 变量和函数在派生类中依然可用，但是<strong>受访问性控制</strong>（比如，父类的 <code>private</code> 域中的就不可访问），而且对 <code>static</code> 变量来说，派生类和父类中的 <code>static</code> 变量是<strong>共用空间</strong>的，这点在利用 <code>static</code> 变量进行引用计数的时候要特别注意。</li>
<li><code>static</code> 函数没有“虚函数”一说。因为 <code>static</code> 函数实际上是<strong>加上了访问控制的全局函数</strong>，全局函数哪来的什么虚函数的概念？</li>
<li>派生类的 <code>friend</code> 函数可以访问派生类本身的一切变量，包括从父类继承下来的 <code>protected</code> 域中的变量。但是对父类来说，他并不是 <code>friend</code> 的。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。所以 <code>static</code> 成员的这种应该算是继承。</li>
</ol>
<hr>
<h4><span id="友元可以继承吗">友元可以继承吗？</span></h4><p>⭐<strong>不能！</strong></p>
<p>友元只是能访问<strong>指定类的私有和保护成员的自定义函数</strong>，<strong>不是被指定类的成员</strong>，自然不能继承。 使用友元类时注意：</p>
<ol>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>A</code> 不一定是类 <code>B</code> 的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>C</code> 是 <code>B</code> 的友元，类 <code>C</code> 不一定是类 <code>A</code> 的友元，同样要看类中是否有相应的声明。</li>
</ol>
<hr>
<h4><span id="多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</span></h4><ol>
<li>基类对象首先被创建。</li>
<li>派生类构造函数应通过<strong>成员初始化列表</strong>（<strong>调用顺序和继承顺序相关</strong>）将基类信息传递给基类构造函数 ，可以使用初始化列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。</li>
<li>派生类构造函数<strong>应初始化派生类新增的数据成员</strong>。派生类对象析构时，程序<strong>首先调用派生类析构函数，再调用基类析构函数。</strong></li>
</ol>
<hr>
<h4><span id="类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</span></h4><ul>
<li><strong>函数重载：重载函数通常用来命名一组 <code>功能相似</code> 的函数</strong><ul>
<li>函数要在 <code>相同的类域</code></li>
<li>函数的 <code>名字要相同</code> </li>
<li>函数的 <code>参数列表或返回值不同</code> </li>
</ul>
</li>
<li><strong>函数重写/覆盖：覆盖是指 <code>派生类函数覆盖基类函数</code> </strong><ul>
<li>函数是要在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>基类函数 <code>必须是虚函数</code></li>
<li>两个函数的 <code>参数相同</code> </li>
</ul>
</li>
<li><strong>函数重定义/隐藏：指派生类的函数屏蔽了与其同名的基类函数</strong><ul>
<li>两个函数在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>两个函数的 <code>参数不同</code> </li>
<li><strong>如果派生类函数与基类函数参数相同，但是在基类函数中没有virtual关键字，发生函数隐藏</strong></li>
</ul>
</li>
</ul>
<hr>
<h4><span id="钻石继承问题">钻石继承问题</span></h4><hr>
<h3><span id="c的四种cast">C++的四种cast</span></h3><h4><span id="static_cast">static_cast</span></h4><p>在C++语言中 <code>static_cast</code> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。例如将整型数据转换为浮点型数据。</p>
<p>主要用法有如下几种：</p>
<ol>
<li><p>用于类层次结构中基类和派生类之间指针或引用的转换。</p>
<p>进行<strong>上行转换</strong>（把派生类的指针或引用转换成基类表示）是<strong>安全</strong>的<br>进行<strong>下行转换</strong>（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，是<strong>不安全</strong>的</p>
</li>
<li><p>用于基本数据类型之间的转换，如把 <code>int</code> 转换成 <code>char</code> 。这种转换的安全也要开发人员来保证。</p>
</li>
<li><p>把空指针转换成目标类型的空指针。</p>
</li>
<li><p>把任何类型的表达式转换为 <code>void</code> 类型。</p>
</li>
</ol>
<ul>
<li>注意：<code>static_cast</code> 不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</li>
<li><code>static_cast</code> : 可以实现C++中内置基本数据类型之间的相互转换。</li>
<li>如果涉及到类的话，<code>static_cast</code> 只能在<strong>有相互联系的类型</strong>中进行相互转换,不一定包含虚函数。</li>
</ul>
<hr>
<h4><span id="const_cast">const_cast</span></h4><p><strong>const_cast&lt;type_id&gt; (expression)</strong></p>
<p><code>const_cast</code> 用于强制去掉 <code>const</code> 这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是<strong>去除指向常数对象的指针或引用的常量性</strong>，其去除常量性的对象必须为指针或引用。用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li>
<li>常量对象被转换成非常量对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> *q =<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    *q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="string">" "</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=10 *p=20 *q=20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，原来的 <code>a</code> 的常量性并没有被去除，而指向常量的指针 <code>p</code> 被转化成非常量指针，并且仍然指向原来的对象，并且指向的值被 <code>q</code> 改变成 <code>20</code> 。</p>
<hr>
<h4><span id="reinterpret_cast">reinterpret_cast</span></h4><p><strong>reinterpret_cast&lt;type_id&gt; (expression) </strong>主要有三种强制转换用途：</p>
<ol>
<li>改变指针或引用的类型。</li>
<li>将指针或引用转换为一个足够长度的整形。</li>
<li>将整型转换为指针或引用类型。</li>
</ol>
<p>其中， <code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。<code>reinterpret_cast</code> 可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。整型指针通过 <code>reinterpret_cast</code> 强制转换成了双精度浮点型指针如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code> 可以将指针或引用转换为一个足够长度的整形，此中的足够长度具体长度需要多少则取决于操作系统，如果是32位的操作系统，就需要4个字节及以上的整型，如果是64位的操作系统则需要8个字节及以上的整型。</p>
<hr>
<h4><span id="dynamic_cast">dynamic_cast</span></h4><p><strong>用法：dynamic_cast&lt;type_id&gt; (expression)</strong></p>
<ol>
<li>其他三种都是<strong>编译时完成</strong>的，dynamic_cast是<strong>程序运行</strong>时处理的，运行时要进行<strong>类型检查</strong>。</li>
<li>不能用于内置的基本数据类型的强制转换。</li>
<li><code>dynamic_cast</code> 转换如果成功的话返回的是<strong>指向类的指针或引用</strong>，转换失败的话则会返回 <code>NULL</code> 。</li>
<li><code>dynamic_cast</code>涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换</li>
<li>使用 <code>dynamic_cast</code> 进行转换的，<strong>基类中一定要有虚函数，否则编译不通过</strong>。<br> 基类中需要检测有虚函数的原因：<ul>
<li>类中存在虚函数，就说明它有想<strong>要让基类指针或引用指向派生类对象</strong>的情况，此时转换才有意义。<br> 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。</li>
</ul>
</li>
<li>在类的转换时，在类层次间进行<strong>上行转换</strong> (子类指针指向父类指针) 时，<code>dynamic_cast</code> 和 <code>static_cast</code> 的效果是一样的。在进行下行转换 (父类指针转化子类指针) 时，<code>dynamic_cast</code> 具有类型检查的功能，比 <code>static_cast</code> 更安全。</li>
<li>在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。<code>dynamic_cast</code> 操作符则可以在运行期对可能产生问题的类型转换进行检查。这个检查主要来自<em>虚函数(virtual function)</em> 。在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名(function siguature)的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。</li>
</ol>
<hr>
<h4><span id="哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</span></h4><p>C风格的强制转换(Type Cast)容易理解,不管什么类型的转换都可以使用使用下面的方式.：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeName b = (TypeName)a;</span><br></pre></td></tr></table></figure>
<p><strong>static_cast</strong> 作用和C语言风格强制转换的效果基本一样，都没有运行时的类型检查来保证转换的安全性。</p>
<hr>
<h3><span id="c智能指针">C++智能指针</span></h3><p>C++提出了智能指针，有以下四种<code>auto_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>, <code>unique_ptr</code>。其中后三个是 <code>C++11</code> 支持的，第一个已经被 <code>C++11</code> 弃用。</p>
<p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是<strong>栈上</strong>的对象，所以当函数（或程序）结束时<strong>会自动被释放通过智能指针管理分配的内存单元</strong>。</p>
<h4><span id="auto_ptr弃用">auto_ptr(弃用)</span></h4><p><code>auto_ptr</code> 采用所有权模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，相当于 <code>p2</code> 剥夺了 <code>p1</code> 的所有权，但是当程序运行时访问 <code>p1</code> 将会报错。所以 <code>auto_ptr</code> 的缺点是：存在潜在的内存崩溃问题。</p>
<hr>
<h4><span id="unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</span></h4><p><code>unique_ptr</code> 实现独占式拥有或严格拥有概念，保证<strong>同一时间内只有一个智能指针</strong>可以指向该对象。它对于避免资源泄露 (例如“以new创建对象后因为发生异常而忘记调用delete”) 特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;</span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>同时，当程序试图将一个 <code>unique_ptr</code> 赋值给另一个时，如果源 <code>unique_ptr</code> 是个临时右值，编译器允许这么做；如果源 <code>unique_ptr</code> 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                          <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));       <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>#1</code> 留下悬挂的 <code>unique_ptr(pu1)</code> ，这可能导致危害。而 <code>#2</code> 不会留下悬挂的 <code>unique_ptr</code> ，因为它调用 <code>unique_ptr</code> 的构造函数，该构造函数创建的临时对象在其所有权让给 <code>pu3</code> 后就会被销毁</p>
<p>如果想要完成上面 <code>#1</code> 的操作，需要将一个 <code>unique_ptr</code> 赋给另一个，可以使用 <code>std::move()</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">std</span>::move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="shared_ptr">shared_ptr</span></h4><p><code>shared_ptr</code> 实现共享式拥有概念：多个智能指针可以指向相同对象，该对象和其相关资源会在<strong>最后一个引用被销毁</strong>时候释放。</p>
<p><code>shared_ptr</code> 使用计数机制来表明资源被几个指针共享。可以通过成员函数 <code>use_count()</code> 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 <code>auto_ptr</code> , <code>unique_ptr</code> , <code>weak_ptr</code> 来构造。当我们调用 <code>release()</code> 时，当前指针会释放资源所有权，计数减一。当计数等于 <code>0</code> 时，资源会被释放。</p>
<p>成员函数：</p>
<ul>
<li><p><code>use_count()</code> 返回引用计数的个数</p>
</li>
<li><p><code>unique()</code> 返回是否是独占所有权(use_count为 1 )</p>
</li>
<li><p><code>swap</code> 交换两个 <code>shared_ptr</code> 对象(即交换所拥有的对象)</p>
</li>
<li><p><code>reset</code> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li><p><code>get</code> 返回内部对象(指针), 由于已经重载了 <code>()</code> 方法, 因此和直接使用对象是一样的。</p>
<p>如 <code>shared_ptr&lt;int&gt; sp(new int(1));</code>  sp 与 sp.get() 是等价的。</p>
</li>
</ul>
<p><strong>引用计数带来的副作用</strong> <code>循环引用问题</code><br>A对象的指针指向B对象，B对象的指针指向了A对象。两个指针相互指向。<code>造成堆里的内存无法正常回收，造成内存泄漏。</code> 这个时候就需要 <code>weak_ptr</code> 了。</p>
<hr>
<h4><span id="weak_ptr">weak_ptr</span></h4><p><code>weak_ptr</code> 是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象，进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code> 。</p>
<p><code>weak_ptr</code> 只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 工作, <strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>, 它的构造和析构不会引起引用记数的增加或减少。</p>
<p><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题：</strong></p>
<p>如果两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。<code>weak_ptr</code> 是对对象的一种弱引用，不会增加对象的引用计数。</p>
<p><code>weak_ptr</code> 和 <code>shared_ptr</code> 之间可以相互转化，<code>shared_ptr</code> 可以直接赋值给<code>weak_ptr</code> ，<code>weak_ptr</code> 也可以通过调用 <code>lock</code> 函数来获得 <code>shared_ptr</code> 。</p>
<p>具体栗子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会只输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>出现了循环引用，当要跳出函数时，智能指针 <code>pa</code> ，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code> ，导致跳出函数时资源没有被释放(A\B的析构函数没有被调用)，如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 <code>A</code> 里面的 <code>shared_ptr pb_;</code> 改为 <code>weak_ptr pb_;</code> 运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">B delete</span><br><span class="line">A delete</span><br></pre></td></tr></table></figure>
<p>资源 <code>B</code> 的引用开始就只有 <code>1</code> ，当 <code>pb</code> 析构时，<code>B</code> 的计数变为 <code>0</code> ，<code>B</code> 得到释放，<code>B</code> 释放的同时也会使 <code>A</code> 的计数减一，同时 <code>pa</code> 析构时使 <code>A</code> 的计数减一，那么 <code>A</code> 的计数为 <code>0</code> ， <code>A</code> 得到释放。</p>
<p>注意的是我们不能通过 <code>weak_ptr</code> 直接访问对象的方法，比如 <code>B</code> 对象中有一个方法 <code>print()</code> ,我们不能这样访问，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;pb_-&gt;print()</span><br></pre></td></tr></table></figure>
<p><code>pb_</code> 是一个 <code>weak_ptr</code> ，应该先调用 <code>lock()</code> 函数把它转化为 <code>shared_ptr</code> ，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> p = pa-&gt;pb_.lock();</span><br><span class="line">p-&gt;print();</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>如何判断weak_ptr的对象是否失效？</strong></p>
<ol>
<li><code>expired()</code> ：检查被引用的对象是否已删除。</li>
<li><code>lock()</code> 会返回 <code>shared_ptr</code> 指针，判断该指针是否为空。</li>
<li><code>use_count()</code> 也可以得到 <code>shared_ptr</code> 引用的个数，但速度较慢。</li>
</ol>
<hr>
<p><strong>shared_ptr 和 unique_ptr 区别</strong></p>
<p><code>unique_ptr</code> 具有唯一性，对指向的对象值存在唯一的 <code>unique_ptr</code> 。<code>unique_ptr</code> 不可复制，赋值，但是<code>std::move()</code> 可以转换对象的所有权，局部变量的返回值除外。与 <code>shared_ptr</code> 相比，若自定义删除器，<code>unique_ptr</code>需要在声明处指定删除器类型，而 <code>shared_ptr</code> 不需要，<code>shared_ptr</code> 自定义删除器只需要指定删除器对象即可；在赋值时，<code>shared_ptr</code> 可以随意赋值，删除器对象也会被赋值给新的对象。因为在 <code>unique_ptr</code> 的实现中，删除器对象是作为 <code>unique_ptr</code> 的一部分，而 <code>shared_ptr</code> 的删除器对象保存在<code>control_block</code> 中。</p>
<hr>
<h4><span id="智能指针是线程安全的吗">智能指针是线程安全的吗？</span></h4><p><code>shared_ptr</code> 本身不是 <code>100%</code> 线程安全的。</p>
<p>它的引用计数本身是安全且无锁的，智能指针的引用计数在手段上使用了<strong>atomic原子操作</strong>，只要 <code>shared_ptr</code> 在拷贝或赋值时增加引用，析构时减少引用就可以了。首先原子是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的。</p>
<p>但对象的读写则不是，因为<code>shared_ptr</code> 有<strong>两个数据成员</strong>，读写操作不能原子化：一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象，当智能指针发生拷贝的时候，标准库的实现是<strong>先拷贝智能指针</strong>，<strong>再拷贝引用计数对象</strong>（拷贝引用计数对象的时候，会使 <code>use_count++</code>），这两个操作并不是原子操作，隐患就出现在这里。<strong>两个线程中智能指针的引用计数同时++或–，这个操作不是原子的，假设引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了，违背了原子性。</strong></p>
<p>根据 <code>boost</code> 文档，<code>shared_ptr</code> 的线程安全级别和内建类型、标准库容器、<code>std::string</code> 一样，即：</p>
<ul>
<li>一个 <code>shared_ptr</code> 对象实体可被多个线程同时读取；</li>
<li>两个 <code>shared_ptr</code> 对象实体可以被两个线程同时写入，<code>析构</code> 算写操作；</li>
<li>如果要从多个线程读写同一个 <code>shared_ptr</code> 对象，那么需要加锁。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>读</code> 是安全的。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>写</code> 是不安全的。</li>
<li>同一个 <code>shared_ptr</code> 对象不能被多线程直接修改，但可以通过原子函数完成。</li>
<li>共享引用计数的不同的 <code>shared_ptr</code> 被多个线程 <code>写</code>  是安全的。</li>
</ul>
<hr>
<h3><span id="stl">STL</span></h3><hr>
<h4><span id="hash-map冲突如何解决">Hash Map冲突如何解决？</span></h4><hr>
<h4><span id="unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</span></h4><h5><span id="map底层数据结构">map底层数据结构</span></h5><h5><span id="为什么用红黑树">为什么用红黑树</span></h5><h5><span id="红黑树查询效率为什么快">红黑树查询效率为什么快</span></h5><hr>
<h4><span id="vector相关">vector相关</span></h4><h5><span id="vector空间的动态增长">vector空间的动态增长</span></h5><h5><span id="vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</span></h5><hr>
<h3><span id="类模板和模板类的区别">类模板和模板类的区别？</span></h3><hr>
<h3><span id="右值引用">右值引用</span></h3><hr>
<h3><span id="volitale关键字">Volitale关键字</span></h3><p>volatile可理解为编译器警告指示字；volatile用于告诉编译器必须每次去内存中取变量值；volatile主要修饰可能被多个线程访问的变量；volatile也可以修饰可能被未知因数更改的变量</p>
<hr>
<h3><span id="stdmove语义">std::move语义</span></h3><hr>
<h3><span id="三个线程交替打印">三个线程交替打印</span></h3><hr>
<h2><span id="操作系统">操作系统</span></h2><h3><span id="linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</span></h3><p>物理内存用完就会使用交换空间（swap），会导致应用运行变慢。因为需要频繁在交换空间和内存之间换入换出数据。</p>
<hr>
<h3><span id="进程和线程的区别和联系">⭐进程和线程的区别和联系</span></h3><p>我们可以说“进程”是包含“线程”的，“线程”是“进程”的一个子集。进程是资源分配的最小单位，线程是程序执行的最小单位。一个程序至少有一个进程,一个进程至少有一个线程。线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。</p>
<p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，<strong>进程是线程的容器</strong>。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。<strong>它被包含在进程之中，是进程中的实际运作单位</strong>。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p><strong>进程是由线程+内存+文件/网络句柄构成的</strong>，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。</p>
<p><strong>线程是由栈+PC(程序计数器)+TLS(线程本地存储)组成的。</strong>操作系统真正运行的是一个个的线程，而我们的进程只是它的一个容器。<strong>PC程序计数器是当前执行指令的地址</strong>，而这个指令是放在内存中。每个线程都有一串自己的指针，去指向自己当前所在内存的指针。计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的<br>这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。<strong>TLS</strong>用来存储线程所独有的数据。</p>
<ul>
<li>进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</li>
<li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li>
<li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li>
<li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li>
<li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li>
</ul>
<hr>
<h3><span id="临界区进程同步">临界区(进程同步)</span></h3><p>操作系统中，同一时刻内同一段代码可能会有多个<strong>进程</strong>在执行，而像 <code>文件读写</code> 、<code>硬件调用</code> 等操作都是排他性的，因此操作系统更应该做好临界区的设置。</p>
<p>临界区( <code>critical-section</code> )是解决进程协作的一个方法。将<strong>多个进程可能修改同一个共享变量的代码段</strong>设为临界区，当有进程进入临界区后，其他进程会被禁止进入，直到前一个进程离开临界区，其他进程才可以进入。即<strong>同一时刻只允许一个进程位于临界区</strong>内。伪代码形式可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//进入区</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="comment">//退出区</span></span><br><span class="line">	<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<p>临界区的实现需要满足以下三个条件：</p>
<ol>
<li><strong>互斥</strong>，即同一时刻只能有一个进程位于临界区内；</li>
<li><strong>前进</strong>，当多个进程同时等待进入临界区的时候，会有一个进程被选择进入</li>
<li><strong>有限等待</strong>，在进入区等待的进程必须在有限时间后进入临界区。</li>
</ol>
<p><strong>实现方式：</strong>对于操作系统的临界区实现，要分为<strong>抢占内核</strong>和非抢占内核来讨论。显然，非抢占内核不存在竞争的问题，因为在临界区内的进程不会被打断，除非进程主动退出。对抢占内核来说，就需要硬件或者软件（算法）上的支持来实现临界区。</p>
<p>软件支持的一个例子是 <code>Peterson</code> 算法。<code>Peterson</code> 算法的精髓在于用两个变量（或数组）来记录当前是否有进程位于临界区以及哪个进程位于临界区，这样通过在进入区检测并设置标记、退出区恢复标记可以实现临界区排他的特性。</p>
<p>硬件支持的方法是 <code>锁</code> ，从底层硬件的层面来看则是实现 <code>原子操作</code> 。进程在进入临界区前检测并申请锁，离开后释放锁。原子操作保证锁的正常运行。<br>Linux下的原子操作的数据结构是 <code>atomic_t</code> ，其定义放在 <code>&lt;linux/types.h&gt;</code> 下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125;<span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>对于单处理器单核系统来说，只要保证操作指令序列不被打断即可实现原子操作。对于简单的原子操作，<code>cpu</code> 实现上会提供单条指令，比如 <code>INC</code> 和 <code>XCHG</code> 。对于复杂的原子操作，需要包含多条指令。执行过程中，出现上下文切换行为，比如任务切换，中断处理等。这里的行为会影响原子操作的原子性。因此需要自旋锁 <code>spinlock</code> 来保证操作指令序列不会在执行的中途受干扰。</p>
<p>但是如果对于多处理器或者多核的系统，原子操作的实现除了需要 <code>spinlock</code> 来保证外，还需要保证不会受到同处理器上其他核，或者其他处理器的影响。当其他核上执行的指令访问的内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。</p>
<p>在 <code>x86架构</code> 中，提供了指令前缀 <code>LOCK</code> 。<code>LOCK</code> 保证了指令不会受其他处理器或 <code>cpu</code> 核的影响。在 <code>PentiumPro</code> 之前，<code>LOCK</code> 的实现，是通过锁住 <code>bus</code> （总线），从而阻止其他 <code>cpu</code> 核的内存访问。可想而知，这种实现是非常低效的。从 <code>PentiumPro</code> 开始，<code>LOCK</code> 只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<p><img src="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg" alt="img"></p>
<p>现在，大多数的 <code>x86</code> 处理器都支持了 <code>CAS</code> 的硬件实现，保证了多处理器多核系统下的原子操作的正确性。<code>CAS</code> 的实现同样无需锁住总线，只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<hr>
<hr>
<h3><span id="原子操作">原子操作</span></h3><p>原子操作指的是不可再分的指令操作，即在执行原子操作时不可能被打断，要么原子操作没有执行，要么已经执行完毕。原子操作的实现必须需要硬件的支持，操作系统仅仅是在硬件指令的基础之上进行一次封装。对于没有实现原子操作的硬件，则需要操作系统从软件算法层面进行支持。</p>
<h4><span id="cas原子操作compare-and-swap">CAS原子操作(compare and swap)</span></h4><p>如果一个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是原子的(atomic)。</p>
<p><strong>为什么要有CAS：</strong>因为通过锁实现原子操作时，其他线程必须等待已经获得锁的线程运行完以后才能获得资源，这样就会占用系统的大量资源。<code>CAS</code> <strong>可以通过硬件层面的阻塞实现原子操作的安全</strong>。</p>
<p><code>CAS</code> 原子操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">    ATOMIC();</span><br><span class="line">    <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">    <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">    	*reg = newval;</span><br><span class="line">    END_ATOMIC();</span><br><span class="line">    <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了还有如下几个原子操作：</p>
<ul>
<li><strong>Fetch And Add：</strong>一般用来对变量做 <code>+1</code> 的原子操作。</li>
<li><strong>Test-and-set：</strong>写值到某个内存位置并传回其旧值。汇编指令 <code>BST</code> 。</li>
<li><strong>Test and Test-and-set</strong>：用来实现多核环境下相互排斥锁。</li>
</ul>
<p>C++11中的 <code>STL</code> 中的 <code>atomic</code> 类的函数能够跨平台使用。（完整的C++11的原子操作可參看 <a href="http://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">Atomic Operation Library</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( volatile std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br></pre></td></tr></table></figure>
<p>具体使用的时候可以如下实现无锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mutex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unlock = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">test_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!(__sync_bool_compare_and_swap (&amp;mutex,lock, <span class="number">1</span>) )) usleep(<span class="number">100000</span>);</span><br><span class="line">        count++;</span><br><span class="line">        __sync_bool_compare_and_swap (&amp;mutex, unlock, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="进程间如何通信">进程间如何通信？</span></h3><p><img src="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg" alt="6种Linux进程间的通信方式6种Linux进程间的通信方式"></p>
<h4><span id="应用场景">应用场景</span></h4><ol>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ol>
<p>现在 <code>Linux</code> 使用的进程间通信方式包括：</p>
<h4><span id="管道">管道</span></h4><p><strong>管道的概念</strong></p>
<ul>
<li>管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。</li>
<li>一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。</li>
<li><strong>数据被一个进程读出后，将被从管道中删除</strong>，其它读进程将不能再读到这些数据。</li>
<li>管道提供了简单的流控制机制，<strong>进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞</strong></li>
<li>管道包括<strong>无名管道</strong>和<strong>有名管道</strong>两种，前者<strong>用于父进程和子进程间的通信，后者可用于运行于同一系统中的任意两个进程间的通信</strong>。</li>
</ul>
<h5><span id="无名管道pipe">无名管道(pipe)</span></h5><p>无名管道是一种<strong>半双工</strong>的通信方式，数据只能<strong>单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系一般指的是父子关系。无明管道一般用于<strong>两个不同进程之间的通信</strong>。当一个进程创建了一个管道，并调用 <code>fork</code> 创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。</p>
<p><img src="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg" alt="这里写图片描述"></p>
<p>无名管道创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符(<strong>fd</strong>)：</p>
<ul>
<li><code>filedis[0]</code> 用于读管道。</li>
<li><code>filedis[1]</code> 用于写管道。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161031215306696" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20161031215332079" alt="img"></p>
<ul>
<li>管道通讯是<strong>单向</strong>的，有固定的<strong>读端和写端</strong>。</li>
<li>数据被进程从管道读出后，在管道中该数据就不存在了。</li>
<li>当进程去<strong>读取空管道</strong>的时候，进程会阻塞。</li>
<li>当进程<strong>往满管道写入数据</strong>时，进程会阻塞。</li>
<li>管道容量为 <strong>64KB</strong></li>
<li><strong>必须在系统调用fork( )前调用pipe( )，否则子进程将不会继承文件描述符</strong></li>
</ul>
<hr>
<h5><span id="有名管道fifo">有名管道(FIFO)</span></h5><p>有名管道和无名管道基本相同，但也有不同点：无名管道只能由父子进程使用；但是通过有名管道，<strong>不相关的进程也能交换数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_tmode)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>pathname：FIFO文件名</p>
</blockquote>
<blockquote>
<p>mode：属性（见文件操作章节）</p>
</blockquote>
<p><strong>一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO。</strong></p>
<hr>
<h4><span id="信号signal">信号(signal)</span></h4><ul>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
<hr>
<h4><span id="消息队列message-queue">消息队列(message queue)</span></h4><ul>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>
<li>消息队列<strong>克服了信号传递信息少</strong>、<strong>管道只能承载无格式字节流以及缓冲区大小受限</strong>等缺点。</li>
<li>消息队列 ( <code>message queue</code> )与 <code>PIPE</code> 相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符( <code>message_type</code> )。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照<strong>先进先出</strong>的顺序取出，也可以<strong>只取出符合某个识别符的消息</strong>(有多个这样的消息时，同样按照先进先出的顺序取出)。</li>
<li>消息队列与 <code>PIPE</code> 的另一个不同在于它并不使用文件 <code>API</code> 。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</li>
</ul>
<hr>
<h4><span id="共享内存shared-memory">共享内存(shared memory)</span></h4><ul>
<li>共享内存就是<strong>映射一段能被其他进程所访问的内存</strong>，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是⭐<strong>最快</strong>⭐的 <code>IPC(interprocess communication)</code> 方式，它是<strong>针对其他进程间通信方式运行效率低而专门设计</strong>的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<ul>
<li>共享内存与多线程共享 <code>global data</code> 和 <code>heap</code> 类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用 <code>semaphore</code> 同步，也可以在共享内存中建立 <code>mutex</code> 或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，<strong>不涉及内核的拷贝</strong>，所以它是效率最高的 <code>IPC</code> 方式。</li>
</ul>
</li>
</ul>
<hr>
<h4><span id="信号量semophore">信号量(semophore )</span></h4><ul>
<li>信号量是一个计数器，可以用来<strong>控制多个线程对共享资源的访问</strong>，它不是用于交换大批数据，而是用于多线程之间的同步。它常作为一种<strong>锁机制</strong>，防止某进程在访问资源时其它进程也访问该资源。因此，<strong>主要作为进程间以及同一个进程内不同线程之间的同步手段</strong>。</li>
<li>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法。比如在任一时刻只能有一个执行线程访问代码的<strong>临界区</strong>。临界区是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说<strong>信号量是用来调协进程对共享资源的访问的</strong>。</li>
<li>信号量是一个特殊的变量，程序对其访问都是<strong>原子操作</strong>，且只允许对它进行等待(<code>P(sv)</code>) 和发送(<code>V(sv)</code>)信息操作。最简单的信号量是只能取 <code>0</code> 和 <code>1</code> 的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。</li>
</ul>
<h5><span id="信号量工作原理">信号量工作原理</span></h5><p>由于信号量只能进行两种操作等待和发送信号，即 <code>P(sv)</code> 和 <code>V(sv)</code> ，他们的行为是这样的：</p>
<ul>
<li><strong>P(sv)等待：</strong>如果 <code>sv</code> 的值大于零，就给它减 <code>1</code> ；如果它的值为零，就<strong>挂起</strong>该进程的执行</li>
<li><strong>V(sv)发送：</strong>如果有其他进程因等待 <code>sv</code> 而被挂起，就让它恢复运行，如果没有进程因等待 <code>sv</code> 而挂起，就给它加 <code>1</code> 。</li>
</ul>
<p>举个例子，就是两个进程共享信号量 <code>sv</code> ，一旦其中一个进程执行了 <code>P(sv)</code> 操作，它将得到信号量，并可以进入临界区，使 <code>sv</code> 减1。而第二个进程将被阻止进入临界区，因为当它试图执行 <code>P(sv)</code> 时，<code>sv</code> 为 <code>0</code> ，它会被挂起以等待第一个进程离开临界区域并执行 <code>V(sv)</code> 释放信号量，这时第二个进程就可以恢复执行。</p>
<p>其实从意义上来说，<code>semaphore</code> 就是一个计数锁，它允许被 <code>N</code> 个进程获得。当有更多的进程尝试获得 <code>semaphore</code> 的时候，就必须等待有前面的进程释放锁。当 <code>N</code> 等于 <code>1</code> 的时候，<code>semaphore</code> 与 <code>mutex</code> 实现的功能就完全相同。许多编程语言也使用 <code>semaphore</code> 处理多线程同步的问题。一个 <code>semaphore</code> 会一直存在在内核中，直到某个进程删除它。</p>
<hr>
<h4><span id="套接字socket">套接字(socket)</span></h4><ul>
<li>套接字也是一种进程间通信机制，与其他通信机制不同的是，它<strong>可用于不同机器间的进程通信</strong>。</li>
</ul>
<hr>
<h3><span id="多线程间通信和同步">多线程间通信和同步</span></h3><hr>
<h3><span id="协程">⭐协程</span></h3><p><strong>什么是协程</strong></p>
<p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。在C++20中出现了<strong>coroutine</strong>的库。协程的作用是在同一个线程中通过保存代码执行段状态，进行代码段的分次执行，以及多个代码段的交织执行。每个代码段可以成为一个协程。协程的好处是<strong>避免了线程之间的频换切换</strong>、<strong>以及线程安全的优化</strong>（对于同一个变量的访问无需做同步控制）。</p>
<p><strong>协程是非抢占式的，线程是抢占式的。</strong></p>
<p>平时正常的程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。而协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg" alt="img"></p>
<p>协程不是被操作系统内核所管理的，而是<strong>完全由程序所控制</strong>，也就是在<strong>用户态</strong>执行。这样带来的好处是<strong>性能大幅度的提升</strong>，因为不会像线程切换那样消耗资源。</p>
<p>协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p>一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以有多个这样的特殊函数在运行，但是有一点必须明确的是：</p>
<blockquote>
<p><strong>一个线程的多个协程的运行是串行的</strong>。</p>
</blockquote>
<p>如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。<strong>当一个协程运行时，其它协程必须挂起</strong>。</p>
<p>C/C++ 语言本身是不能天然支持协程的。现有的 C++ 协程库均基于两种方案：<strong>利用汇编代码控制协程上下文的切换，以及利用操作系统提供的 API 来实现协程上下文切换</strong>。</p>
<p>在C++里，一个函数如果其函数体实现中包含 <code>co_await</code> 、<code>co_yield</code> 、<code>co_return</code> 中任何一个关键字，那么这个函数就是一个coroutine。其中：</p>
<ol>
<li><code>co_await</code>：挂起当前的coroutine。</li>
<li><code>co_return</code>：从当前coroutine返回一个结果。</li>
<li><code>co_yield</code>：返回一个结果并且挂起当前的coroutine。</li>
</ol>
<h4><span id="libco库">libco库</span></h4><ul>
<li><p><code>co_create_env()</code> 创建协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stStackMem_t</span> &#123;</span></span><br><span class="line">    stCoRoutine_t* occupy_co;  <span class="comment">// 使用该栈的协程</span></span><br><span class="line">    <span class="keyword">int</span> stack_size;            <span class="comment">// 栈大小</span></span><br><span class="line">    <span class="keyword">char</span>* stack_bp;            <span class="comment">// 栈底指针，栈从高地址向低地址增长</span></span><br><span class="line">    <span class="keyword">char</span>* stack_buffer;        <span class="comment">// 栈底</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_resume()</code> 激活协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">( stCoRoutine_t *co )</span> </span>&#123;</span><br><span class="line">    stCoRoutineEnv_t *env = co-&gt;env;</span><br><span class="line">    <span class="comment">// 获取当前正在运行的协程的结构</span></span><br><span class="line">    stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    <span class="keyword">if</span>( !co-&gt;cStart ) &#123;</span><br><span class="line">        <span class="comment">// 为将要运行的 co 布置上下文环境</span></span><br><span class="line">        coctx_make( &amp;co-&gt;ctx,(<span class="keyword">coctx_pfn_t</span>)CoRoutineFunc,co,<span class="number">0</span> );</span><br><span class="line">        co-&gt;cStart = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;pCallStack[ env-&gt;iCallStackSize++ ] = co;  <span class="comment">// 设置co为运行的线程</span></span><br><span class="line">    co_swap( lpCurrRoutine, co );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_swap()</code> 实现上下文切换，<code>co_swap</code> 具体完成三项工作：</p>
<ol>
<li>记录当前协程 <code>curr</code> 的运行栈的栈顶指针，通过 <code>char c; curr_stack_sp=&amp;c</code> 实现，当下次切换回 <code>curr</code>时，可以从该栈顶指针指向的位置继续，执行完 <code>curr</code> 后可以顺利释放该栈。</li>
<li>处理共享栈相关的操作，并且调用函数 <code>coctx_swap</code> 来完成上下文环境的切换。注意执行完 <code>coctx_swap</code>之后，执行流程将跳到新的 coroutine 也就是 pending_co 中运行，后续的代码需要等下次切换回 <code>curr</code> 时才会执行。</li>
<li>当下次切换回 <code>curr</code> 时，处理共享栈相关的操作。</li>
</ol>
</li>
<li><p>对应于 <code>co_resume</code> 函数，协程主动让出执行权则调用 <code>co_yield</code> 函数。<code>co_yield</code> 函数调用了 <code>co_yield_env</code>，将当前协程与当前线程中记录的其他协程进行切换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_env</span><span class="params">( stCoRoutineEnv_t *env )</span> </span>&#123;</span><br><span class="line">    stCoRoutine_t *last = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">2</span> ];</span><br><span class="line">    stCoRoutine_t *curr = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    env-&gt;iCallStackSize--;</span><br><span class="line">    co_swap( curr, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3><span id="selectpollepoll的区别">⭐Select/Poll/Epoll的区别</span></h3><hr>
<h4><span id="缺页中断">缺页中断</span></h4><hr>
<h2><span id="计算机网络">计算机网络</span></h2><h3><span id="udp和tcp的差别">⭐UDP和TCP的差别</span></h3><p><strong>UDP：</strong></p>
<ul>
<li><strong>无连接</strong>：减少了开销和发送前时延；</li>
<li><strong>尽最大努力交付</strong>：不保证可靠交付；</li>
<li><strong>面向报文</strong>：对应用层交下来的报文既不合并，也不拆分，保留这些报文的边界。</li>
<li><strong>没有拥塞控制</strong>：网络拥塞不会使源主机发送速率降低，允许在网络拥塞时丢失一些数据，却不允许数据有太大的时延。</li>
<li><strong>支持一对一、一对多、多对一、多对多的交互通信</strong></li>
<li><strong>首部开销小：</strong> 首部长度只有 8 字节，比 TCP 的 20 字节短。</li>
</ul>
<p><strong>TCP:</strong></p>
<ul>
<li><strong>面向连接：</strong> 传输前需建立连接，传输完成需释放连接；TCP 连接是一条<strong>逻辑连接</strong>。</li>
<li><strong>点对点：</strong> 每一条 TCP 连接只能有两个端点；</li>
<li><strong>提供可靠交付：</strong> 无差错、不丢失、不重复、不失序；</li>
<li><strong>全双工通信：</strong> 设有发送缓存和接收缓存，允许双方随时发送数据。</li>
<li><strong>面向字节流：</strong> TCP 把应用进程交下来的数据看作一连串的无结构字节流；</li>
</ul>
<hr>
<h3><span id="三次握手四次挥手">三次握手四次挥手</span></h3><hr>
<h3><span id="get和post的区别">get和post的区别</span></h3><hr>
<h3><span id="http状态码">HTTP状态码</span></h3><hr>
<h3><span id="计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</span></h3><ul>
<li><h4><span id="地址解析协议-arp">地址解析协议 ARP</span></h4></li>
</ul>
<p><img src="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png" alt="1568551356084"></p>
<ul>
<li><strong>APR 协议作用：</strong> 已经知道一个机器的 <strong>IP 地址</strong>，需要找出对应的<strong>硬件地址</strong>。<ul>
<li><strong>RARP 协议</strong>：现在的 DHCP 协议包含逆地址解析协议功能，即从<strong>硬件地址</strong>找出其 <strong>IP 地址</strong>。</li>
</ul>
</li>
<li><strong>ARP 协议工作原理：</strong> 网络层使用 IP 地址，但实际网络链路上传送数据帧时，最终必须使用该网络的硬件地址。ARP 解决方法是在<strong>主机 ARP 高速缓存</strong> 中存放一个从 IP 地址到硬件地址的映射表，并实时动态更新（新增或超时删除）。<ul>
<li>当主机 A 要向主机 B 发送 IP 数据报时，就在其 ARP 高速缓存中查看有无主机 B 的 IP 地址，如有就查找并<strong>写入 MAC 帧</strong>，并传输。</li>
<li>有可能查不到主机 B 的 IP 地址，可能主机 B 刚入网，可能主机 A 刚加电（高速缓存为空）。在这种情况下，主机 A 就自动运行 ARP，通过广播请求分组找出主机 B 的硬件地址。</li>
</ul>
</li>
<li><strong>ARP 协议工作流程：</strong><ol>
<li>主机 A 在本局域网上发送一个 ARP 请求分组，在本局域网上所有主机上运行的 ARP 进程都收到此请求分组。</li>
<li>主机 B 收下这个 ARP 请求，并向主机 A 发送响应分组（普通的单播，发送给主机 A ）。同时，把请求分组里 A 的 IP 地址到硬件地址的映射写入主机 B 的 ARP 高速缓存中。</li>
<li>主机 A 收到主机 B 的响应分组后，就在 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</li>
</ol>
</li>
<li><strong>ARP生存时间：</strong> 超过生存时间（例如 10 ~ 20 分钟）的项目从高速缓存中删掉。这样如果 B 更换了设备， A 无法找到原主机 B ，但过了一段时间， A 的 ARP 高速缓存中已经删除了 B 原先硬件地址，于是 A 重新广播发送 ARP请求分组，找到新的 B 硬件地址。</li>
</ul>
<hr>
<h3><span id="https的通信过程">⭐HTTPS的通信过程</span></h3><p>HTTPS是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用 <strong>SSL/TLS</strong> 来加密数据包。 HTTPS的通信过程，充分利用了各种加密算法及其特性。</p>
<hr>
<h3><span id="从浏览器输入网址到出现页面经过了哪些阶段">从浏览器输入网址到出现页面经过了哪些阶段</span></h3><ol>
<li><p><strong>输入网址</strong>：</p>
<p>URL的形式： schema://host:port/path?query#fragment</p>
<p>　　<code>-schema</code> : 协议，例如http , https,  ftp等</p>
<p>　　<code>-host</code> : 域名或者ip地址</p>
<p>　　<code>-port</code> ： 端口，http默认端口80，可以省略</p>
<p>　　<code>-path</code> ： 路径，例如/abc /a/b/c</p>
<p>　　<code>-query</code> : 查询参数，例如 token=sdfs2223fds2&amp;name=sdffaf</p>
<p>　　<code>-fragment</code> : 锚点（哈希Hash），用于定位页面的某个位置。</p>
<p>符合规则的URL</p>
<p>　　<a href="http://www.baidu.com/java/web?flag=1#function" target="_blank" rel="noopener">http://www.baidu.com/java/web?flag=1#function</a></p>
</li>
<li><p><strong>缓存解析</strong></p>
<p>浏览器获取了这个url，它先去缓存当中看看有没有，依次从浏览器缓存-&gt;系统缓存-&gt;路由器缓存当中查看，如果有从缓存当中显示页面，这样是不需要发送http请求的。如果没有那就进行步骤3。<br>缓存就是把之前访问的web资源，比如一些js，css，图片什么的保存在本机的内存或者磁盘当中。</p>
</li>
<li><p><strong>域名解析</strong></p>
<p>当缓存中没有这个url的时候，就需要发送http请求了，那么在发送http请求之前，需要先进行<strong>DNS解析</strong>将域名解析成 ip 地址。<strong>DNS解析</strong>存在着多级缓存：</p>
<ul>
<li>浏览器的DNS缓存</li>
<li>系统的DNS缓存</li>
<li>路由器的DNS缓存</li>
<li>网络运营商的DNS缓存（中国移动，中国电信）</li>
<li>上述都没有找到，则会采取递归的方式，向<strong>根服务器</strong>进行查询，根服务器告诉本地DNS服务器域服务器的地址，本地DNS向<strong>域服务器</strong>发出请求，域服务器告诉本地服务器<strong>域名解构服务器</strong>的地址，本地服务器向域名解构服务器发出请求，收到域名和IP的关系，本地服务器再返回给浏览器并将对应关系保存在缓存中以便下一次使用。</li>
</ul>
<hr>
<p><strong>DNS优化</strong></p>
<ul>
<li><strong>DNS缓存</strong><br>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li>
<li><strong>DNS负载均衡</strong><br>DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，</li>
</ul>
</li>
<li><p><strong>tcp链接，三次握手</strong></p>
<p>在域名解析之后，浏览器向服务器发起了http请求，tcp连接，三次握手建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接。</p>
<p>（1）客户端向服务器发送连接请求报文；<br>（2）服务器端接受客户端发送的连接请求后后回复ACK报文，并为这次连接分配资源。<br>（3）客户端接收到ACK报文后也向服务器端发生ACK报文，并分配资源。</p>
<p>这样TCP连接就建立了。<br>在此之后，浏览器开始向服务器发送http请求，请求数据包。请求信息包含一个头部和一个请求体。</p>
</li>
<li><p><strong>服务器收到请求</strong></p>
<p>服务器收到浏览器发送的请求信息，返回一个响应头和一个响应体。</p>
</li>
<li><p><strong>浏览器页面渲染</strong></p>
<ul>
<li>处理HTML标记并构建DOM树；</li>
<li>处理CSS标记并构建CSSDOM树；</li>
<li>将DOM和CSSOM合并为一颗渲染树；</li>
<li>根据渲染树来布局，以计算每个节点的几何信息(重排)</li>
<li>将各个结点绘制到屏幕上(重绘)</li>
<li>如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。</li>
</ul>
</li>
<li><p><strong>断开连接，四次挥手</strong></p>
</li>
</ol>
<hr>
<h3><span id="cache的结构与工作原理">Cache的结构与工作原理</span></h3><p><a href="https://blog.csdn.net/baidu_35679960/article/details/78610804" target="_blank" rel="noopener">https://blog.csdn.net/baidu_35679960/article/details/78610804</a></p>
<p>首先，要想理解cache，先理解内存。内存的简单表示如下图，内存里面的内容的查找是根据地址来进行的，也就是说内存包含两点①地址②内存的内容（存的数据），根据地址来找数据。</p>
<p><img src="https://img-blog.csdn.net/20171123102431734" alt="img"></p>
<hr>
<h3><span id="边缘触发和水平触发区别">边缘触发和水平触发区别</span></h3><p>边缘触发的IO应该怎么写？</p>
<hr>
<h2><span id="数据库">数据库</span></h2><h3><span id="mysql相关">Mysql相关</span></h3><p><strong>索引是个什么样的数据结构呢?</strong></p>
<p>索引的数据结构和具体存储引擎的实现有关, 在 <code>MySQL</code> 中使用较多的索引有 <code>Hash索引</code> ，<code>B+</code> 树索引等,而我们经常使用的 <code>InnoDB</code> 存储引擎的默认索引实现为：<code>B+</code> 树索引。</p>
<ul>
<li><code>hash索引</code> 底层就是 <code>hash表</code> ，进行查找时，调用一次 <code>hash</code> 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。<code>B+</code> 树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
<li><code>hash索引</code> 进行等值查询更快(一般情况下)，但是却<strong>无法进行范围查询</strong>。因为在 <code>hash索引</code> 中经过 <code>hash函数</code> 建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询；而 <code>B+树</code> 的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似)，天然支持范围。</li>
<li><code>hash索引</code> 任何时候都避免不了<strong>回表查询数据</strong>，而 <code>B+树</code> 在符合某些条件(<strong>聚簇索引</strong>，<strong>覆盖索引</strong>等)的时候可以只通过索引完成查询。</li>
</ul>
<hr>
<p><strong>上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?</strong></p>
<p>在 <code>B+树</code> 的索引中，叶子节点可能存储了当前的 <code>key</code> 值，也可能存储了当前的 <code>key</code> 值以及整行的数据，这就是<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。在 <code>InnoDB</code> 中，只有<strong>主键索引</strong>是<strong>聚簇索引</strong>，如果没有主键，则挑选一个唯一键建立聚簇索引.如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<p>事务特性</p>
<ul>
<li>持久型数据库怎么实现的</li>
<li>数据库有哪几种日志</li>
<li>分布式下还能满足ACID吗</li>
<li>数据库有哪几种锁</li>
<li>联合索引知道吗</li>
</ul>
<h2><span id="其他">其他</span></h2><h3><span id="从两个文件各含50亿个url中找出共同的url">从两个文件(各含50亿个url)中找出共同的url</span></h3><blockquote>
<p>给定a、b两个文件，各存放50亿个url，每个url各占用64字节，内存限制是4G，如何找出a、b文件共同的url？</p>
</blockquote>
<p>可以估计每个文件的大小为 <code>5G*64=300G</code> ，远大于 <code>4G</code> 。所以不可能将其完全加载到内存中处理。考虑采取<strong>分而治之</strong>的方法。<br>遍历文件 <code>a</code> ，对每个 <code>url</code> 求取 <code>hash(url)%1000</code>，然后根据所得值将 <code>url</code> 分别存储到 <code>1000</code> 个小文件（设为<code>a0,a1,...a999</code> ）当中。这样每个小文件的大小约为 <code>300M</code> 。遍历文件 <code>b</code> ，采取和 <code>a</code> 相同的方法将 <code>url</code> 分别存储到 <code>1000</code> 个小文件(<code>b0,b1....b999</code>)中。这样处理后，所有可能相同的 <code>url</code> 都在对应的小文件( <code>a0 vs b0, a1 vs b1....a999 vs b999</code> )当中，不对应的小文件（比如 <code>a0 vs b99</code> ）不可能有相同的url。然后我们只要求出 <code>1000</code> 对小文件中相同的 <code>url</code> 即可。<br>比如对于 <code>a0 vs b0</code> ，我们可以遍历 <code>a0</code> ，将其中的 <code>url</code> 存储到 <code>hash_map</code> 当中。然后遍历 <code>b0</code> ，如果 <code>url</code> 在 <code>hash_map</code> 中，则说明此 <code>url</code> 在 <code>a</code> 和 <code>b</code> 中同时存在，保存到文件中即可。<br>如果分成的小文件不均匀( <code>hash</code> 的问题)，导致有些小文件太大（比如大于 <code>2G</code> ），可以考虑将这些太大的小文件再按类似的方法分成小小文件即可。</p>
<hr>
<p> 无名管道和有名管道的区别</p>
<p>CAS（compare and swap）</p>
<p>cache的结构，工作原理详细介绍一下，组相联是什么概念。</p>
<p>虚拟地址到物理地址的转换过程</p>
<p>水平触发和边缘触发</p>
<p>一致性哈希算法</p>
<p> 编译型语言和解释型语言的区别 </p>
<p> socket通信为什么不用网络，而用本地 </p>
<p> 进程间通信的方式（你用这个的时候，你是怎么考虑的，为什么要用这个方式） </p>
<p> 说一下epoll </p>
<p> 多线程间通信和同步 </p>
<p> STL底层内存分配 </p>
<p> 问为什么windows vector是1.5倍，linux是2倍 </p>
<p> 协程的原理和具体的操作，以及跟线程的区别 </p>
<p> 协程的创建受什么影响 </p>
<p> 会原子操作吗 </p>
<p> 编译型语言和解释型语言的区别 </p>
<p> 如何把UDP变得可靠起来 </p>
<p> 了解一些中间件吗(说了一大堆，我都不会，我很绝望) </p>
<p> 说一下QUIC </p>
<p> 共享内存如何把一颗二叉树给读出来 </p>
<p> 12个瓶子，其中有一个不知道轻重，你如何查出来 </p>
<p> 某个线程CPU占比高，你如何排查出问题</p>
<p>RALL机制 </p>
<p> 四大智能指针 </p>
<p> weak_ptr为什么可以解决循环引用，底层怎么实现的，然后又讨论了一下一些应用场景和坑点 </p>
<p> 智能指针是线程安全的吗（这里，我崩了，我项目涉及多线程，我居然不能回答好这个问题，后面也因为这个问题导致了面试官对我的印象很不友好） </p>
<p> 说一下Reactor模式。 </p>
<p> Reactor模式是半同步半异步的吗（是的） </p>
<p> 那你还知道别的模式吗（本来想说proactor，但是英语太差，说不出来，只是说了个P字头的，然后面试官也知道我英语菜鸡。。） </p>
<p> 说一下怎么优化Reactor </p>
<p> 定时器是怎么做的。 </p>
<p> 说一下四次挥手，说完并且也说出来全双工，然后问我timewait，回答出来2msl和作用后又问我过多timewait会产生什么影响，这里回答的不太好，主要是有点忘记了，又问我怎么处理，我说修改linux内核的一些设置，面试官不太满意，提示我socket怎么处理，想起来是某个参数，但是我记不住呀，由此面试官可以看出来我网络编程凉凉。 </p>
<p> QUIC解决了什么问题（我答非所问） </p>
<p> 算法题：有100万个数字，求前K个数字 </p>
<p> 说一下堆排序</p>
<p>TCP发包发很大导致分包，如何怎么处理（面试官还结合ET和LT的区别来问）</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面经/" rel="tag"># 面经</a>
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/17/1030. 距离顺序排列矩阵单元格/" rel="next" title="Leetcode_1030 距离顺序排列矩阵单元格">
                <i class="fa fa-chevron-left"></i> Leetcode_1030 距离顺序排列矩阵单元格
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/01/705. 设计哈希集合/" rel="prev" title="Leetcode_705 设计哈希集合">
                Leetcode_705 设计哈希集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">334</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">后台开发面经汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.</span> <span class="nav-text">C++线程中的几种锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">互斥锁(Mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">条件锁(condition_variable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">自旋锁(spinlock_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">读写锁(shared_mutex)/共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">递归锁(recursive_mutex)/可重入锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.</span> <span class="nav-text">C++中thread操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">detach()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.</span> <span class="nav-text">C++多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">多态有哪几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">虚函数的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">为什么析构函数必须是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">为什么C++默认的析构函数不是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">为什么构造函数不能是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">静态成员及静态成员函数能不能被继承？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.8.</span> <span class="nav-text">友元可以继承吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.9.</span> <span class="nav-text">多态中构造函数/析构函数调用顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.10.</span> <span class="nav-text">类成员函数中重载/重写/隐藏的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.11.</span> <span class="nav-text">钻石继承问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.</span> <span class="nav-text">C++的四种cast</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">哪种cast更加接近C的强制类型转换？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.</span> <span class="nav-text">C++智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">auto_ptr(弃用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">unique_ptr(替换auto_ptr)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">智能指针是线程安全的吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">Hash Map冲突如何解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">Unordered_map和map底层实现有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.2.1.</span> <span class="nav-text">map底层数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.2.2.</span> <span class="nav-text">为什么用红黑树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.2.3.</span> <span class="nav-text">红黑树查询效率为什么快</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">vector相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.3.1.</span> <span class="nav-text">vector空间的动态增长</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.3.2.</span> <span class="nav-text">vector底层数据结构，vector底层是如何删除元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.</span> <span class="nav-text">类模板和模板类的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.8.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.9.</span> <span class="nav-text">Volitale关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.10.</span> <span class="nav-text">std::move语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.11.</span> <span class="nav-text">三个线程交替打印</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.1.</span> <span class="nav-text">Linux的内存不足时会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.2.</span> <span class="nav-text">⭐进程和线程的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.3.</span> <span class="nav-text">临界区(进程同步)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.4.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">CAS原子操作(compare and swap)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.</span> <span class="nav-text">进程间如何通信？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.2.1.</span> <span class="nav-text">无名管道(pipe)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.2.2.</span> <span class="nav-text">有名管道(FIFO)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">信号(signal)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">消息队列(message queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">共享内存(shared memory)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">信号量(semophore )</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.6.1.</span> <span class="nav-text">信号量工作原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">套接字(socket)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.6.</span> <span class="nav-text">多线程间通信和同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.7.</span> <span class="nav-text">⭐协程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">libco库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.</span> <span class="nav-text">⭐Select/Poll/Epoll的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">缺页中断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">⭐UDP和TCP的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.</span> <span class="nav-text">三次握手四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.</span> <span class="nav-text">get和post的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.5.</span> <span class="nav-text">计算机网络是如何根据IP地址定位到一台主机的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">地址解析协议 ARP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.6.</span> <span class="nav-text">⭐HTTPS的通信过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.7.</span> <span class="nav-text">从浏览器输入网址到出现页面经过了哪些阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.8.</span> <span class="nav-text">Cache的结构与工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.9.</span> <span class="nav-text">边缘触发和水平触发区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.</span> <span class="nav-text">Mysql相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.1.</span> <span class="nav-text">从两个文件(各含50亿个url)中找出共同的url</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
