<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,C++,">










<meta name="description" content="C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;gt;     C++">
<meta name="keywords" content="基础知识,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础总结">
<meta property="og:url" content="http://chenqi1997.github.io/2020/12/22/C++基础总结/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;gt;     C++">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-da022f1196cfbe2f439a21cd64208e10_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-fc1fb96508a363b17d1bb7737dc51e54_720w.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20180520012305597">
<meta property="og:image" content="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:updated_time" content="2020-12-29T04:05:03.701Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++基础总结">
<meta name="twitter:description" content="C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;gt;     C++">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/12/22/C++基础总结/">





  <title>C++基础总结 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/12/22/C++基础总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++基础总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-22T17:46:00+08:00">
                2020-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#c基础">C++基础</a><ul>
<li><a href="#c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</a><ul>
<li><a href="#互斥锁mutex">互斥锁(Mutex)</a></li>
<li><a href="#条件变量condition_variable">条件变量(condition_variable)</a></li>
<li><a href="#自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</a></li>
<li><a href="#读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</a></li>
<li><a href="#递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</a></li>
<li><a href="#定时锁time_mutex">定时锁(time_mutex)</a></li>
<li><a href="#两种基本的锁类型">两种基本的锁类型</a><ul>
<li><a href="#条件变量中只能使用unique_lock-stdmutex">条件变量中只能使用unique_lock&lt; std::mutex &gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c中原子类型">C++中原子类型</a></li>
<li><a href="#c中thread操作">C++中thread操作</a><ul>
<li><a href="#stdthread构造">std::thread构造</a></li>
<li><a href="#join">join()</a></li>
<li><a href="#detach">detach()</a></li>
<li><a href="#wait成员函数">wait()成员函数</a></li>
<li><a href="#wait_for成员函数">wait_for()成员函数</a></li>
<li><a href="#notify_allnotify_one">notify_all/notify_one</a></li>
<li><a href="#虚假唤醒">虚假唤醒</a></li>
</ul>
</li>
<li><a href="#c多态">C++多态</a><ul>
<li><a href="#多态有哪几种">多态有哪几种？</a></li>
<li><a href="#虚函数的实现">虚函数的实现</a></li>
<li><a href="#动态绑定">动态绑定</a></li>
<li><a href="#为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</a></li>
<li><a href="#为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</a></li>
<li><a href="#为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</a></li>
<li><a href="#静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</a></li>
<li><a href="#友元可以继承吗">友元可以继承吗？</a></li>
<li><a href="#虚函数virtual可以是内联函数inline吗">虚函数(virtual)可以是内联函数(inline)吗？</a></li>
<li><a href="#多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</a></li>
<li><a href="#类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</a></li>
<li><a href="#钻石继承问题">钻石继承问题</a></li>
</ul>
</li>
<li><a href="#c的四种cast">C++的四种cast</a><ul>
<li><a href="#static_cast">static_cast</a></li>
<li><a href="#const_cast">const_cast</a></li>
<li><a href="#reinterpret_cast">reinterpret_cast</a></li>
<li><a href="#dynamic_cast">dynamic_cast</a></li>
<li><a href="#哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</a></li>
</ul>
</li>
<li><a href="#c智能指针">C++智能指针</a><ul>
<li><a href="#auto_ptr弃用">auto_ptr(弃用)</a></li>
<li><a href="#unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
<li><a href="#weak_ptr">weak_ptr</a></li>
<li><a href="#智能指针是线程安全的吗">智能指针是线程安全的吗？</a></li>
</ul>
</li>
<li><a href="#c对象的内存模型">C++对象的内存模型</a><ul>
<li><a href="#普通对象模型">普通对象模型</a></li>
<li><a href="#派生类的对象模型">派生类的对象模型</a></li>
<li><a href="#vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</a></li>
</ul>
</li>
<li><a href="#volitale关键字">Volitale关键字</a><ul>
<li><a href="#volatile指针">volatile指针</a></li>
<li><a href="#可见性">可见性</a><ul>
<li><a href="#什么是可见性">什么是可见性？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c中指针和引用的区别">C++中指针和引用的区别</a></li>
<li><a href="#c中new与malloc的区别">C++中new与malloc的区别</a></li>
<li><a href="#c-内存对齐">C++ 内存对齐</a></li>
<li><a href="#c存储类型">C++存储类型</a><ul>
<li><a href="#auto-自动变量">auto 自动变量</a></li>
<li><a href="#register-寄存器变量">register 寄存器变量</a></li>
<li><a href="#static-关键字">static 关键字</a></li>
<li><a href="#extern关键字">extern关键字</a></li>
<li><a href="#mutable-存储类">mutable 存储类</a></li>
<li><a href="#thread_local-存储类">thread_local 存储类</a></li>
</ul>
</li>
<li><a href="#stdmove语义">std::move()语义</a></li>
<li><a href="#右值引用">右值引用</a><ul>
<li><a href="#左值引用">左值引用</a></li>
<li><a href="#右值引用-1">右值引用</a></li>
<li><a href="#右值引用有办法指向左值吗">右值引用有办法指向左值吗</a></li>
<li><a href="#完美转发-stdforward">完美转发 std::forward()</a></li>
<li><a href="#auto也是这个意思">auto&amp;&amp;也是这个意思</a></li>
</ul>
</li>
<li><a href="#c内联函数">C++内联函数</a><ul>
<li><a href="#内联函数有什么优点">内联函数有什么优点？</a></li>
<li><a href="#缺点">缺点</a></li>
<li><a href="#将内联函数放入头文件">将内联函数放入头文件</a></li>
<li><a href="#内联函数与宏定义的区别">内联函数与宏定义的区别？</a></li>
<li><a href="#explicit关键字">explicit关键字</a></li>
<li><a href="#union-联合体">union 联合体</a></li>
</ul>
</li>
<li><a href="#深拷贝与浅拷贝">深拷贝与浅拷贝</a></li>
<li><a href="#必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</a></li>
<li><a href="#定位内存泄露及检测">定位内存泄露及检测</a></li>
<li><a href="#手写strcpymemcpystrcatstrcmp等函数">手写strcpy，memcpy，strcat，strcmp等函数</a><ul>
<li><a href="#strcpy">strcpy</a></li>
<li><a href="#memcpy">memcpy</a></li>
<li><a href="#strlen">strlen</a></li>
<li><a href="#strcat">strcat</a></li>
<li><a href="#strcmp">strcmp</a></li>
</ul>
</li>
<li><a href="#memmove">memmove</a></li>
<li><a href="#手写单例模式">手写单例模式</a></li>
<li><a href="#三个线程交替打印">三个线程交替打印</a></li>
<li><a href="#类模板和模板类的区别">类模板和模板类的区别？</a></li>
<li><a href="#海量数据问题">海量数据问题</a><ul>
<li><a href="#十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</a></li>
<li><a href="#十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</a></li>
</ul>
</li>
<li><a href="#布隆过滤器">布隆过滤器</a><ul>
<li><a href="#什么情况下需要布隆过滤器">什么情况下需要布隆过滤器？</a></li>
<li><a href="#布隆过滤器的原理">布隆过滤器的原理。</a></li>
<li><a href="#位图bitmap">位图(bitmap)</a></li>
<li><a href="#布隆过滤器大小计算">布隆过滤器大小计算</a></li>
<li><a href="#布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</a></li>
</ul>
</li>
<li><a href="#stl">STL</a><ul>
<li><a href="#hash-map冲突如何解决">Hash Map冲突如何解决？</a><ul>
<li><a href="#哈希函数">哈希函数</a></li>
<li><a href="#哈希冲突解决方案">哈希冲突解决方案</a></li>
</ul>
</li>
<li><a href="#hash_map扩容发生什么">Hash_map扩容发生什么</a></li>
<li><a href="#unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</a><ul>
<li><a href="#map与unordered_map的区别">map与unordered_map的区别</a></li>
<li><a href="#为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？红黑树查询效率为什么快？</a></li>
</ul>
</li>
<li><a href="#为何map和set的插入删除效率比用其他序列容器高">为何map和set的插入删除效率比用其他序列容器高？</a><ul>
<li><a href="#为什么每次insert之后以前保存的iterator不会失效">为什么每次insert之后，以前保存的iterator不会失效</a></li>
</ul>
</li>
<li><a href="#vector相关">vector相关</a><ul>
<li><a href="#vector空间的动态增长">vector空间的动态增长</a></li>
<li><a href="#vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</a></li>
</ul>
</li>
<li><a href="#stl里的内存池实现">STL里的内存池实现</a><ul>
<li><a href="#内存的分配和回收">内存的分配和回收</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h2><span id="c基础">C++基础</span></h2><h3><span id="c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</span></h3><p>C++线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong> 这几种。需要在进入临界区之前对互斥量 <code>lock</code> ，退出临界区时对互斥量 <code>unlock</code> ；当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。</p>
<h4><span id="互斥锁mutex">互斥锁(Mutex)</span></h4><p>互斥锁用于<strong>控制多个线程对他们之间共享资源互斥访问的一个信号量</strong>。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。</p>
<p>在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以<strong>阻塞方式</strong>进行等待。</p>
<p><strong>互斥锁是是一种sleep-waiting的锁</strong>。假设线程 <code>T1</code> 获取互斥锁并且正在 <code>core1</code> 上运行时，此时线程 <code>T2</code> 也想要获取互斥锁 (pthread_mutex_lock)，但是由于 <code>T1</code> 正在使用互斥锁使得 <code>T2</code> 被阻塞。当 <code>T2</code> 处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器 <code>core2</code> 会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p>
<p><strong>用法：</strong>在C++中，通过构造 <code>std::mutex</code> 的实例创建互斥元，调用成员函数 <code>lock()</code> 来锁定它，调用 <code>unlock()</code> 来解锁，不过一般不推荐这种做法，标准C++库提供了std::lock_guard类模板，实现了互斥元的 <code>RAII</code> 惯用语法。<code>std::mutex</code> 和 <code>std::lock_guard</code> 。都声明在 <code>&lt;mutex&gt;</code> 头文件中。</p>
<p><code>lock_guard</code> 对象通常用于管理某个锁(Lock)对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用互斥元保护列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list;</span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(some_mutex);</span><br><span class="line">    some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="条件变量condition_variable">条件变量(condition_variable)</span></h4><p>条件锁就是所谓的条件变量，某一个线程因为某个条件<strong>未满足</strong>时可以使用 <code>条件锁</code> 使该程序处于 <code>阻塞状态</code> 。</p>
<p>一旦条件满足，可以以 <code>信号量</code> 的方式唤醒一个因为该条件而被阻塞的线程。</p>
<p>条件变量的作用不是用来管理互斥量的，它的作用是用来<strong>同步线程</strong>，它的用法相当于编程中常见的 <code>flag</code> 标志（A、B两个人约定 <code>flag=true</code> 为行动号角，默认 <code>flag</code> 为 <code>false</code> ，A不断的检查 <code>flag</code> 的值,只要 <code>B</code> 将 <code>flag</code> 修改为 <code>true</code> ，<code>A</code> 就开始行动）。类比到 <code>condition_variable</code>，A、B两个人约定 <code>notify_one</code> 为行动号角，<code>A</code>就等着（调用 <code>wait()</code> ，阻塞）,只要 <code>B</code> 一调用 <code>notify_one</code> ，A就开始行动（不再阻塞）。</p>
<p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为 <code>任务队列为空</code> 这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用std::condition_variable等待数据</span></span><br><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);   <span class="comment">//这里使用unique_lock是为了后面方便解锁</span></span><br><span class="line">        data_cond.wait(lk,&#123;[]<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面，<code>wait()</code> 的实现接下来检查条件，并在满足时返回。如果条件不满足，wait()解锁互斥元，并将该线程置于阻塞或等待状态。当来自数据准备线程中对 <code>notify_one()</code> 的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从wait()返回值，互斥元仍被锁定。如果条件不满足，该线程解锁互斥元，并恢复等待。</p>
<hr>
<h4><span id="自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</span></h4><p><em>自旋锁需要与互斥锁一起来比较理解。</em></p>
<p><strong>自旋锁是一种busy-waiting的锁</strong>。也就是说，如果 <code>T1</code> 正在使用自旋锁，而 <code>T2</code> 也去申请这个自旋锁，此时 <code>T2</code> 肯定得不到这个自旋锁。与互斥锁相反的是，此时运行 <code>T2</code> 的处理器 <code>core2</code> 会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p>
<p>从 <code>自旋锁</code> 的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一直占用 <code>CPU</code> 请求这个自旋锁使得 <code>CPU</code> 不能去做其他的事情，直到获取这个锁为止，这就是 <code>自旋</code> 的含义。</p>
<p>当发生阻塞时，互斥锁可以让 <code>CPU</code> 去处理其他的任务；而自旋锁让 <code>CPU</code> 一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道 <code>自旋锁</code> 是比较耗费 <code>CPU</code> 的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(<span class="keyword">spinlock_t</span> *x);<span class="comment">//初始化</span></span><br><span class="line">spin_lock(x);   			  <span class="comment">//只有在获得锁的情况下才返回，否则一直“自旋”</span></span><br><span class="line">spin_trylock(x);  			  <span class="comment">//如立即获得锁则返回真，否则立即返回假</span></span><br><span class="line">spin_unlock(x);				  <span class="comment">//释放锁</span></span><br><span class="line">spin_is_locked(x)			  <span class="comment">//该宏用于判断自旋锁x是否已经被某执行单元保持（即被锁），如果是，   返回真，否则返回假。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</span></h4><p><code>std::shared_mutex</code>有两种访问级别：</p>
<ul>
<li><strong>共享：</strong>多个线程可以共享这个锁的拥有权。一般用于数据的<strong>读操作</strong>，防止数据被写修改。</li>
<li><strong>互斥：</strong>仅仅一个线程可以拥有这个锁。一般用于<strong>写操作</strong>。</li>
<li>如果一个线程已经获取了 <code>互斥锁</code> ，则其他线程都无法获取该锁。</li>
<li>如果一个线程已经获取了 <code>共享锁</code> ，则其他任何线程都无法获取 <code>互斥锁</code> ，但是可以获取 <code>共享锁</code> 。</li>
</ul>
<hr>
<h4><span id="递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</span></h4><p>我们都知道，一般的互斥量对于同一个线程只能同时加锁一次（调用 <code>lock</code> ），如果连续调用两次以上便会出现死锁。但设想这样一个场景，如果在一个函数内给互斥量上了锁还没有解开，然后又调用了另一个函数，这个被调用的函数也去给互斥量上锁，这种情境下就会出现死锁。</p>
<p>对于互斥锁，分为递归锁和非递归锁。在不同的线程中调用已锁定的互斥锁，必然会导致死锁。但是在<strong>同一个线程中，如果想要多次获得一个锁，只能使用递归锁</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MutexLock mutex;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    mutex.unlock();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    foo();  </span><br><span class="line">    mutex.unlock();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，引入了递归锁的概念。</p>
<p><strong>递归锁</strong>，顾名思义，<strong>如果因为多次函数调用而导致出现多次上锁的情况，只有第一次会去真正加锁，后面的加锁操作会被自动忽略。</strong></p>
<p><strong>recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁）</strong>，来获得对互斥量对象的<strong>多层所有权</strong>，<code>recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和 <code>unlock()</code> 次数相同，除此之外，<code>recursive_mutex</code> 的特性和<code>mutex</code> 大致相同。</p>
<hr>
<h4><span id="定时锁time_mutex">定时锁(time_mutex)</span></h4><p><code>std::time_mutex</code> 比 <code>std::mutex</code> 多了两个成员函数，<code>try_lock_for()</code> ，<code>try_lock_until()</code> 。</p>
<p><strong>try_lock_for</strong> 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 <code>std::mutex</code> 的 <code>try_lock()</code> 不同，<code>try_lock</code> 如果被调用时没有获得锁则直接返回 <code>false</code>），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code>。</p>
<p><strong>try_lock_until</strong> 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code> 。</p>
<hr>
<h4><span id="两种基本的锁类型">两种基本的锁类型</span></h4><p>C++11 标准为我们提供了两种基本的锁类型，分别如下：</p>
<ul>
<li><strong>std::lock_guard</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁。<ul>
<li><strong>lock_guard</strong> 对象通常用于管理某个锁( <code>Lock</code> )对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源 )。</li>
<li>在 <code>lock_guard</code> 对象构造时，传入的 <code>Mutex</code> 对象(即它所管理的 <code>Mutex</code> 对象)会被<strong>当前线程</strong>锁住。在<code>lock_guard</code> 对象被析构时，它所管理的 <code>Mutex</code> 对象会自动解锁，由于不需要程序员手动调用 <code>lock</code> 和 <code>unlock</code> 对 <code>Mutex</code> 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 <code>Mutex</code> 对象可以正确进行解锁操作，极大地简化了程序员编写与 <code>Mutex</code> 相关的异常处理代码。</li>
<li>值得注意的是，<code>lock_guard</code> 对象并不负责管理 <code>Mutex</code> 对象的生命周期，<code>lock_guard</code> 对象只是简化了 <code>Mutex</code> 对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁。</li>
</ul>
</li>
<li><strong>std::unique_lock</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。<ul>
<li><strong>unique_lock</strong> 提供了更好的上锁和解锁控制。顾名思义，<code>unique_lock</code> 对象以独占所有权的方式(unique owership)管理 <code>mutex</code> 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权。</li>
<li>在构造(或移动(move)赋值)时，<code>unique_lock</code> 对象需要传递一个 <code>Mutex</code> 对象作为它的参数，新创建的 <code>unique_lock</code> 对象负责传入的 <code>Mutex</code> 对象的上锁和解锁操作。</li>
</ul>
</li>
</ul>
<h5><span id="条件变量中只能使用unique_locklt-stdmutex-gt">条件变量中只能使用unique_lock&lt; std::mutex &gt;</span></h5><p><code>unique_lock</code> 和 <code>lock_guard</code> 都是管理锁的辅助类工具，都是 <code>RAII(资源定义即初始化)</code> 风格；它们是在定义时获得锁，在析构时释放锁。它们的主要区别在于 <code>unique_lock</code> 锁机制更加灵活，可以再需要的时候进行 <code>lock</code> 或者 <code>unlock</code> 调用，不非得是析构或者构造时。它们的区别可以通过成员函数就可以一目了然。</p>
<hr>
<h3><span id="c中原子类型">C++中原子类型</span></h3><p><strong>std::atomic&lt;&gt;</strong>是一个模板类，使用该模板类实例化的对象，提供了<strong>一些保证原子性的成员函数</strong>来实现共享数据的常用操作。</p>
<p>可以这样理解： 在以前，定义了一个共享的变量 <code>int i=0</code>，多个线程会用到这个变量，那么每次操作这个变量时，都需要 <code>lock</code> 加锁，操作完毕 <code>unlock</code> 解锁，以保证线程之间不会冲突；但是这样每次加锁解锁、加锁解锁就显得很麻烦，那怎么办呢？ 现在，实例化了一个类对象 <code>std::atomic&lt;int&gt; I=0</code> 来代替以前的那个变量（这里的对象 <code>I</code> 你就把它看作一个变量，看作对象反而难以理解了），每次操作这个对象时，就不用 <code>lock</code> 与 <code>unlock</code> ，这个对象自身就具有原子性（相当于加锁解锁操作不用你写代码实现，能自动加锁解锁了），以保证线程之间不会冲突。</p>
<hr>
<h3><span id="c中thread操作">C++中thread操作</span></h3><h4><span id="stdthread构造">std::thread构造</span></h4><table>
<thead>
<tr>
<th>default (1)</th>
<th>thread() noexcept;</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialization (2)</td>
<td>template <class fn,="" class...="" args=""> explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;… args);</class></td>
</tr>
<tr>
<td>copy [deleted] (3)</td>
<td>thread (const thread&amp;) = delete;</td>
</tr>
<tr>
<td>move (4)</td>
<td>thread (thread&amp;&amp; x) noexcept;</td>
</tr>
</tbody>
</table>
<ol>
<li>默认构造函数，创建一个空的 thread 执行对象。</li>
<li>初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</li>
<li>拷贝构造函数(被禁用)，意味着 <strong>thread 不可被拷贝构造</strong>。只能用<strong>右值引用配合move赋值操作</strong>。</li>
<li>move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。</li>
</ol>
<p>注意：可被 <code>joinable</code> 的 <code>thread</code> 对象必须在他们销毁之前被主线程 <code>join</code> 或者将其设置为 <code>detached</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(<span class="built_in">std</span>::move(t3))</span></span>; <span class="comment">// t4 is now running f2(). t3 is no longer a thread</span></span><br></pre></td></tr></table></figure>
<h4><span id="join">join()</span></h4><ul>
<li>阻塞主线程，直至 <code>this</code> 所标识的线程完成其执行。<code>this</code> 所标识的线程的完成同步于从 <strong>join()</strong> 的成功返回。</li>
<li>该方法简单暴力，主线程等待子进程期间什么都不能做。<code>thread::join()</code> 会清理子线程相关的内存空间，此后<code>thread object</code> 将不再和这个子线程相关了，即 <code>thread object</code> 不再 <code>joinable</code> 了，所以 <code>join</code> 对于一个子线程来说只可以被调用一次，为了实现更精细的线程等待机制，可以使用条件变量等机制。</li>
</ul>
<h4><span id="detach">detach()</span></h4><ul>
<li>从调用线程中分离出对象所代表的线程，从而使它们彼此独立执行。两个线程继续运行，而不会阻塞或以任何方式进行同步。</li>
<li>请注意，当任何一个执行结束时，其资源将被释放。</li>
<li>调用此函数后，线程对象变得不可连接，并且可以安全地销毁。</li>
<li>使用 <code>detach</code> ，那么新线程就会与原线程分离，如果原线程先执行完毕，销毁线程对象及局部变量，并且<strong>新线程有共享变量或引用</strong>之类，这样新线程可能使用的变量，就变成未定义，产生异常或不可预测的错误。</li>
</ul>
<h4><span id="wait成员函数">wait()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock )</span></span>;</span><br><span class="line"><span class="comment">//Predicate 谓词函数，可以普通函数或者lambda表达式</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );</span><br></pre></td></tr></table></figure>
<p><code>wait</code>  导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，可选地循环<strong>直至满足某谓词</strong>。条件变量的wait所必须是<strong>unique_lock而</strong>不是lock_guard，因为wait会在内部调用<strong>unique_lock.unlock</strong>先解锁，当被唤醒后，条件满足时，会<strong>unique_lock.lock</strong></p>
<h4><span id="wait_for成员函数">wait_for()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function">cv_status <span class="title">wait_for</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span>, <span class="title">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">wait_for</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span><br><span class="line">               <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span><br><span class="line">               Predicate pred);</span><br></pre></td></tr></table></figure>
<p><code>wait_for</code> 导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，或者<strong>超时返回</strong>。</p>
<p>以上两个类型的<strong>wait函数都在会阻塞时，自动释放锁权限，即调用unique_lock的成员函数unlock（），以便其他线程能有机会获得锁</strong>。这就是条件变量只能和 <code>unique_lock</code> 一起使用的原因，否则当前线程一直占有锁，线程被阻塞。</p>
<h4><span id="notify_allnotify_one">notify_all/notify_one</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则解阻塞（唤醒)全部等待线程。</span></span><br></pre></td></tr></table></figure>
<h4><span id="虚假唤醒">虚假唤醒</span></h4><p>在正常情况下，<code>wait</code> 类型函数返回时要不是因为被唤醒，要不是因为超时才返回，但是在实际中发现，因此操作系统的原因，<code>wait</code> 类型在不满足条件时，它也会返回，这就导致了虚假唤醒。因此，我们一般都是使用带有谓词参数的 <code>wait</code> 函数，因为这种<code>(xxx, Predicate pred )</code>类型的函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!(xxx条件) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//虚假唤醒发生，由于while循环，再次检查条件是否满足，</span></span><br><span class="line">    <span class="comment">//否则继续等待，解决虚假唤醒</span></span><br><span class="line">    wait();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c多态">C++多态</span></h3><p><strong>封装，继承，多态是面向对象设计的三个特征</strong>，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。</p>
<h4><span id="多态有哪几种">多态有哪几种？</span></h4><p>多态是面向对象的重要特性之一，它是一种行为的封装，是同一种事物所表现出的多种形态，简单地说是”一个接口多种实现“。多态的实现主要分为<strong>静态多态</strong>和<strong>动态多态</strong>：</p>
<ul>
<li>静态多态主要是<strong>重载</strong>，在编译的时候就已经确定。<ul>
<li><strong>函数重载</strong></li>
<li><strong>运算符重载</strong></li>
<li><strong>模板</strong></li>
</ul>
</li>
<li>动态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。</li>
</ul>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，<strong>在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数</strong>。在子类中重新定义父类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<hr>
<h4><span id="虚函数的实现">虚函数的实现</span></h4><p>在有虚函数的类中，<strong>类的最开始部分是一个虚函数表的指针</strong>，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在 <code>代码段(.text)</code> 中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<p>虚表是一个<strong>指针数组</strong>，其元素是<strong>虚函数的指针</strong>，每个元素对应一个<strong>虚函数的函数指针</strong>。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。虚表内的条目，即<strong>虚函数指针的赋值发生在编译器的编译阶段</strong>，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<p>虚表是<strong>属于类</strong>的，而不是属于某个具体的对象，<strong>一个类只需要一个虚表</strong>即可。<strong>同一个类的所有对象都使用同一个虚表。</strong></p>
<p>⭐<code>Linux</code> 下虚表存储位置在<strong>只读数据段中(rodata)</strong>，<code>windows</code> 是在存储位置应该是<strong>常量区域。</strong> </p>
<p>为了指定对象的虚表，对象内部包含一个<strong>虚表的指针</strong>，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>void** __vfptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg" alt="img"></p>
<hr>
<h4><span id="动态绑定">动态绑定</span></h4><p>如果将基类的成员函数声明为 <code>virtual</code> 的，然后用<strong>指向派生类对象的基类指针或者引用</strong>来<strong>调用该成员函数</strong>，那么程序会<strong>在运行时选择该派生类的函数而不是基类的函数</strong>，这种特性成为<strong>运行时绑定</strong>（<strong>动态绑定</strong>、<strong>晚绑定</strong>）。</p>
<p>派生类虚函数要达成运行时动态绑定的效果，必须和基类的函数名、参数列表完全相同，否则仅仅是对基类虚函数的<strong>隐藏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类 <code>A</code> 是基类，类 <code>B</code> 继承类 <code>A</code> ，类 <code>C</code> 又继承类 <code>B</code> 。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> ，其对象模型如下图所示。由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（<code>A vtbl</code>），类B的虚表（<code>B vtbl</code>），类C的虚表（<code>C vtbl</code>）。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> 对象都拥有一个虚表指针<code>*__vptr</code>，用来指向自己所属类的虚表。</p>
<p><strong>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</strong>。</p>
<p><strong>生成子类虚表的过程：</strong></p>
<ol>
<li>将父类虚表内容拷贝到子类虚表上。</li>
<li>将子类重写的虚函数覆盖掉表中父类的虚函数。</li>
<li>如果子类有新增加的虚函数,按声明次序加到最后。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg" alt="img"></p>
<p>我们把经过虚表调用虚函数的过程称为<strong>动态绑定</strong>，其表现出来的现象称为<strong>运行时多态</strong>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为<strong>静态绑定</strong>，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p>
<ol>
<li><p>通过<strong>指针或引用</strong>来调用函数</p>
</li>
<li><p>指针<strong>upcast</strong>向上转型（继承类向基类的转换称为 <code>upcast</code> ，也就是用一个基类指针指向派生类对象）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base *base = <span class="keyword">new</span> Derived();<span class="comment">//upcast, cast Derived to Base</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用的是虚函数</p>
</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<hr>
<h4><span id="为什么析构函数必须是虚函数">为什么析构函数必须是虚函数？</span></h4><p>将<strong>可能会被继承的父类</strong>的析构函数设置为虚函数，可以保证当我们 <code>new</code> 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<hr>
<h4><span id="为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</span></h4><p>C++默认的析构函数不是虚函数是因为虚函数<strong>需要额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是<strong>只有当需要当作父类时，设置为虚函数。</strong></p>
<hr>
<h4><span id="为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</span></h4><p>1.<strong>从存储空间角度：</strong> 虚函数对应一个 <code>vtable</code> ，这个 <code>vtable</code> 其实是存储在<strong>对象的内存空间</strong>的。问题出来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到<code>vtable</code> ，所以构造函数不能是虚函数。<br><strong>2，从使用角度：</strong> 构造函数本身就是要<strong>初始化实例</strong>，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。<strong>虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数</strong>。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。<br><strong>3、构造函数不需要是虚函数，也不允许是虚函数：</strong>因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过基类的指针或引用去访问它。<br><strong>4、从实现上看，</strong><code>vtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数。</p>
<hr>
<h4><span id="静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</span></h4><p>⭐<strong>静态数据成员和静态成员函数可以被继承！</strong>具体如下：</p>
<ol>
<li>父类的 <code>static</code> 变量和函数在派生类中依然可用，但是<strong>受访问性控制</strong>（比如，父类的 <code>private</code> 域中的就不可访问），而且对 <code>static</code> 变量来说，派生类和父类中的 <code>static</code> 变量是<strong>共用空间</strong>的，这点在利用 <code>static</code> 变量进行引用计数的时候要特别注意。</li>
<li><code>static</code> 函数没有“虚函数”一说。因为 <code>static</code> 函数实际上是<strong>加上了访问控制的全局函数</strong>，全局函数哪来的什么虚函数的概念？</li>
<li>派生类的 <code>friend</code> 函数可以访问派生类本身的一切变量，包括从父类继承下来的 <code>protected</code> 域中的变量。但是对父类来说，他并不是 <code>friend</code> 的。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。所以 <code>static</code> 成员的这种应该算是继承。</li>
</ol>
<hr>
<h4><span id="友元可以继承吗">友元可以继承吗？</span></h4><p>⭐<strong>不能！</strong></p>
<p>友元只是能访问<strong>指定类的私有和保护成员的自定义函数</strong>，<strong>不是被指定类的成员</strong>，自然不能继承。 使用友元类时注意：</p>
<ol>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>A</code> 不一定是类 <code>B</code> 的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>C</code> 是 <code>B</code> 的友元，类 <code>C</code> 不一定是类 <code>A</code> 的友元，同样要看类中是否有相应的声明。</li>
</ol>
<hr>
<h4><span id="虚函数virtual可以是内联函数inline吗">虚函数(virtual)可以是内联函数(inline)吗？</span></h4><ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li><strong>内联是在编译器建议编译器内联</strong>，而<strong>虚函数的多态性在运行期</strong>，编译器无法知道运行期调用哪个代码，因此<strong>虚函数表现为多态性时（运行期）不可以内联</strong>。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：<strong>编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生</strong>。(上面第二种情况就是发生了运行期多态，是采用对象的指针或者引用、<code>upcast</code> 调用了对象的函数)</li>
</ul>
<hr>
<h4><span id="多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</span></h4><ol>
<li>基类对象首先被创建。</li>
<li>派生类构造函数应通过<strong>成员初始化列表</strong>（<strong>调用顺序和继承顺序相关</strong>）将基类信息传递给基类构造函数 ，可以使用初始化列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。</li>
<li>派生类构造函数<strong>应初始化派生类新增的数据成员</strong>。派生类对象析构时，程序<strong>首先调用派生类析构函数，再调用基类析构函数。</strong></li>
</ol>
<hr>
<h4><span id="类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</span></h4><ul>
<li><strong>函数重载：重载函数通常用来命名一组 <code>功能相似</code> 的函数</strong><ul>
<li>函数要在 <code>相同的类域</code></li>
<li>函数的 <code>名字要相同</code> </li>
<li>函数的 <code>参数列表或返回值不同</code> </li>
</ul>
</li>
<li><strong>函数重写/覆盖：覆盖是指 <code>派生类函数覆盖基类函数</code> </strong><ul>
<li>函数是要在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>基类函数 <code>必须是虚函数</code></li>
<li>两个函数的 <code>参数相同</code> </li>
</ul>
</li>
<li><strong>函数重定义/隐藏：指派生类的函数屏蔽了与其同名的基类函数</strong><ul>
<li>两个函数在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>两个函数的 <code>参数不同</code> </li>
<li><strong>如果派生类函数与基类函数参数相同，但是在基类函数中没有virtual关键字，发生函数隐藏</strong></li>
</ul>
</li>
</ul>
<hr>
<h4><span id="钻石继承问题">钻石继承问题</span></h4><p>为了解决上述菱形继承带来的问题，C++中引入了虚基类，其作用是在<strong>间接继承共同基类时只保留一份基类成员</strong>。虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态。对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象，共享基类子对象称为虚基类。虚基类用virtual声明继承关系就行了。这样一来，D就只有A的一份拷贝。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():a(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span>  <span class="keyword">public</span> B ,  <span class="keyword">public</span> C &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">	D d;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(d);</span><br><span class="line">	d.a=<span class="number">10</span>;</span><br><span class="line">	d.printA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c的四种cast">C++的四种cast</span></h3><h4><span id="static_cast">static_cast</span></h4><p>在C++语言中 <code>static_cast</code> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。例如将整型数据转换为浮点型数据。</p>
<p>主要用法有如下几种：</p>
<ol>
<li><p>用于类层次结构中基类和派生类之间指针或引用的转换。</p>
<p>进行<strong>上行转换</strong>（把派生类的指针或引用转换成基类表示）是<strong>安全</strong>的<br>进行<strong>下行转换</strong>（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，是<strong>不安全</strong>的</p>
</li>
<li><p>用于基本数据类型之间的转换，如把 <code>int</code> 转换成 <code>char</code> 。这种转换的安全也要开发人员来保证。</p>
</li>
<li><p>把空指针转换成目标类型的空指针。</p>
</li>
<li><p>把任何类型的表达式转换为 <code>void</code> 类型。</p>
</li>
</ol>
<ul>
<li>注意：<code>static_cast</code> 不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</li>
<li><code>static_cast</code> : 可以实现C++中内置基本数据类型之间的相互转换。</li>
<li>如果涉及到类的话，<code>static_cast</code> 只能在<strong>有相互联系的类型</strong>中进行相互转换,不一定包含虚函数。</li>
</ul>
<hr>
<h4><span id="const_cast">const_cast</span></h4><p><strong>const_cast&lt;type_id&gt; (expression)</strong></p>
<p><code>const_cast</code> 用于强制去掉 <code>const</code> 这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是<strong>去除指向常数对象的指针或引用的常量性</strong>，其去除常量性的对象必须为指针或引用。用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li>
<li>常量对象被转换成非常量对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> *q =<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    *q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="string">" "</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=10 *p=20 *q=20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，原来的 <code>a</code> 的常量性并没有被去除，而指向常量的指针 <code>p</code> 被转化成非常量指针，并且仍然指向原来的对象，并且指向的值被 <code>q</code> 改变成 <code>20</code> 。</p>
<hr>
<h4><span id="reinterpret_cast">reinterpret_cast</span></h4><p><strong>reinterpret_cast&lt;type_id&gt; (expression) </strong>主要有三种强制转换用途：</p>
<ol>
<li>改变指针或引用的类型。</li>
<li>将指针或引用转换为一个足够长度的整形。</li>
<li>将整型转换为指针或引用类型。</li>
</ol>
<p>其中， <code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。<code>reinterpret_cast</code> 可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。整型指针通过 <code>reinterpret_cast</code> 强制转换成了双精度浮点型指针如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code> 可以将指针或引用转换为一个足够长度的整形，此中的足够长度具体长度需要多少则取决于操作系统，如果是32位的操作系统，就需要4个字节及以上的整型，如果是64位的操作系统则需要8个字节及以上的整型。</p>
<hr>
<h4><span id="dynamic_cast">dynamic_cast</span></h4><p><strong>用法：dynamic_cast&lt;type_id&gt; (expression)</strong></p>
<ol>
<li><p>其他三种都是<strong>编译时完成</strong>的，dynamic_cast是<strong>程序运行</strong>时处理的，运行时要进行<strong>类型检查</strong>。</p>
</li>
<li><p>不能用于内置的基本数据类型的强制转换。</p>
</li>
<li><p><code>dynamic_cast</code> 转换如果成功的话返回的是<strong>指向类的指针或引用</strong>，转换失败的话则会返回 <code>NULL</code> 。</p>
</li>
<li><p><code>dynamic_cast</code>涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换</p>
</li>
<li><p>使用 <code>dynamic_cast</code> 进行转换的，<strong>基类中一定要有虚函数，否则编译不通过</strong>。<br>基类中需要检测有虚函数的原因：</p>
<ul>
<li>类中存在虚函数，就说明它有想<strong>要让基类指针或引用指向派生类对象</strong>的情况，此时转换才有意义。<br>这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。</li>
</ul>
</li>
<li><p>在类的转换时，在类层次间进行<strong>上行转换</strong> (子类指针转为父类指针) 时，<code>dynamic_cast</code> 和 <code>static_cast</code> 的效果是一样的。在进行<strong>下行转换</strong> (父类指针转为子类指针) 时，<code>dynamic_cast</code> 具有类型检查的功能，比 <code>static_cast</code> 更安全。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base* pB = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">if</span>(Derived* pD = <span class="keyword">static_cast</span>&lt;Derived*&gt;(pB))&#123;&#125;</span><br><span class="line"><span class="comment">//下行转换是不安全的(坚决抵制这种方法)</span></span><br><span class="line"></span><br><span class="line">Derived* pD = <span class="keyword">new</span> Derived();</span><br><span class="line"><span class="keyword">if</span>(Base* pB = <span class="keyword">static_cast</span>&lt;Base*&gt;(pD))&#123;&#125;</span><br><span class="line"><span class="comment">//上行转换是安全的</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li>在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。<code>dynamic_cast</code> 操作符则可以在运行期对可能产生问题的类型转换进行检查。这个检查主要来自<em>虚函数(virtual function)</em> 。在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名(function siguature)的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。</li>
</ol>
<hr>
<h4><span id="哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</span></h4><p>C风格的强制转换(Type Cast)容易理解,不管什么类型的转换都可以使用使用下面的方式.：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeName b = (TypeName)a;</span><br></pre></td></tr></table></figure>
<p><strong>static_cast</strong> 作用和C语言风格强制转换的效果基本一样，都没有运行时的类型检查来保证转换的安全性。</p>
<hr>
<h3><span id="c智能指针">C++智能指针</span></h3><p><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a></p>
<p>C++提出了智能指针，有以下四种<code>auto_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>, <code>unique_ptr</code>。其中后三个是 <code>C++11</code> 支持的，第一个已经被 <code>C++11</code> 弃用。</p>
<p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是<strong>栈上</strong>的对象，所以当函数（或程序）结束时<strong>会自动被释放通过智能指针管理分配的内存单元</strong>。</p>
<h4><span id="auto_ptr弃用">auto_ptr(弃用)</span></h4><p><code>auto_ptr</code> 采用<strong>所有权模式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，相当于 <code>p2</code> 剥夺了 <code>p1</code> 的所有权，但是当程序运行时访问 <code>p1</code> 将会报错。所以 <code>auto_ptr</code> 的缺点是：存在潜在的内存崩溃问题。</p>
<hr>
<h4><span id="unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</span></h4><p><code>unique_ptr</code> 实现<strong>独占式拥有或严格拥有</strong>概念，保证<strong>同一时间内只有一个智能指针</strong>可以指向该对象。它对于避免资源泄露 (例如“以new创建对象后因为发生异常而忘记调用delete”) 特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;</span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>同时，当程序试图将一个 <code>unique_ptr</code> 赋值给另一个时，如果源 <code>unique_ptr</code> 是个临时右值，编译器允许这么做；如果源 <code>unique_ptr</code> 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                          <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));       <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>#1</code> 留下悬挂的 <code>unique_ptr(pu1)</code> ，这可能导致危害。而 <code>#2</code> 不会留下悬挂的 <code>unique_ptr</code> ，因为它调用 <code>unique_ptr</code> 的构造函数，该构造函数创建的临时对象在其所有权让给 <code>pu3</code> 后就会被销毁</p>
<p>如果想要完成上面 <code>#1</code> 的操作，需要将一个 <code>unique_ptr</code> 赋给另一个，可以使用 <code>std::move()</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">std</span>::move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="shared_ptr">shared_ptr</span></h4><p><code>shared_ptr</code> 实现共享式拥有概念：多个智能指针可以指向相同对象，该对象和其相关资源会在<strong>最后一个引用被销毁</strong>时候释放。</p>
<p><code>shared_ptr</code> 使用计数机制来表明资源被几个指针共享。可以通过成员函数 <code>use_count()</code> 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 <code>auto_ptr</code> , <code>unique_ptr</code> , <code>weak_ptr</code> 来构造。当我们调用 <code>release()</code> 时，当前指针会释放资源所有权，计数减一。当计数等于 <code>0</code> 时，资源会被释放。</p>
<p>成员函数：</p>
<ul>
<li><p><code>use_count()</code> 返回引用计数的个数</p>
</li>
<li><p><code>unique()</code> 返回是否是独占所有权(use_count为 1 )</p>
</li>
<li><p><code>swap</code> 交换两个 <code>shared_ptr</code> 对象(即交换所拥有的对象)</p>
</li>
<li><p><code>reset</code> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li><p><code>get</code> 返回内部对象(指针), 由于已经重载了 <code>()</code> 方法, 因此和直接使用对象是一样的。</p>
<p>如 <code>shared_ptr&lt;int&gt; sp(new int(1));</code>  sp 与 sp.get() 是等价的。</p>
</li>
</ul>
<p><strong>引用计数带来的副作用</strong> <code>循环引用问题</code><br>A对象的指针指向B对象，B对象的指针指向了A对象。两个指针相互指向。<code>造成堆里的内存无法正常回收，造成内存泄漏。</code> 这个时候就需要 <code>weak_ptr</code> 了。</p>
<hr>
<h4><span id="weak_ptr">weak_ptr</span></h4><p><code>weak_ptr</code> 是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象，进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code> 。</p>
<p><code>weak_ptr</code> 只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 工作, <strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>, 它的构造和析构不会引起引用记数的增加或减少。</p>
<p><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题：</strong></p>
<p>如果两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。<code>weak_ptr</code> 是对对象的一种弱引用，不会增加对象的引用计数。</p>
<p><code>weak_ptr</code> 和 <code>shared_ptr</code> 之间可以相互转化，<code>shared_ptr</code> 可以直接赋值给<code>weak_ptr</code> ，<code>weak_ptr</code> 也可以通过调用 <code>lock</code> 函数来获得 <code>shared_ptr</code> 。</p>
<p>具体栗子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会只输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>出现了循环引用，当要跳出函数时，智能指针 <code>pa</code> ，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code> ，导致跳出函数时资源没有被释放(A\B的析构函数没有被调用)，如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 <code>A</code> 里面的 <code>shared_ptr pb_;</code> 改为 <code>weak_ptr pb_;</code> 运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">B delete</span><br><span class="line">A delete</span><br></pre></td></tr></table></figure>
<p>资源 <code>B</code> 的引用开始就只有 <code>1</code> ，当 <code>pb</code> 析构时，<code>B</code> 的计数变为 </p>
<p>​    <code>0</code> ，<code>B</code> 得到释放，<code>B</code> 释放的同时也会使 <code>A</code> 的计数减一，同时 <code>pa</code> 析构时使 <code>A</code> 的计数减一，那么 <code>A</code> 的计数为 <code>0</code> ， <code>A</code> 得到释放。</p>
<p>注意的是我们不能通过 <code>weak_ptr</code> 直接访问对象的方法，比如 <code>B</code> 对象中有一个方法 <code>print()</code> ,我们不能这样访问，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;pb_-&gt;print()</span><br></pre></td></tr></table></figure>
<p><code>pb_</code> 是一个 <code>weak_ptr</code> ，应该先调用 <code>lock()</code> 函数把它转化为 <code>shared_ptr</code> ，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> p = pa-&gt;pb_.lock();</span><br><span class="line">p-&gt;print();</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>如何判断weak_ptr的对象是否失效？</strong></p>
<ol>
<li><code>expired()</code> ：检查被引用的对象是否已删除。</li>
<li><code>lock()</code> 会返回 <code>shared_ptr</code> 指针，判断该指针是否为空。</li>
<li><code>use_count()</code> 也可以得到 <code>shared_ptr</code> 引用的个数，但速度较慢。</li>
</ol>
<hr>
<p><strong>shared_ptr 和 unique_ptr 区别</strong></p>
<p><code>unique_ptr</code> 具有唯一性，对指向的对象值存在唯一的 <code>unique_ptr</code> 。<code>unique_ptr</code> 不可复制，赋值，但是<code>std::move()</code> 可以转换对象的所有权，局部变量的返回值除外。与 <code>shared_ptr</code> 相比，若自定义删除器，<code>unique_ptr</code>需要在声明处指定删除器类型，而 <code>shared_ptr</code> 不需要，<code>shared_ptr</code> 自定义删除器只需要指定删除器对象即可；在赋值时，<code>shared_ptr</code> 可以随意赋值，删除器对象也会被赋值给新的对象。因为在 <code>unique_ptr</code> 的实现中，删除器对象是作为 <code>unique_ptr</code> 的一部分，而 <code>shared_ptr</code> 的删除器对象保存在<code>control_block</code> 中。</p>
<hr>
<h4><span id="智能指针是线程安全的吗">智能指针是线程安全的吗？</span></h4><p><code>shared_ptr</code> 本身不是 <code>100%</code> 线程安全的。</p>
<p>它的引用计数本身是安全且无锁的，智能指针的引用计数在手段上使用了<strong>atomic原子操作</strong>，只要 <code>shared_ptr</code> 在拷贝或赋值时增加引用，析构时减少引用就可以了。首先原子是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的。</p>
<p>但对象的读写则不是，因为<code>shared_ptr</code> 有<strong>两个数据成员</strong>，读写操作不能原子化：一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象，当智能指针发生拷贝的时候，标准库的实现是<strong>先拷贝智能指针</strong>，<strong>再拷贝引用计数对象</strong>（拷贝引用计数对象的时候，会使 <code>use_count++</code>），这两个操作并不是原子操作，隐患就出现在这里。<strong>两个线程中智能指针的引用计数同时++或–，这个操作不是原子的，假设引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了，违背了原子性。</strong></p>
<p>根据 <code>boost</code> 文档，<code>shared_ptr</code> 的线程安全级别和内建类型、标准库容器、<code>std::string</code> 一样，即：</p>
<ul>
<li>一个 <code>shared_ptr</code> 对象实体可被多个线程同时读取；</li>
<li>两个 <code>shared_ptr</code> 对象实体可以被两个线程同时写入，<code>析构</code> 算写操作；</li>
<li>如果要从多个线程读写同一个 <code>shared_ptr</code> 对象，那么需要加锁。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>读</code> 是安全的。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>写</code> 是不安全的。</li>
<li>同一个 <code>shared_ptr</code> 对象不能被多线程直接修改，但可以通过原子函数完成。</li>
<li>共享引用计数的不同的 <code>shared_ptr</code> 被多个线程 <code>写</code>  是安全的。</li>
</ul>
<hr>
<h3><span id="c对象的内存模型">C++对象的内存模型</span></h3><h4><span id="普通对象模型">普通对象模型</span></h4><p>对象是如何在内存中布局的？</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>存放位置</th>
<th>访问范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>非静态数据成员</td>
<td>每一个对象体内</td>
<td>为该对象专有</td>
</tr>
<tr>
<td>静态数据成员</td>
<td>程序的静态存储区内，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>成员函数（静态/非静态）</td>
<td>程序的代码段中，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>类内嵌套的各种类型（typedef、class、struct、enum等）</td>
<td>与放在类外面定义的类型除了定义域之外没有本质区别</td>
<td>遵循类内部的访问规则</td>
</tr>
</tbody>
</table>
<p>因此，构成对象本身的<strong>只有数据</strong>，类的成员函数不属于任何一个对象。<strong>非静态成员函数与对象之间的关系是通过this指针绑定的</strong>。</p>
<h4><span id="派生类的对象模型">派生类的对象模型</span></h4><p>派生类的对象是如何在内存中布局的？</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承自基类的非静态数据成员</td>
<td>作为对象自己专用的数据</td>
</tr>
<tr>
<td>继承自基类的非静态成员函数</td>
<td>作为类的成员函数一样访问</td>
</tr>
<tr>
<td>虚函数（继承的或者新增的）</td>
<td>所有虚函数的地址都存放在vtable里</td>
</tr>
<tr>
<td>多态类每一个对象中的vptr</td>
<td>函数指针的指针，指向所属类的vtable</td>
</tr>
<tr>
<td>继承自基类的vptr</td>
<td>继承和重用该vptr</td>
</tr>
<tr>
<td>多重继承的多个分支</td>
<td>每个分支都继承一个vptr并生成一个对应的vtable</td>
</tr>
</tbody>
</table>
<p><code>vptr</code> 在派生类对象中的相对位置不会随着继承的层次改变而改变，一般编译器会将 <code>vptr</code> 放在所有数据成员的最前面。为了支持 <code>RTTI</code> ，编译器会为每一个多态类创建一个 <code>type_info</code> 对象，并把其地址保存在该类 <code>vtable</code> 中的第一个位置。</p>
<h4><span id="vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</span></h4><ol>
<li>如果虚函数是第一次出现，则把它的函数地址指针依次插入到 <code>vtable</code> 的尾部。</li>
<li>如果派生类改写了基类的虚函数，则这个函数的地址在派生类 <code>vtable</code> 中的位置与其在基类 <code>vtable</code> 中的位置一致，而与其在派生类中的声明位置无关。也就是说<strong>一旦虚函数指针在 <code>vtable</code> 的位置确定，则它的位置就不会因为继承层次的改变而改变。</strong></li>
<li>派生类没有改写的基类虚函数被继承，位置与原先在 <code>vtable</code> 中的位置相同。</li>
</ol>
<hr>
<h3><span id="volitale关键字">Volitale关键字</span></h3><p> <code>volatile</code> 关键字直译应该是 <code>易变的</code> ，也就是它修饰的对象有可能突然发生不可预期的改变。被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p>
<p><code>volatile</code> 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>，从而可以<strong>提供对特殊地址的稳定访问</strong>。</p>
<p><code>volatile</code> 可理解为编译器警告指示字；<code>volatile</code> 用于告诉编译器必须每次去内存中取变量值；<code>volatile</code>主要修饰可能被多个线程访问的变量；<code>volatile</code> 也可以修饰可能被未知因数更改的变量。</p>
<p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在<strong>主存(物理内存)</strong>当中的，这时就存在一个问题，由于CPU执行速度很快，而<strong>从内存读取数据</strong>和<strong>向内存写入数据</strong>的过程跟<strong>CPU执行指令的速度</strong>比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。</p>
<p>为了处理这个问题，在CPU里面就有了<strong>高速缓存(Cache)</strong>的概念。当程序在运行过程中，会将运算需要的数据<strong>从主存复制一份到CPU的高速缓存当中</strong>，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将<strong>高速缓存中的数据刷新到主存当中</strong>。</p>
<p>这一过程在单线程运行是没有问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存。这时就会出现同一个变量在两个高速缓存中的<strong>值</strong>不一致问题了。例如：两个线程分别读取了 <code>t</code> 的值，假设此时 <code>t</code> 的值为0，并且把 <code>t</code> 的值存到了各自的高速缓存中，然后线程1对 <code>t</code> 进行了加1操作，此时 <code>t</code> 的值为1，并且把 <code>t</code> 的值写回到主存中。但是线程2中高速缓存的值还是0，进行加1操作之后，<code>t</code> 的值还是为1，然后再把 <code>t</code> 的值写回主存。此时，就出现了 <code>线程不安全</code> 问题了。</p>
<p>按照 <a href="https://link.zhihu.com/?target=http%3A//web.archive.org/web/20180120044239/http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html" target="_blank" rel="noopener">Hans Boehm &amp; Nick Maclaren 的总结</a>，<code>volatile</code> 只在三种场合下是合适的。</p>
<ul>
<li><ul>
<li>和信号处理（signal handler）相关的场合；</li>
<li>和内存映射硬件（memory mapped hardware）相关的场合；</li>
<li>和非本地跳转（<code>setjmp</code> 和 <code>longjmp</code>）相关的场合。换句话说也就是</li>
</ul>
</li>
</ul>
<p>也就是：</p>
<p><strong>1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；</strong></p>
<p><strong>2) 多任务环境下各任务间共享的标志应该加volatile；</strong></p>
<p><strong>3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</strong></p>
<h4><span id="volatile指针">volatile指针</span></h4><p>和 <code>const</code> 修饰词类似，<code>const</code> 有常量指针和指针常量的说法，<code>volatile</code> 也有相应的概念：</p>
<ul>
<li>修饰由指针指向的对象、数据是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span>* vpch;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针自身的值——一个代表地址的整数变量，是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>(1) 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</strong></p>
<p>(2) 除了基本类型外，对用户定义类型也可以用 <code>volatile</code> 类型进行修饰。</p>
<p>(3) C++中一个有 <code>volatile</code> 标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用<code>const_cast</code> 来获得对类型接口的完全访问。此外，<code>volatile</code> 像 <code>const</code> 一样会从类传递到它的成员。</p>
<h4><span id="可见性">可见性</span></h4><h5><span id="什么是可见性">什么是可见性？</span></h5><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的<strong>工作空间</strong>中读取。<br>例如我们上面说的，当线程1对 <code>t</code> 进行了加1操作并把数据写回到主存之后，线程2就会知道它自己工作空间内的 <code>t</code> 已经被修改了，当它要执行加1操作之后，就会去主存中读取。这样，两边的数据就能一致了。<br>假如一个变量被声明为 <code>volatile</code> ，那么这个变量就具有了<strong>可见性</strong>的性质了。这就是 <code>volatile</code> 关键的作用之一了。</p>
<hr>
<p><strong>静态全局变量</strong>：注意使用 <code>static</code> 修饰变量，就不能使用 <code>extern</code> 来修饰，即 <code>static</code> 和 <code>extern</code> 不可同时出现。<code>static</code> 修饰的全局变量的声明与定义同时进行，即当你在头文件中使用 <code>static</code> 声明了全局变量，同时它也被定义了。</p>
<hr>
<h3><span id="c中指针和引用的区别">C++中指针和引用的区别</span></h3><ol>
<li>指针有自己的一块空间，而引用只是一个别名；</li>
<li>使用 <code>sizeof</code> 看一个指针的大小是 <code>4</code> ，而引用则是被引用对象的大小；</li>
<li>指针可以被初始化为 <code>NULL</code> ，而引用必须被初始化且必须是一个已有对象的引用；</li>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li>
<li>可以有 <code>const</code> 指针，但是没有 <code>const</code> 引用；<ul>
<li><strong>指针常量</strong> <code>int *const P1</code>：指针常量约束的是该指针所指的地址，即指针变量本身，而并不是对象本身，地址不能够改变，但是对象值可以改变。<code>const</code> 在 <code>*</code> 后，表示约束的量是指针的地址。</li>
<li><strong>指向常量的指针</strong> <code>const int *P1</code> ：用 <code>const</code> 约束指针对所指对象进行访问时，这个指针称为指向常量的指针。<code>const</code> 在 <code>*</code> 前，表示约束的是指针量本身。<strong>指向常量的指针可以获取变量的地址，但限制用指针间址访问对象方式为“只读</strong>。</li>
</ul>
</li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</li>
<li>指针可以有多级指针（<code>**p</code>），而引用只有一级；</li>
<li>指针和引用使用 <code>++</code> 运算符的意义不一样：引用自增被引用对象的值，指针自增内存地址</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起<strong>内存泄露</strong>。</li>
</ol>
<hr>
<h3><span id="c中new与malloc的区别">C++中new与malloc的区别</span></h3><p><code>new</code> 和 <code>malloc</code> 的内存是分配在堆上的。也有说 <code>new</code> 是分配在自由存储区而 <code>malloc</code> 分配在堆上，自由存储区可以是堆也可以不是，具体要看 <code>new</code> 内部的实现。操作系统在堆上维护一个空闲内存链表，当需要分配内存的时候，就查找这个表，找到一块内存大于所需内存的区域，分配内存并将剩余的内存空间返还到空闲链表上(如果有剩余的话)。</p>
<ol>
<li><code>malloc</code> 和 <code>free</code> 是<strong>库函数</strong>，而 <code>new</code> 和 <code>delete</code> 是 <code>C++</code> <strong>操作符</strong>；</li>
<li><code>new</code> 自己计算需要的空间大小，比如 <code>int * a = new</code> ，<code>malloc</code> 需要指定大小，例如 <code>int * a = malloc(sizeof(int));</code> </li>
<li><code>new</code> 在动态分配内存的时候可以初始化对象，调用其构造函数，<code>delete</code> 在释放内存时调用对象的析构函数。而 <code>malloc</code> 只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回 <code>NULL</code> 。</li>
<li><code>new</code> 是 <code>C++</code> 操作符，是关键字，而 <code>operate new</code> 是 <code>C++</code> 库函数</li>
<li><code>opeartor new</code> / <code>operator delete</code> 可以重载，而 <code>malloc</code> 不行</li>
<li><code>new</code> 可以调用 <code>malloc</code> 来实现，但是 <code>malloc</code> 不能调用 <code>new</code> 来实现</li>
<li>对于数组，C++定义 <code>new[]</code> 专门进行动态数组分配，用 <code>delete[]</code> 进行销毁。<code>new[]</code> 会一次分配内存，然后多次调用构造函数；<code>delete[]</code> 会先多次调用析构函数，然后一次性释放。</li>
<li><strong>malloc能够直观地重新分配内存</strong>：使用 <code>malloc</code> 分配的内存后，如果在使用过程中发现内存不足，可以使用<code>realloc</code> 函数进行内存重新分配实现内存的扩充。<code>realloc</code> 先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域；<code>new</code> 没有这样直观的配套设施来扩充内存。</li>
</ol>
<hr>
<h3><span id="c-内存对齐">C++ 内存对齐</span></h3><p>现代计算机中内存空间都是按照 <code>byte</code> 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的<strong>首地址的值</strong>是某个数 <code>k</code> （通常它为4或8）的倍数，这就是所谓的内存对齐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，32位系统下，<code>int</code> 占 <code>4 byte</code> ，<code>char</code> 占一个 <code>byte</code> ，那么将它们放到一个结构体中应该占<code>4+1=5byte</code>；但是实际上，<code>sizeof(s)</code> 得到的结果是 <code>8 byte</code> ，这就是内存对齐所导致的。</p>
<p><strong>为什么要内存对齐？</strong></p>
<p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，四字节，<code>8</code> 字节，<code>16</code> 字节甚至 <code>32</code> 字节为单位来存取内存，我们将上述这些存取单位称为<strong>内存存取粒度</strong>。</p>
<p>现在考虑 <code>4</code> 字节存取粒度的处理器取 <code>int</code> 类型变量（<code>32</code> 位系统），该处理器只能从地址为 <code>4</code> 的倍数的内存开始读取数据。这样处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p>
<p>每个特定平台上的编译器都有自己的默认<strong>对齐系数</strong>（也叫对齐模数）。<code>gcc</code> 中默认 <code>#pragma pack(4)</code> ，可以通过预编译命令 <code>#pragma pack(n)</code> ，<code>n = 1,2,4,8,16</code> 来改变这一系数。</p>
<p>有效对其值：是给定值 <code>#pragma pack(n)</code> 和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p><strong>内存对齐规则：</strong></p>
<ul>
<li>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 <code>offset</code> 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</li>
<li><strong>结构体的总大小</strong>为有效对齐值的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">&#125;x3;</span><br></pre></td></tr></table></figure>
<p><code>x1</code> , <code>x2</code> , <code>x3</code> 的 <code>sizeof</code> 结果分别是 <code>8</code> ,  <code>12</code> , <code>8</code> 。</p>
<p>内存结构分别如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg" alt="img"></p>
<hr>
<h3><span id="c存储类型">C++存储类型</span></h3><p>C++中<strong>存储类型的说明符</strong>有四个：<strong>auto</strong>, <strong>register</strong>, <strong>static</strong>和<strong>extern</strong>。前两者称为<code>自动</code>类型，后两者分别为<code>静态</code>和<code>外部</code>类型。此外还有 <code>mutable存储类</code> 和 <code>thread_local 存储类</code> 。</p>
<hr>
<h4><span id="auto-自动变量">auto 自动变量</span></h4><p>用 <code>auto</code> 说明的变量，通常 <code>auto</code> 省略。局部变量都是自动类型。其生命期开始于块的执行，结束于块的结束。</p>
<p>自动变量的空间分配在<strong>栈</strong>中，在程序运行过程中，块开始执行时系统<strong>自动</strong>分配空间（未初始化时值为随机数），块执行结束时系统<strong>自动</strong>释放空间。因此，自动变量的<strong>生命期和作用域是一致的</strong>。</p>
<hr>
<h4><span id="register-寄存器变量">register 寄存器变量</span></h4><p>用 <code>register</code> 说明的变量，如 <code>register int i</code> ; 系统将这样说明的变量尽可能保存在寄存器中，以提高程序运行速度。但不同的编译器对哪些变量可以说明为寄存器变量有不同的规定，而且一般的编译器都会对寄存器的使用进行优化，所以不提倡使用寄存器变量。</p>
<hr>
<h4><span id="static-关键字">static 关键字</span></h4><p>静态变量存储在<strong>全局存储区(静态存储区)</strong>，在整个程序运行期间一直存在。如果程序未显式给出初始化值，系统自动初始化为全 <code>0</code>，且初始化只进行一次。静态变量占有的空间要到整个程序执行结束才释放，故静态变量具有<strong>全局生命期</strong>。</p>
<p>静态变量根据定义位置的不同还分为 <code>局部静态变量</code> 和 <code>全局静态变量</code> ，</p>
<ol>
<li><p><strong>局部静态变量：</strong></p>
<p>是指在块中定义的静态变量，当块第一次被执行的时候，编译器在<strong>全局存储区</strong>为其开辟空间并保存数据，该空间一直到整个程序结束才释放。该变量具有<strong>局部作用域</strong>，但却具有<strong>全局生命期</strong>。当定义它的函数或者语句块结束的时候，作用域结束。:star:但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且变量的值不变。</p>
</li>
<li><p><strong>全局静态变量：</strong></p>
<p>全局静态变量在声明他的文件之外是不可见的，作用域是从定义之处-&gt;文件结尾。</p>
</li>
<li><p><strong>静态函数：</strong></p>
<p>在函数返回类型前加 <code>static</code> ，函数就定义为静态函数。函数的定义和声明在默认情况下都是<code>extern</code> 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用 <code>static</code> 修饰，那么这个函数只可在本 <code>cpp</code> 内使用，不会同其他 <code>cpp</code> 中的同名函数引起冲突。</p>
<p>注意：不要在头文件中声明 <code>static</code> 的全局函数，不要在 <code>cpp</code> 内声明非 <code>static</code> 的全局函数，如果你要在多个 <code>cpp</code> 中复用该函数，就把它的声明提到头文件里去，否则 <code>cpp</code> 内部声明需加上static修饰。</p>
</li>
<li><p><strong>类的静态成员：</strong></p>
<p>在类中，静态成员可以实现多个对象之间的<strong>数据共享</strong>，并且使用静态数据成员还<strong>不会破坏隐藏的原则</strong>，即保证了安全性。因此，静态成员是<strong>类的所有对象中共享的成员</strong>，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
</li>
<li><p><strong>类的静态函数：</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)。</p>
<ol>
<li>静态成员函数<strong>是类的一个特殊的成员函数</strong></li>
<li>静态成员函数<strong>属于整个类所有，没有this指针</strong></li>
<li>静态成员函数<strong>只能直接访问静态成员变量和静态成员函数</strong></li>
<li><strong>可以通过类名直接访问类的公有静态成员函数</strong></li>
<li><strong>可以通过对象名访问类的公有静态成员函数</strong></li>
<li><strong>定义静态成员函数，直接使用static关键字修饰即可</strong></li>
</ol>
<p>这里面有一种很常见的情况是，在 <code>sort()</code> 函数中，<code>sort</code> 函数的参数 <code>cmp</code> 的调用要求不带 <code>this</code> 指针，对于类内函数，他们都有一个隐式的 <code>this</code> 指针在第一个参数内，因此要么把 <code>cmp</code> 写在类外，要么加上 <code>static</code> 声明，<code>static</code> 声明后的成员函数不带有 <code>this</code> 指针。所以要写成如下形式：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="extern关键字">extern关键字</span></h4><p><code>extern</code> 是一种<strong>外部声明</strong>的关键字，字面意思就是<strong>在此处声明</strong>某种变量或函数，<strong>在外部定义</strong>。</p>
<p><code>extern</code> 关键字的主要作用是<strong>扩大变量/函数的作用域</strong>，使得其它源文件和头文件可以复用同样的变量/函数，也起到类似“分块储存”的作用，划分代码。如图所示，在一个头文件里做了外部声明，就能把变量的定义部分和函数体的实现部分转移到其它地方了。</p>
<p><img src="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png" alt="img"></p>
<p>此外 <code>extern</code> 也可用来进行<strong>链接指定</strong>：当它与 <code>C</code> 一起连用时，如: <code>extern &quot;C&quot; void fun(int a, int b);</code> 则告诉编译器在编译 <code>fun</code> 这个函数名时按着 <code>C</code> 的规则去翻译相应的函数名而不是 <code>C++</code> 的，<code>C++</code> 的规则在翻译这个函数名时会把 <code>fun</code> 这个名字变得面目全非，可能是 <code>fun@aBc_int_int#%$</code> 也可能是别的，因为 <code>C++</code> 支持函数的重载。</p>
<p><strong>对于extern关键字：只在头文件中做声明，真理总是这么简单</strong>。</p>
<hr>
<h4><span id="mutable-存储类">mutable 存储类</span></h4><p><strong>mutable</strong> 说明符仅适用于类的对象。它允许对象的成员替代常量。也就是说，<code>mutable</code> 成员可以通过 <code>const</code> 成员函数修改。</p>
<hr>
<h4><span id="thread_local-存储类">thread_local 存储类</span></h4><p><code>thread_local</code> 变量是 <code>C++11</code> 新引入的一种存储类型。它会影响变量的存储周期( <code>Storage duration</code> )。只有<code>thread_local</code> 关键字修饰的变量具有线程周期( <code>thread duration</code> )，这些变量(或者说对象）在线程开始的时候被生成( <code>allocated</code> )，在线程结束的时候被销毁( <code>deallocated</code> )。并且每 一个线程都拥有一个独立的变量实例。<code>thread_local</code> 可以和<code>static</code> 与 <code>extern</code>关键字联合使用，这将影响变量的链接属性。</p>
<hr>
<h3><span id="stdmove语义">std::move()语义</span></h3><p>在 <code>C++11</code> 中，标准库在 <code>&lt;utility&gt;</code> 中提供了一个有用的函数 <code>std::move</code> ，<code>std::move</code> 并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。  </p>
<hr>
<h3><span id="右值引用">右值引用</span></h3><p><strong>左值与右值</strong></p>
<p>左值可以取地址、位于等号左边；而右值没法取地址，位于等号右边。</p>
<p>有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<h4><span id="左值引用">左值引用</span></h4><p><strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure>
<p>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。但是，<strong>const左值引用</strong>是可以指向右值的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<p><code>const</code> 左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用 <code>const &amp;</code> 作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p>
<h4><span id="右值引用">右值引用</span></h4><p>右值引用的标志是 <code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>
<h4><span id="右值引用有办法指向左值吗">右值引用有办法指向左值吗</span></h4><p>可以通过 <code>std::move()</code> 实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>
<p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>。</p>
<p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参是个右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span> </span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// ref_a_left是个左值引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// ref_a_right是个右值引用</span></span><br><span class="line"> </span><br><span class="line">    change(a); <span class="comment">// 编译不过，a是左值，change参数要求右值</span></span><br><span class="line">    change(ref_a_left); <span class="comment">// 编译不过，左值引用ref_a_left本身也是个左值</span></span><br><span class="line">    change(ref_a_right); <span class="comment">// 编译不过，右值引用ref_a_right本身也是个左值</span></span><br><span class="line">     </span><br><span class="line">    change(<span class="built_in">std</span>::move(a)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_right)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_left)); <span class="comment">// 编译通过</span></span><br><span class="line"> </span><br><span class="line">    change(<span class="number">5</span>); <span class="comment">// 当然可以直接接右值，编译通过</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    <span class="comment">// 打印这三个左值的地址，都是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::move()</code> 会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以 <code>move</code> 返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：</p>
<p><strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p>
<p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 </p>
<p><strong>总的来说：</strong></p>
<ol>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以<strong>避免拷贝</strong>。</li>
<li>右值引用可以直接指向右值，也可以通过 <code>std::move</code> 指向左值；而左值引用只能指向左值( <code>const</code> 左值引用也能指向右值)。</li>
<li>作为函数形参时，右值引用更灵活。虽然 <code>const</code> 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// 编译失败，const左值引用不能修改指向变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> &amp;&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">5</span>);</span><br><span class="line">    f2(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际场景中，右值引用和 <code>std::move</code> 被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。在 <code>STL</code> 的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如 <code>std::vector</code> 的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<p>移动构造函数即：把被拷贝者的数据移动过来，被拷贝者后边就不要这个数据了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2：std::vector和std::string的实际例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"aacasxs"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.push_back(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.emplace_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.emplace_back(<span class="string">"axcsddcas"</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::vector方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有些 <code>STL</code> 类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_a = <span class="built_in">std</span>::make_unique&lt;A&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = <span class="built_in">std</span>::move(ptr_a); <span class="comment">// unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = ptr_a; <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<h4><span id="完美转发-stdforward">完美转发 std::forward()</span></h4><p>和<code>std::move</code>一样，<code>std::forward</code>也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换。</p>
<p>与 <code>move</code> 相比，<code>forward</code> 更强大，<code>move</code> 只能转出来右值，<code>forward</code> 都可以。</p>
<blockquote>
<p>std::forward<t>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</t></p>
</blockquote>
<h4><span id="autoampamp也是这个意思">auto&amp;&amp;也是这个意思</span></h4><p>迭代器中如果使用 <code>auto&amp;&amp;</code> 代表着接受任何初始化程序，无论它是左值表达式还是右值表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>         =&gt; will copy the <span class="built_in">vector</span>, but we wanted a reference</span><br><span class="line"><span class="keyword">auto</span>&amp;        =&gt; will only bind to modifiable lvalues</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;  =&gt; will bind to anything but make it <span class="keyword">const</span>, giving us const_iterator</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; =&gt; will bind only to rvalues</span><br></pre></td></tr></table></figure>
<p>所以说大部分情况下，<code>auto</code> 和 <code>auto&amp;&amp;</code> 能够解决大部分问题。</p>
<hr>
<h3><span id="c内联函数">C++内联函数</span></h3><h4><span id="内联函数有什么优点">内联函数有什么优点？</span></h4><ol>
<li><code>inline</code> 函数代码是被放到<strong>符号表</strong>中，使用时像宏一样展开，没有调用的开销，效率很高；</li>
<li><code>inline</code> 函数是真正的函数，所以要进行一系列的数据类型检查；</li>
<li><code>inline</code> 函数作为类的成员函数，可以使用类的保护成员及私有成员；</li>
</ol>
<p>C++中支持内联函数，其目的是为了<strong>提高函数的执行效率</strong>：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。用关键字 <code>inline</code> 放在函数定义(<strong>注意是定义而非声明</strong>)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上<strong>内联地</strong>展开，假设我们将 <code>max</code> 定义为内联函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>cout&lt;&lt;max(a, b)&lt;&lt;endl;</code> 的时候，编译时会展开为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;(a &gt; b ? a : b)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>Effective C++</code> 中，<code>Prefer consts，enums，and inlines to #defines</code>，建议我们用内联函数来替代宏定义。</p>
<h4><span id="缺点">缺点</span></h4><ol>
<li><strong>代码膨胀：</strong>内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li><strong>inline 函数无法随着函数库升级而升级</strong>：inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li><strong>是否内联，程序员不可控</strong>：内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4><span id="将内联函数放入头文件">将内联函数放入头文件</span></h4><p>关键字 <code>inline</code> 必须与函数定义体放在一起才能使函数成为内联，仅将 <code>inline</code> 放在函数声明前面不起任何作用。定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125;   <span class="comment">// 自动地成为内联函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 <code>inline</code> 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p>
<p>当然内联函数定义也可以放在源文件中，但此时<strong>只有定义的那个源文件可以用它</strong>，而且<strong>必须为每个源文件拷贝一份定义</strong>(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。</p>
<h4><span id="内联函数与宏定义的区别">内联函数与宏定义的区别？</span></h4><ol>
<li><p>内联函数在<strong>编译时展开</strong>，宏在<strong>预编译时展开</strong>；</p>
</li>
<li><p>内联函数直接<strong>嵌入到目标代码中</strong>，宏是简单的做<strong>文本替换</strong>；</p>
<p>所以这时候宏定义会出意想不到的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= ADD(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//所得的结果却是210</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------其实本质就是--------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= x + y * <span class="number">10</span>;  <span class="comment">//编译器并不会给其加括号</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内联函数有<strong>类型检测、语法判断</strong>等功能，宏没有；</p>
</li>
<li><p><code>inline</code> 函数是函数，宏不是；</p>
</li>
<li><p>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；</p>
</li>
<li><p>C++中引入了类及类的访问控制，在涉及到<strong>类的保护成员和私有成员</strong>就不能用宏定义来操作。</p>
</li>
</ol>
<hr>
<h4><span id="explicit关键字">explicit关键字</span></h4><ul>
<li><code>explicit</code> 修饰构造函数时，可以<strong>防止隐式转换和复制初始化</strong></li>
<li><code>explicit</code> 修饰转换函数时，可以<strong>防止隐式转换</strong>，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li>
</ul>
<hr>
<h4><span id="union-联合体">union 联合体</span></h4><p>联合(union)是一种节省空间的特殊的类，一个 <code>union</code> 可以有多个数据成员，但是<strong>在任意时刻只有一个数据成员可以有值</strong>。<strong>当某个成员被赋值后其他成员变为未定义状态</strong>。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li><strong>不能含有引用类型的成员</strong></li>
<li><strong>不能继承自其他类，不能作为基类</strong></li>
<li>不能含有虚函数</li>
<li>匿名 <code>union</code> 在定义所在作用域可直接访问 <code>union</code> 成员</li>
<li>匿名 <code>union</code> 不能包含 <code>protected</code> 成员或 <code>private</code> 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<hr>
<h3><span id="深拷贝与浅拷贝">深拷贝与浅拷贝</span></h3><p>C++中类的拷贝有两种：<strong>深拷贝</strong>，<strong>浅拷贝</strong>：当出现类的等号赋值时，即会调用拷贝函数。<br><strong>深拷贝与浅拷贝的区别</strong></p>
<ol>
<li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但<strong>当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂</strong>现象，所以，此时，必须采用深拷贝。</li>
<li>深拷贝与浅拷贝的区别就在于深拷贝<strong>会在堆内存中另外申请空间来储存数据</strong>，从而也就解决了指针悬挂的问题。简而言之，当<strong>数据成员中有指针时，必须要用深拷贝</strong>。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。</p>
<p>深拷贝的实现一般如下，即自己定义拷贝构造函数来实现深拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student();</span><br><span class="line">	~Student();</span><br><span class="line">	Student(<span class="keyword">const</span> Student &amp;s);<span class="comment">//深拷贝构造函数，const防止对象被改变</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Student::Student() &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">Student::~Student() &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; (<span class="keyword">int</span>)name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> name;</span><br><span class="line">	name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;s) &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(name, s.name, <span class="built_in">strlen</span>(s.name));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="built_in">string</span> &amp;name;</span><br><span class="line">    Address addr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">int</span> grade, <span class="built_in">string</span> name):grade(grade), name(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常量成员</strong>：常量成员只能初始化不能赋值，所以必须放在初始化列表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>引用类型</strong>：引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>对象成员</strong>：成员是其他类的对象，例如上面的 <code>Address  addr</code> 成员。如果把它放在构造函数的初始化列表里，此时会调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>，对这个类对象进行初始化。如果把它放在构造函数体中，会先调用 <code>Address</code> 类的<strong>默认构造函数</strong>，然后再调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>。从性能上考虑，把对象成员的初始化放在初始化列表里性能会更高。</li>
<li><strong>对象成员，并且这个对象只有含参数的构造函数，没有无参数的构造函数：</strong>如果我们有一个<strong>类成员</strong>，它本身是一个类或者是一个结构，而且这个成员它<strong>只有一个带参数的构造函数，而没有默认构造函数</strong>，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。</li>
<li><strong>子类初始化父类的私有成员</strong>，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数。</li>
</ul>
<hr>
<h3><span id="定位内存泄露及检测">定位内存泄露及检测</span></h3><p><a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" target="_blank" rel="noopener">https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html</a></p>
<p>(1)在 <code>windows</code> 平台下通过 <code>CRT</code> 中的库函数进行检测；<br>(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置<br>(3) <code>Linux</code> 下通过工具 <code>valgrind</code> 检测</p>
<hr>
<h3><span id="手写strcpymemcpystrcatstrcmp等函数">手写strcpy，memcpy，strcat，strcmp等函数</span></h3><h4><span id="strcpy">strcpy</span></h4><ol>
<li><code>const</code> 修饰：源字符串参数用 <code>const</code> 修饰，防止修改源字符串；</li>
<li>空指针检查：源指针和目的指针都有可能会出现空指针的情况，所以应该对其进行检查；</li>
<li>为什么要设置 <code>ret</code> 指针以及返回 <code>ret</code> 指针的位置，由于目的指针 <code>dst</code> 已经在进行移动了，所以用辅助指针 <code>ret</code> 表明首指针；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数是没有考虑重叠的</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dst);</span><br><span class="line">    assert(src);</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑重叠</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(src) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dst &gt; src &amp;&amp; dst &lt; src + len) &#123;</span><br><span class="line">        dst = dst + size - <span class="number">1</span>;</span><br><span class="line">        src = src + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">            *dst-- = *src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">            *dst++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="memcpy">memcpy</span></h4><p>对于地址重叠的情况，该函数的行为是未定义的。因此自己动手实现 <code>memcpy()</code> 时就需要考虑地址重叠的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> *ret = dst;</span><br><span class="line">	<span class="keyword">char</span>* pdst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">	<span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">	<span class="keyword">if</span> (pdst &gt; src || pdst &lt; psrc + size) &#123;</span><br><span class="line">		pdst = pdst + size - <span class="number">1</span>;</span><br><span class="line">		psrc = psrc + size - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst-- = *psrc--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst++ = *psrc++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strlen">strlen</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    assert(<span class="literal">NULL</span> != str);</span><br><span class="line">    <span class="keyword">while</span> (*str++ != <span class="string">'\0'</span>) &#123;　</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcat">strcat</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*dst,<span class="keyword">const</span> <span class="keyword">char</span>*src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">while</span> (*dst != <span class="string">'\0'</span>)	</span><br><span class="line">        dst++;<span class="comment">//要在循环体内++；因为要是*strDest最后指向该字符串的结束标志’\0’</span></span><br><span class="line">	<span class="keyword">while</span> ((*dst++ = *src++) != <span class="string">'\0'</span>);<span class="comment">//赋值+自增+判断非结尾</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcmp">strcmp</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!str1 || !str2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (*str1 == *str2 &amp;&amp; str1 != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		str1++;</span><br><span class="line">		str2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="memmove">memmove</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *pdst, <span class="keyword">const</span> <span class="keyword">void</span>* psrc, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pdst || !psrc)   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span>* dst = (<span class="keyword">char</span>*)pdst;</span><br><span class="line">	<span class="keyword">char</span> *src = (<span class="keyword">char</span>*)psrc;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">if</span> (dst &lt; src || dst &gt;(src + n - <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst++) = *(src++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dst = dst + n - <span class="number">1</span>;</span><br><span class="line">		src = src + n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst--) = *(src--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="手写单例模式">手写单例模式</span></h3><p>线程安全懒汉式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // shared_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;  // mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt; Ptr;</span><br><span class="line">    ~Singleton()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"destructor called!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Singleton(Singleton&amp;)=delete;</span></span><br><span class="line">    <span class="comment">//Singleton&amp; operator=(const Singleton&amp;)=delete;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Ptr <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "double checked lock"</span></span><br><span class="line">        <span class="keyword">if</span>(m_instance_ptr==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(m_mutex);</span><br><span class="line">            <span class="keyword">if</span>(m_instance_ptr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">              m_instance_ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructor called!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Ptr m_instance_ptr;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialization static variables out of class</span></span><br><span class="line">Singleton::Ptr Singleton::m_instance_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton::Ptr instance = Singleton::get_instance();</span><br><span class="line">    Singleton::Ptr instance2 = Singleton::get_instance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="三个线程交替打印">三个线程交替打印</span></h3><hr>
<h3><span id="类模板和模板类的区别">类模板和模板类的区别？</span></h3><h3><span id="海量数据问题">海量数据问题</span></h3><h4><span id="十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</span></h4><p>类似问题的解决方法思路：首先哈希将数据分成 <code>N</code> 个文件，然后对每个文件建立 <code>K</code> 个元素最小/大堆（根据要求来选择）。最后将文件中剩余的数插入堆中，并维持 <code>K</code> 个元素的堆。最后将 <code>N</code> 个堆中的元素合起来分析。可以采用归并的方式来合并。在归并的时候为了提高效率还需要建一个 <code>N</code> 个元素构成的最大堆，先用 <code>N</code> 个堆中的最大值填充这个堆，然后就是弹出最大值，指针后移的操作了。当然这种问题在现在的互联网技术中，一般就用 <code>map-reduce</code> 框架来做了。<br>大数据排序相同的思路：先哈希（哈希是好处是分布均匀，相同的数在同一个文件中），然后小文件装入内存快排，排序结果输出到文件。最后建堆归并。</p>
<h4><span id="十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></h4><p>在大规模数据处理中，常遇到的一类问题是，在海量数据中找出出现频率最高的前K个数，或者从海量数据中找出最大的前K个数，这类问题通常称为<strong>top K</strong>问题，如：在搜索引擎中，统计搜索最热门的 <code>10</code>个查询词；在歌曲库中统计下载率最高的前10首歌等等。</p>
<p>针对 <strong>top k</strong>类问题，通常比较好的方案是<strong>分治+trie树/hash+小顶堆</strong>，即先将数据集按照 <code>hash</code> 方法分解成多个小数据集，然后使用 <code>trie</code> 树或者 <code>hash</code> 统计每个小数据集中的 <code>query</code> 词频，之后用小顶堆求出每个数据集中出频率最高的前 <code>K</code> 个数，最后在所有 <code>top K</code> 中求出最终的 <code>top K</code> 。</p>
<hr>
<h3><span id="布隆过滤器">布隆过滤器</span></h3><h4><span id="什么情况下需要布隆过滤器">什么情况下需要布隆过滤器？</span></h4><ul>
<li>字处理软件中，需要检查一个英语单词是否拼写正确</li>
<li>在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上</li>
<li>在网络爬虫里，一个网址是否被访问过</li>
<li>yahoo, gmail等邮箱垃圾邮件过滤功能</li>
<li>如果一个黑名单网站包含100亿个黑名单网页，每个网页最多占64B，设计一个系统，判断当前的URL是否在这个黑名单当中，要求额外空间不超过30GB，允许误差率为万分之一。这种情况，如果全都在内存中查询的话，需要的内存是640GB。</li>
</ul>
<h4><span id="布隆过滤器的原理">布隆过滤器的原理。</span></h4><p><strong>布隆过滤器</strong>(Bloom Filter)是由布隆(Burton Howard Bloom)在1970年提出的。它实际上是由<strong>一个很长的二进制向量和一系列随机映射函数</strong>组成。</p>
<p>布隆过滤器可以用于<strong>检索一个元素是否在一个集合</strong>中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p><img src="https://pic1.zhimg.com/80/v2-da022f1196cfbe2f439a21cd64208e10_720w.jpg" alt="img"></p>
<h4><span id="位图bitmap">位图(bitmap)</span></h4><p>布隆过滤器其中重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有1个 <code>bit</code> ，而每个 <code>bit</code> 只有 <code>0</code> 和 <code>1</code> 两种状态。如上图 <code>bit array</code> 所示。<code>bit array</code> 也叫 <code>bitmap</code> ，大小也就是布隆过滤器的大小。</p>
<p>假设我们有 <code>k</code> 个哈希函数，且每个哈希函数的输出范围都大于 <code>m</code> ，接着将输出值对 <code>k</code> 取余（%m）,就会得到 <code>k</code> 个 <code>[0, m-1]</code> 的值，由于每个哈希函数之间相互独立，因此这 <code>k</code> 个数也相互独立，最后将这 <code>k</code> 个数对应到<code>bitarray</code> 上并标记为 <code>1</code> 。</p>
<p>等到要判断某一个元素是否存在时，将输入对象经过这 <code>k</code> 个哈希函数计算得到 <code>k</code> 个值，然后判断对应 <code>bitarray</code> 的 <code>k</code> 个位置是否都为 <code>1</code> ，<strong>如果有一个不为1，那么这个输入对象则不在这个集合中；如果都是黑，那说明在集合中，但有可能会误判</strong>，由于当输入对象过多，而集合也就是 <code>bitarray</code> 过小，则会出现大部分为黑的情况，那样就容易发生误判！因此使用布隆过滤器是需要容忍错误率的，即使很低很低！</p>
<h4><span id="布隆过滤器大小计算">布隆过滤器大小计算</span></h4><p>假设输入对象个数为 <code>n</code> ，<code>bitarray</code> 大小（也就是布隆过滤器大小）为 <code>m</code> ，所容忍的误判率 <code>p</code> 和哈希函数的个数 <code>k</code> 。计算公式如下：（<strong>小数向上取整</strong>）</p>
<p><img src="https://pic1.zhimg.com/80/v2-fc1fb96508a363b17d1bb7737dc51e54_720w.jpg" alt="img"></p>
<p>假设一个网页黑名单有URL为100亿，每个样本为64B，失误率为0.01%，经过上述公式计算后，需要布隆过滤器大小为25GB，这远远小于使用哈希表的640GB的空间。</p>
<p>并且由于是通过 <code>hash</code> 进行查找的，所以基本都可以在 <code>O(1)</code> 的时间完成。</p>
<h4><span id="布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</span></h4><hr>
<h3><span id="stl">STL</span></h3><h4><span id="hash-map冲突如何解决">Hash Map冲突如何解决？</span></h4><p>哈希表（Hash table，也叫散列表）， 是根据关键码值( <code>Key value</code> )而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p><strong>直接定址</strong>与<strong>解决冲突</strong>是哈希表的两大特点。</p>
<h5><span id="哈希函数">哈希函数</span></h5><ol>
<li><strong>直接定制法</strong>：哈希函数为关键字的线性函数如  $H(key)=a\times key+b$</li>
<li><strong>数字分析法</strong>：此种方法通常用于数字位数较长的情况，必须数字存在一定规律，其必须知道数字的分布情况</li>
<li><strong>平方取中法</strong>：如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。这种方法适合<strong>事先不知道数据并且数据长度较小的情况</strong></li>
<li><strong>折叠法</strong>：如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为 <code>hash</code> 地址。</li>
<li><strong>除留余数法</strong>：<code>H(key)=key MOD p</code> (p&lt;=m m为表长) <code>p</code> 应为不大于 <code>m</code> 的质数或是不含 <code>20</code> 以下的质因子的合数，这样可以减少地址的重复(冲突)。</li>
</ol>
<h5><span id="哈希冲突解决方案">哈希冲突解决方案</span></h5><ol>
<li><p><strong>开放定制法</strong></p>
<p>对于哈希函数 <code>H(key)</code> ，如果 $key_1$ 和 $key_i$ 哈希冲突，那么 $key_i$ 存储的位置为 $H_i=(H(key)+d_i)mod (m)$</p>
<ol>
<li><p><strong>线性探测再散列</strong>：$d_i=c∗i$</p>
<p>例如可以取 $d_i=1$，即冲突后存储在冲突后一个位置，如果仍然冲突继续向后线性探测。</p>
</li>
<li><p><strong>平方探测再散列</strong>：$d_i=1^2,-1^2,2^2,-2^2……$</p>
</li>
<li><p>随机探测再散列(双探测再散列)：$d_i$ 是一组伪随机数列</p>
</li>
</ol>
</li>
<li><p><strong>链地址法</strong></p>
<p>产生 <code>hash</code> 冲突后在存储数据后面加一个指针，指向后面冲突的数据(链地址法是可以直接删除元素的)</p>
<p><img src="https://img-blog.csdn.net/20180520012305597" alt="这里写图片描述"></p>
</li>
<li><p><strong>公共溢出区法</strong><br>建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。</p>
</li>
<li><p><strong>再散列法(rehash)</strong></p>
<p>准备若干个 <code>hash</code> 函数，如果使用第一个 <code>hash</code> 函数发生了冲突，就使用第二个 <code>hash</code> 函数，第二个也冲突，使用第三个……</p>
</li>
</ol>
<hr>
<h4><span id="hash_map扩容发生什么">Hash_map扩容发生什么</span></h4><ol>
<li>创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到<em>sqrt</em>(<em>n</em>)范围内的数)  </li>
<li>将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换)</li>
<li>通过swap函数将新桶和旧桶交换，销毁新桶</li>
</ol>
<hr>
<h4><span id="unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</span></h4><p><code>HashSet(unordered_set)</code> 和 <code>HashMap(unordered_map)</code> 都是以 <code>hashtable</code> 作为底层机制，提供与 <code>set</code> 和<code>map</code> 完全相同的操作，但是 <code>Hash</code> 版本的容器不提供自动排序的功能，非 <code>Hash</code> 的版本是以 <code>RB-tree</code> 作为底层机制，也就提供排序的能力。总体来说，<code>hash_map</code> 查找速度会比 <code>map</code> 快，而且查找速度基本和数据数据量大小，属于常数级别；而 <code>map</code> 的查找速度是 <code>log(n)</code> 级别。</p>
<h5><span id="map与unordered_map的区别">map与unordered_map的区别</span></h5><p>他们俩存储时是根据 <code>key</code> 的 <code>hash</code> 值判断元素是否相同，而 <code>unordered_map</code> 内部元素是无序的，<code>map</code> 中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时 <code>map</code> 的 <code>key</code> 需要定义<code>operator&lt;</code>。而 <code>unordered_map</code> 需要定义 <code>hash_value</code> 函数并且重载 <code>operator==</code> 。但是很多系统内置的数据类型都自带这些。总结： <code>map</code> 重载 <code>&lt;</code> 运算符，<code>unordered_map</code> 重载 <code>==</code> 运算符。</p>
<p><strong>set/map</strong>底层实现的机制是<strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，默认是按升序排序的。在红黑树上做查找、插入、删除操作的时间复杂度为 <code>O(logN)</code> 。(<strong>比较稳定</strong>)</p>
<p><strong>红黑树的缺点</strong>：空间占用率高，每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</p>
<p><strong>std::unordered_map</strong>对应哈希表，哈希表的特点就是<strong>查找效率高</strong>，时间复杂度为常数级别<strong>O(1)</strong>，而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 <code>std::unordered_map</code> 容器。而如果对<strong>内存大小比较敏感</strong>或者<strong>数据存储要求有序</strong>的话，则可以用 <code>std::map</code> 容器。</p>
<h5><span id="为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？红黑树查询效率为什么快？</span></h5><p>红黑树不仅是作为 <code>AVL</code> 的工程版本，在增加节点颜色、不严格平滑等特性实现了更高效的插入和删除。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。<strong>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种弱平衡二叉树，相对于要求严格的 <code>AVL</code> 树来说，它的<strong>旋转次数少</strong>，所以对于<strong>搜索，插入，删除操作较多的情况</strong>下，通常使用红黑树。<code>AVL</code> 树是高度平衡的，频繁的插入和删除，会引起频繁的 <code>rebalance</code> ，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多<strong>两次</strong>旋转，删除最多<strong>三次</strong>旋转。</p>
<p>红黑树满足以下特征：</p>
<ol>
<li><strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</strong></li>
<li><strong>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;=2bd</strong></li>
<li><strong>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;=2log(n+1)</strong></li>
</ol>
<h4><span id="为何map和set的插入删除效率比用其他序列容器高">为何map和set的插入删除效率比用其他序列容器高？</span></h4><p>对于<strong>关联容器</strong>来说，不需要做内存拷贝和内存移动。说对了，确实如此。<code>map</code> 和 <code>set</code> 容器内所有元素都是以红黑树节点（如下）的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line">  /  \</span><br><span class="line"> B    C</span><br><span class="line">/ \  /  \</span><br><span class="line">D E  F  G</span><br></pre></td></tr></table></figure>
<p>因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点就OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p>
<h5><span id="为什么每次insert之后以前保存的iterator不会失效">为什么每次insert之后，以前保存的iterator不会失效</span></h5><p><code>iterator</code> 这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于 <code>vector</code> 来说，每一次删除和插入，指针都有可能失效，调用 <code>push_back</code> 在尾部插入也是如此。因为为了保证内部数据的连续存放，<code>iterator</code> 指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时 <code>push_back</code> 的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。</p>
<hr>
<h4><span id="vector相关">vector相关</span></h4><h5><span id="vector空间的动态增长">vector空间的动态增长</span></h5><h5><span id="vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</span></h5><hr>
<h4><span id="stl里的内存池实现">STL里的内存池实现</span></h4><p>首先我们需要明确, 内存池的目的到底是什么?我们每次使用 <code>new T</code> 来初始化类型 <code>T</code> 的时候, 其实发生了<strong>两步</strong>操作：</p>
<p> 第一步是<strong>内存分配</strong>， 这一步使用的其实不是 <code>new</code> 而是 <code>operator new</code> (也可以认为就是C语言中的 <code>malloc</code> )，这一步是直接和操作系统打交道的，操作系统可能需要经过相对繁琐的过程才能将一块指向空闲内存的指针返回给用户，所以这也是 <code>new</code> 比较耗时的一部分。</p>
<p>第二步是<strong>使用构造函数初始化该内存</strong>，这是我们比较熟悉。既然内存分配耗时。那我们很容易想到的就是一次性分配一大块内存，然后在用户需要的时候再划分其中一部分给用户。这样<strong>一次分配，多次使用</strong>， 自然而然提高了效率。而用来<strong>管理这所谓的一大块内存的数据结构</strong>，也就是今天我们要说的<strong>内存池</strong>。另外一个好处在于，频繁地使用 <code>new</code> 将导致系统内存空间碎片化严重，容易导致的后果就是很难找到一块连续的大块内存，空间利用率低。</p>
<p><code>STL</code> 内存分配分为<strong>一级分配器</strong>和<strong>二级分配器</strong>，一级分配器就是采用<strong>malloc分配内存</strong>，二级分配器采用<strong>内存池</strong>。</p>
<p>第二级配置器目的解决小型区块造成的内存碎片问题。</p>
<p>二级分配器设计的非常巧妙，分别给 <code>8byte</code> ，<code>16byte</code> ,…, <code>128byte</code> 等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块 <code>10K</code> 的内存，那么就找到最小的大于等于 <code>10byte</code> 的块，也就是 <code>16byte</code> ，从 <code>16byte</code> 的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。如果要分配的内存大于 <code>128byte</code> 则直接调用一级分配器。为了节省维持链表的开销，内存池采用了一个 <code>union</code> 结构体，分配器使用 <code>union</code> 里的 <code>next</code> 指针来指向下一个节点，而用户则使用 <code>union</code> 的空指针来表示该节点的地址。</p>
<p>使用<strong>自由链表(free-list)技巧</strong>。主动将不论什么小额区块的内存需求量上调至 <code>8</code> 的倍数。如需求 <code>30</code> ，则上调至<code>32</code> 。内存池可以认为由上面的一个<strong>指针数组</strong>和下面的<strong>自由链表</strong>两部分组成, 指针数组中第一个指针指向的是存放内存大小为 <code>8bytes</code> 的节点串接而成的自由链表, 之后依次是内存 <code>16bytes</code> , <code>24bytes</code> 直到 <code>128bytes</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Align = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MaxBytes = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfFreeLists = MaxBytes / Align;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfAddedNodesForEachTime = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span> MemNode &#123;</span><br><span class="line">		MemNode*	_next;</span><br><span class="line">		<span class="keyword">char</span>		_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> obj *freeLists[NumberOfFreeLists];</span><br></pre></td></tr></table></figure>
<p><code>union</code> 每个成员的起始地址都是开头的位置，所以每次仅能使用一个成员，在链表中由<code>_next</code> 指向下个内存块的地址，在分配内存时由 <code>_data</code> 指向内存首地址，长度为1 的数组放在结构体最后一个成员位置，可以访问给结构体多分配的地址空间，这种技术叫做<strong>柔性数组</strong>。这样做的好处减少了对内存块管理时额外的内存损耗。想想我们学习数据结构时实现的链表，都是通过结构体的一个成员来指向下个节点的地址，多出了一个指针 <code>4Byte</code> 的内存消耗。参考 <code>STL</code> ，内存块的管理如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="内存块示意图"></p>
<h5><span id="内存的分配和回收">内存的分配和回收</span></h5><p><img src="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>每次从系统申请内存时都通过一个辅助函数将内存增到为 <code>8</code> 的倍数，上层请求内存时寻找最小能容纳当前请求的头节点索引；当找到索引位置时，如果内存块不为空，则取出当前内存块，将之后的链表节点向前移动，如果内存不够的话，再次向系统请求新的内存。内存回收时与此理相同，通过辅助函数找到索引位置，将内存块放入首部位置，之前的内存块后移。</p>
<hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/19/316. 去除重复字母/" rel="next" title="Leetcode_316 去除重复字母">
                <i class="fa fa-chevron-left"></i> Leetcode_316 去除重复字母
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/24/操作系统总结/" rel="prev" title="操作系统总结">
                操作系统总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">342</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">90</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">C++线程中的几种锁/互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.</span> <span class="nav-text">互斥锁(Mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.</span> <span class="nav-text">条件变量(condition_variable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.</span> <span class="nav-text">自旋锁(spinlock_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.</span> <span class="nav-text">读写锁(shared_mutex)/共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.</span> <span class="nav-text">递归锁(recursive_mutex)/可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.</span> <span class="nav-text">定时锁(time_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.</span> <span class="nav-text">两种基本的锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">条件变量中只能使用unique_lock&lt; std::mutex &gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">C++中原子类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.</span> <span class="nav-text">C++中thread操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">std::thread构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.</span> <span class="nav-text">detach()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.</span> <span class="nav-text">wait()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.5.</span> <span class="nav-text">wait_for()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.6.</span> <span class="nav-text">notify_all/notify_one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.7.</span> <span class="nav-text">虚假唤醒</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.</span> <span class="nav-text">C++多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.</span> <span class="nav-text">多态有哪几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.2.</span> <span class="nav-text">虚函数的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.4.</span> <span class="nav-text">为什么析构函数必须是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.5.</span> <span class="nav-text">为什么C++默认的析构函数不是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.6.</span> <span class="nav-text">为什么构造函数不能是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.7.</span> <span class="nav-text">静态成员及静态成员函数能不能被继承？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.8.</span> <span class="nav-text">友元可以继承吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.9.</span> <span class="nav-text">虚函数(virtual)可以是内联函数(inline)吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.10.</span> <span class="nav-text">多态中构造函数/析构函数调用顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.11.</span> <span class="nav-text">类成员函数中重载/重写/隐藏的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.12.</span> <span class="nav-text">钻石继承问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.</span> <span class="nav-text">C++的四种cast</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.2.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.3.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.4.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.5.</span> <span class="nav-text">哪种cast更加接近C的强制类型转换？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.</span> <span class="nav-text">C++智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.1.</span> <span class="nav-text">auto_ptr(弃用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.2.</span> <span class="nav-text">unique_ptr(替换auto_ptr)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.3.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.4.</span> <span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.5.</span> <span class="nav-text">智能指针是线程安全的吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.</span> <span class="nav-text">C++对象的内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.1.</span> <span class="nav-text">普通对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.2.</span> <span class="nav-text">派生类的对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.3.</span> <span class="nav-text">vtable中虚函数指针的排列顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.</span> <span class="nav-text">Volitale关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.1.</span> <span class="nav-text">volatile指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.2.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">什么是可见性？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.9.</span> <span class="nav-text">C++中指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.</span> <span class="nav-text">C++中new与malloc的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.</span> <span class="nav-text">C++ 内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.</span> <span class="nav-text">C++存储类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.1.</span> <span class="nav-text">auto 自动变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.2.</span> <span class="nav-text">register 寄存器变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.3.</span> <span class="nav-text">static 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.4.</span> <span class="nav-text">extern关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.5.</span> <span class="nav-text">mutable 存储类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.6.</span> <span class="nav-text">thread_local 存储类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.</span> <span class="nav-text">std::move()语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.</span> <span class="nav-text">右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.3.</span> <span class="nav-text">右值引用有办法指向左值吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.4.</span> <span class="nav-text">完美转发 std::forward()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.5.</span> <span class="nav-text">auto&amp;&amp;也是这个意思</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.</span> <span class="nav-text">C++内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.1.</span> <span class="nav-text">内联函数有什么优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.3.</span> <span class="nav-text">将内联函数放入头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.4.</span> <span class="nav-text">内联函数与宏定义的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.5.</span> <span class="nav-text">explicit关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.6.</span> <span class="nav-text">union 联合体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.17.</span> <span class="nav-text">必须在构造函数初始化列表里进行初始化的数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.18.</span> <span class="nav-text">定位内存泄露及检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.</span> <span class="nav-text">手写strcpy，memcpy，strcat，strcmp等函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.1.</span> <span class="nav-text">strcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.2.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.3.</span> <span class="nav-text">strlen</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.4.</span> <span class="nav-text">strcat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.5.</span> <span class="nav-text">strcmp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.</span> <span class="nav-text">memmove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.</span> <span class="nav-text">手写单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.22.</span> <span class="nav-text">三个线程交替打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.</span> <span class="nav-text">类模板和模板类的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.</span> <span class="nav-text">海量数据问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.1.</span> <span class="nav-text">十亿整数（随机生成，可重复）中前K最大的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.2.</span> <span class="nav-text">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.</span> <span class="nav-text">布隆过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.1.</span> <span class="nav-text">什么情况下需要布隆过滤器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.2.</span> <span class="nav-text">布隆过滤器的原理。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.3.</span> <span class="nav-text">位图(bitmap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.4.</span> <span class="nav-text">布隆过滤器大小计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.5.</span> <span class="nav-text">布隆过滤器可能出现误判，怎么保证无误差？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.1.</span> <span class="nav-text">Hash Map冲突如何解决？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.1.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.1.2.</span> <span class="nav-text">哈希冲突解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.2.</span> <span class="nav-text">Hash_map扩容发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.3.</span> <span class="nav-text">Unordered_map和map底层实现有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.3.1.</span> <span class="nav-text">map与unordered_map的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.3.2.</span> <span class="nav-text">为什么用红黑树？红黑树查询效率为什么快？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.4.</span> <span class="nav-text">为何map和set的插入删除效率比用其他序列容器高？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.4.1.</span> <span class="nav-text">为什么每次insert之后，以前保存的iterator不会失效</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.5.</span> <span class="nav-text">vector相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.5.1.</span> <span class="nav-text">vector空间的动态增长</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.5.2.</span> <span class="nav-text">vector底层数据结构，vector底层是如何删除元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.6.</span> <span class="nav-text">STL里的内存池实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.6.1.</span> <span class="nav-text">内存的分配和回收</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
