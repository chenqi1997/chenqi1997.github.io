<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,C++,">










<meta name="description" content="C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;gt;     RAI">
<meta name="keywords" content="基础知识,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="Cq的Blog">
<meta property="og:url" content="http://chenqi1997.github.io/2020/12/22/C++基础总结/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;gt;     RAI">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX84lfZ0rGm9ia1ZzvLTT2I1udpL0BDt6F9StbnKg2TJVg0d6LbOoV97nzn2axKhb0sKV4MAKgGP1kg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img-blog.csdn.net/20180827214626276?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827214736229?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827215540235?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827215608475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827220036482?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827220133990?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827220613306?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827220946739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180827221411477?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613564872855.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019051218542467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTkyMDQ4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-da022f1196cfbe2f439a21cd64208e10_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-fc1fb96508a363b17d1bb7737dc51e54_720w.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20180520012305597">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613806083822.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:updated_time" content="2021-02-23T14:47:50.622Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cq的Blog">
<meta name="twitter:description" content="C++基础 C++线程中的几种锁/互斥量 互斥锁(Mutex) 条件变量(condition_variable) 自旋锁(spinlock_mutex) 读写锁(shared_mutex)/共享锁 递归锁(recursive_mutex)/可重入锁 定时锁(time_mutex) 两种基本的锁类型 条件变量中只能使用unique_lock&amp;lt; std::mutex &amp;gt;     RAI">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/12/22/C++基础总结/">





  <title> | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/12/22/C++基础总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-22T17:46:00+08:00">
                2020-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#c基础">C++基础</a><ul>
<li><a href="#c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</a><ul>
<li><a href="#互斥锁mutex">互斥锁(Mutex)</a></li>
<li><a href="#条件变量condition_variable">条件变量(condition_variable)</a></li>
<li><a href="#自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</a></li>
<li><a href="#读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</a></li>
<li><a href="#递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</a></li>
<li><a href="#定时锁time_mutex">定时锁(time_mutex)</a></li>
<li><a href="#两种基本的锁类型">两种基本的锁类型</a><ul>
<li><a href="#条件变量中只能使用unique_lock-stdmutex">条件变量中只能使用unique_lock&lt; std::mutex &gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#raii资源获取即初始化">RAII/资源获取即初始化</a></li>
<li><a href="#c中原子操作cas">C++中原子操作/CAS</a><ul>
<li><a href="#cas">CAS</a><ul>
<li><a href="#gcc41">GCC4.1+</a></li>
<li><a href="#c11">C++11</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c中thread操作">C++中thread操作</a><ul>
<li><a href="#stdthread构造">std::thread构造</a></li>
<li><a href="#join">join()</a></li>
<li><a href="#detach">detach()</a></li>
<li><a href="#wait成员函数">wait()成员函数</a></li>
<li><a href="#wait_for成员函数">wait_for()成员函数</a></li>
<li><a href="#notify_allnotify_one">notify_all/notify_one</a></li>
<li><a href="#虚假唤醒">虚假唤醒</a></li>
</ul>
</li>
<li><a href="#面向对象的三大特性">面向对象的三大特性</a><ul>
<li><a href="#继承">继承</a></li>
<li><a href="#封装">封装</a></li>
<li><a href="#多态">多态</a></li>
</ul>
</li>
<li><a href="#c11新特性">C++11新特性</a></li>
<li><a href="#c模板">⭐C++模板</a><ul>
<li><a href="#模板类存放位置h">模板类存放位置(.h)</a></li>
<li><a href="#模板类是什么时候实例化的">模板类是什么时候实例化的</a></li>
<li><a href="#模板代码class声明和定义能够写在不同的文件吗">模板代码class声明和定义能够写在不同的文件吗</a></li>
<li><a href="#模板类中能够使用虚函数吗">模板类中能够使用虚函数吗</a></li>
<li><a href="#模板函数和模板类的特例化">模板函数和模板类的特例化</a><ul>
<li><a href="#引入原因"><strong>引入原因</strong></a></li>
<li><a href="#定义"><strong>定义</strong></a></li>
</ul>
</li>
<li><a href="#类模板和模板类的区别">类模板和模板类的区别？</a></li>
</ul>
</li>
<li><a href="#c多态">⭐C++多态</a><ul>
<li><a href="#多态有哪几种">多态有哪几种？</a></li>
<li><a href="#虚函数">虚函数</a><ul>
<li><a href="#虚表指针的初始化时间">虚表指针的初始化时间</a></li>
</ul>
</li>
<li><a href="#动态绑定">动态绑定</a></li>
<li><a href="#虚继承与虚函数">虚继承与虚函数</a><ul>
<li><a href="#虚继承要解决的问题">虚继承要解决的问题</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#为什么析构函数必须是虚函数">⭐为什么析构函数必须是虚函数？</a></li>
<li><a href="#为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</a></li>
<li><a href="#为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</a></li>
<li><a href="#静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</a></li>
<li><a href="#友元可以继承吗">友元可以继承吗？</a></li>
<li><a href="#虚函数virtual可以是内联函数inline吗当虚函数表现多态性的时候不能内联">虚函数(virtual)可以是内联函数(inline)吗？(当虚函数表现多态性的时候不能内联)</a></li>
<li><a href="#多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</a></li>
<li><a href="#类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</a></li>
<li><a href="#钻石继承问题">钻石继承问题</a></li>
</ul>
</li>
<li><a href="#c的四种构造函数">C++的四种构造函数</a><ul>
<li><a href="#拷贝构造函数和赋值运算符重载的区别">拷贝构造函数和赋值运算符重载的区别？</a></li>
</ul>
</li>
<li><a href="#c的四种cast">C++的四种cast</a><ul>
<li><a href="#static_cast">static_cast</a></li>
<li><a href="#const_cast">const_cast</a></li>
<li><a href="#reinterpret_cast">reinterpret_cast</a></li>
<li><a href="#dynamic_cast">⭐dynamic_cast</a></li>
<li><a href="#哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</a></li>
</ul>
</li>
<li><a href="#c智能指针">C++智能指针</a><ul>
<li><a href="#auto_ptr弃用">auto_ptr(弃用)</a></li>
<li><a href="#unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
<li><a href="#weak_ptr">weak_ptr</a><ul>
<li><a href="#weak_ptr是用来解决shared_ptr相互引用时的死锁问题"><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题：</strong></a></li>
<li><a href="#weak_ptr是不保证内存有效的">weak_ptr是不保证内存有效的</a></li>
<li><a href="#如何判断weak_ptr的对象是否失效">如何判断weak_ptr的对象是否失效？</a></li>
</ul>
</li>
<li><a href="#智能指针原理">智能指针原理</a></li>
<li><a href="#智能指针是线程安全的吗">智能指针是线程安全的吗？</a></li>
</ul>
</li>
<li><a href="#cthis指针">C++this指针</a></li>
<li><a href="#c对象的内存模型">C++对象的内存模型</a><ul>
<li><a href="#普通对象模型">普通对象模型</a><ul>
<li><a href="#类的对象存储空间大小">类的对象存储空间大小</a></li>
</ul>
</li>
<li><a href="#派生类的对象模型">派生类的对象模型</a><ul>
<li><a href="#派生类构造函数执行顺序">派生类构造函数执行顺序</a></li>
</ul>
</li>
<li><a href="#vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</a></li>
<li><a href="#空类含有虚函数的类的大小">空类/含有虚函数的类的大小</a><ul>
<li><a href="#为何空类的大小不是0呢">为何空类的大小不是0呢？</a></li>
<li><a href="#继承关系中的类大小">继承关系中的类大小</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c内存分区">C++内存分区</a></li>
<li><a href="#c中指针和引用的区别">C++中指针和引用的区别</a></li>
<li><a href="#c中new与malloc的区别">C++中new与malloc的区别</a><ul>
<li><a href="#newdelete是如何实现的">new/delete是如何实现的？</a></li>
<li><a href="#mallocfree是如何实现的">malloc/free是如何实现的？</a></li>
<li><a href="#delete和delete区别">delete和delete[]区别</a></li>
<li><a href="#malloccallocrealloc函数">malloc/calloc/realloc函数</a><ul>
<li><a href="#malloc函数">malloc函数</a></li>
<li><a href="#calloc函数">calloc函数</a></li>
<li><a href="#realloc函数">realloc函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c-内存对齐">C++ 内存对齐</a></li>
<li><a href="#c存储类型">C++存储类型</a><ul>
<li><a href="#auto-自动变量">auto 自动变量</a></li>
<li><a href="#register-寄存器变量">register 寄存器变量</a></li>
<li><a href="#extern关键字">extern关键字</a></li>
<li><a href="#thread_local-存储类">thread_local 存储类</a></li>
</ul>
</li>
<li><a href="#static-关键字">static 关键字</a><ul>
<li><a href="#隐藏">隐藏</a></li>
<li><a href="#持久static变量中的记忆功能和全局生存期">持久：static变量中的记忆功能和全局生存期</a></li>
<li><a href="#static成员函数不能被virtual修饰">static成员函数不能被virtual修饰</a></li>
</ul>
</li>
<li><a href="#const常量const函数">const常量/const函数</a><ul>
<li><a href="#const常量">const常量</a></li>
<li><a href="#const函数">const函数</a></li>
<li><a href="#const对象只能调用const成员函数">const对象：只能调用const成员函数</a></li>
<li><a href="#const形参">const形参</a></li>
</ul>
</li>
<li><a href="#堆和栈的区别">堆和栈的区别</a></li>
<li><a href="#c运算符重载">C++运算符重载</a></li>
<li><a href="#c中null和nullptr的区别">C++中NULL和nullptr的区别</a></li>
<li><a href="#cc源程序到可执行程序exe的全过程">C/C++源程序到可执行程序exe的全过程</a><ul>
<li><a href="#1-预处理生成testi">1. 预处理(生成test.i)</a></li>
<li><a href="#2-编译生成tests">2. 编译(生成test.s)</a></li>
<li><a href="#3-汇编生成testo">3. 汇编(生成test.o)</a></li>
<li><a href="#4-链接生成默认aout">4. 链接(生成默认a.out)</a><ul>
<li><a href="#静态链接">静态链接</a></li>
<li><a href="#动态链接">动态链接</a></li>
<li><a href="#目标文件">目标文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#右值引用">右值引用</a><ul>
<li><a href="#左值引用">左值引用</a></li>
<li><a href="#右值引用-1">右值引用</a></li>
<li><a href="#右值引用有办法指向左值吗">右值引用有办法指向左值吗</a></li>
<li><a href="#完美转发-stdforward">完美转发 std::forward()</a></li>
<li><a href="#auto也是这个意思">auto&amp;&amp;也是这个意思</a></li>
</ul>
</li>
<li><a href="#c内联函数">C++内联函数</a><ul>
<li><a href="#内联函数有什么优点">内联函数有什么优点？</a></li>
<li><a href="#内联函数适用场景">内联函数适用场景</a></li>
<li><a href="#缺点">缺点</a></li>
<li><a href="#构造函数-析构函数-虚函数可否声明为内联函数">构造函数、析构函数、虚函数可否声明为内联函数？</a><ul>
<li><a href="#构造函数和析构函数声明为内联函数是没有意义的"><strong>构造函数和析构函数声明为内联函数是没有意义的</strong></a></li>
<li><a href="#将虚函数声明为inline要分情况讨论"><strong>将虚函数声明为inline，要分情况讨论</strong></a></li>
</ul>
</li>
<li><a href="#将内联函数放入头文件">将内联函数放入头文件</a></li>
</ul>
</li>
<li><a href="#宏定义define">宏定义#Define</a><ul>
<li><a href="#宏定义和函数区别">宏定义和函数区别？</a></li>
<li><a href="#宏定义和typedef区别">宏定义和typedef区别？</a></li>
<li><a href="#宏定义与内联函数的区别">宏定义与内联函数的区别？</a></li>
<li><a href="#宏定义和const的区别">宏定义和const的区别</a><ul>
<li><a href="#编译阶段">编译阶段</a></li>
<li><a href="#安全性">安全性</a></li>
<li><a href="#内存占用">内存占用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c11类型说明符autodecltypedecltypeauto">C++11类型说明符auto/decltype/decltype(auto)</a><ul>
<li><a href="#auto">auto</a></li>
<li><a href="#decltype">decltype</a></li>
<li><a href="#decltypeauto">decltype(auto)</a></li>
</ul>
</li>
<li><a href="#volitalemutableexplicit关键字">Volitale/mutable/explicit关键字</a><ul>
<li><a href="#volitale关键字">Volitale关键字</a><ul>
<li><a href="#volatile指针">volatile指针</a></li>
<li><a href="#可见性">可见性</a></li>
</ul>
</li>
<li><a href="#mutable-关键字">mutable 关键字</a></li>
<li><a href="#explicit关键字">explicit关键字</a></li>
</ul>
</li>
<li><a href="#union-联合体">union 联合体</a></li>
<li><a href="#finaloverride关键字">final/override关键字</a><ul>
<li><a href="#override">override</a></li>
<li><a href="#final继承的终点">final(继承的终点)</a></li>
</ul>
</li>
<li><a href="#深拷贝与浅拷贝">深拷贝与浅拷贝</a><ul>
<li><a href="#深拷贝与浅拷贝的区别"><strong>深拷贝与浅拷贝的区别</strong></a></li>
</ul>
</li>
<li><a href="#拷贝初始化和直接初始化">拷贝初始化和直接初始化</a></li>
<li><a href="#必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</a><ul>
<li><a href="#成员初始化列表做了什么">成员初始化列表做了什么</a></li>
<li><a href="#赋值初始化与列表初始化的区别">赋值初始化与列表初始化的区别</a></li>
</ul>
</li>
<li><a href="#定位内存泄露及检测">定位内存泄露及检测</a></li>
<li><a href="#c函数调用的压栈过程">C++函数调用的压栈过程</a></li>
<li><a href="#手写strcpymemcpystrcatstrcmp等函数">手写strcpy，memcpy，strcat，strcmp等函数</a><ul>
<li><a href="#strcpy">strcpy</a></li>
<li><a href="#memcpy">memcpy</a></li>
<li><a href="#strlen">strlen</a></li>
<li><a href="#strcat">strcat</a></li>
<li><a href="#strcmp">strcmp</a></li>
<li><a href="#memmove">memmove</a></li>
</ul>
</li>
<li><a href="#c实现堆排序原地算法">⭐C++实现堆排序(原地算法)</a></li>
<li><a href="#手写单例模式">手写单例模式</a></li>
<li><a href="#三个线程交替打印">三个线程交替打印</a></li>
<li><a href="#海量数据问题">海量数据问题</a><ul>
<li><a href="#十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</a></li>
<li><a href="#十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</a></li>
</ul>
</li>
<li><a href="#布隆过滤器">布隆过滤器</a><ul>
<li><a href="#什么情况下需要布隆过滤器">什么情况下需要布隆过滤器？</a></li>
<li><a href="#布隆过滤器的原理">布隆过滤器的原理。</a></li>
<li><a href="#位图bitmap">位图(bitmap)</a></li>
<li><a href="#布隆过滤器大小计算">布隆过滤器大小计算</a></li>
<li><a href="#布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</a></li>
</ul>
</li>
<li><a href="#静态链接与动态链接">静态链接与动态链接</a></li>
<li><a href="#c抽象类和接口的区别">C++抽象类和接口的区别</a></li>
<li><a href="#c-traits-萃取">C++ traits 萃取</a></li>
<li><a href="#区别以下指针类型">区别以下指针类型</a></li>
<li><a href="#变量声明和定义的区别">变量声明和定义的区别</a></li>
<li><a href="#如何用代码判断大小端存储">如何用代码判断大小端存储</a><ul>
<li><a href="#强制类型转换判断法">强制类型转换判断法</a></li>
<li><a href="#union判断法">Union判断法</a></li>
<li><a href="#strlen和sizeof区别">strlen和sizeof区别</a></li>
<li><a href="#数组名和指向数组首元素的指针的区别">数组名和指向数组首元素的指针的区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#stl">STL</a><ul>
<li><a href="#stl六大部件">STL六大部件</a></li>
<li><a href="#hash-map冲突如何解决">Hash Map冲突如何解决？</a><ul>
<li><a href="#哈希函数">哈希函数</a></li>
<li><a href="#哈希冲突解决方案">哈希冲突解决方案</a></li>
</ul>
</li>
<li><a href="#hash_map扩容发生什么">Hash_map扩容发生什么</a></li>
<li><a href="#unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</a><ul>
<li><a href="#map与unordered_map的区别">map与unordered_map的区别</a></li>
<li><a href="#为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？红黑树查询效率为什么快？</a></li>
</ul>
</li>
<li><a href="#为何map和set的插入删除效率比用其他序列容器高">为何map和set的插入删除效率比用其他序列容器高？</a><ul>
<li><a href="#为什么每次insert之后以前保存的iterator不会失效">为什么每次insert之后，以前保存的iterator不会失效</a></li>
</ul>
</li>
<li><a href="#vector相关">vector相关</a><ul>
<li><a href="#vector空间的动态增长">vector空间的动态增长</a></li>
<li><a href="#vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</a></li>
<li><a href="#push_back时间复杂度">push_back()时间复杂度</a></li>
<li><a href="#push_back与emplace_back的区别">push_back与emplace_back的区别</a></li>
</ul>
</li>
<li><a href="#stl里的内存池实现">STL里的内存池实现</a><ul>
<li><a href="#内存的分配和回收">内存的分配和回收</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h2><span id="c基础">C++基础</span></h2><h3><span id="c线程中的几种锁互斥量">C++线程中的几种锁/互斥量</span></h3><p>C++线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong> 这几种。需要在进入临界区之前对互斥量 <code>lock</code> ，退出临界区时对互斥量 <code>unlock</code> ；当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。</p>
<h4><span id="互斥锁mutex">互斥锁(Mutex)</span></h4><p>互斥锁用于<strong>控制多个线程对他们之间共享资源互斥访问的一个信号量</strong>。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。</p>
<p>在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以<strong>阻塞方式</strong>进行等待。</p>
<p><strong>互斥锁是是一种sleep-waiting的锁</strong>。假设线程 <code>T1</code> 获取互斥锁并且正在 <code>core1</code> 上运行时，此时线程 <code>T2</code> 也想要获取互斥锁 (pthread_mutex_lock)，但是由于 <code>T1</code> 正在使用互斥锁使得 <code>T2</code> 被阻塞。当 <code>T2</code> 处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器 <code>core2</code> 会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p>
<p><strong>用法：</strong>在C++中，通过构造 <code>std::mutex</code> 的实例创建互斥元，调用成员函数 <code>lock()</code> 来锁定它，调用 <code>unlock()</code> 来解锁，不过一般不推荐这种做法，标准C++库提供了std::lock_guard类模板，实现了互斥元的 <code>RAII</code> 惯用语法。<code>std::mutex</code> 和 <code>std::lock_guard</code> 。都声明在 <code>&lt;mutex&gt;</code> 头文件中。</p>
<p><code>lock_guard</code> 对象通常用于管理某个锁(Lock)对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用互斥元保护列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list;</span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(some_mutex);</span><br><span class="line">    some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="条件变量condition_variable">条件变量(condition_variable)</span></h4><p>条件锁就是所谓的条件变量，某一个线程因为某个条件<strong>未满足</strong>时可以使用 <code>条件锁</code> 使该程序处于 <code>阻塞状态</code> 。</p>
<p>一旦条件满足，可以以 <code>信号量</code> 的方式唤醒一个因为该条件而被阻塞的线程。</p>
<p>条件变量的作用不是用来管理互斥量的，它的作用是用来<strong>同步线程</strong>，它的用法相当于编程中常见的 <code>flag</code> 标志（A、B两个人约定 <code>flag=true</code> 为行动号角，默认 <code>flag</code> 为 <code>false</code> ，A不断的检查 <code>flag</code> 的值,只要 <code>B</code> 将 <code>flag</code> 修改为 <code>true</code> ，<code>A</code> 就开始行动）。类比到 <code>condition_variable</code>，A、B两个人约定 <code>notify_one</code> 为行动号角，<code>A</code>就等着（调用 <code>wait()</code> ，阻塞）,只要 <code>B</code> 一调用 <code>notify_one</code> ，A就开始行动（不再阻塞）。</p>
<p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为 <code>任务队列为空</code> 这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用std::condition_variable等待数据</span></span><br><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);   <span class="comment">//这里使用unique_lock是为了后面方便解锁</span></span><br><span class="line">        data_cond.wait(lk,&#123;[]<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面，<code>wait()</code> 的实现接下来检查条件，并在满足时返回。如果条件不满足，wait()解锁互斥元，并将该线程置于阻塞或等待状态。当来自数据准备线程中对 <code>notify_one()</code> 的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从wait()返回值，互斥元仍被锁定。如果条件不满足，该线程解锁互斥元，并恢复等待。</p>
<hr>
<h4><span id="自旋锁spinlock_mutex">自旋锁(spinlock_mutex)</span></h4><p><em>自旋锁需要与互斥锁一起来比较理解。</em></p>
<p><strong>自旋锁是一种busy-waiting的锁</strong>。也就是说，如果 <code>T1</code> 正在使用自旋锁，而 <code>T2</code> 也去申请这个自旋锁，此时 <code>T2</code> 肯定得不到这个自旋锁。与互斥锁相反的是，此时运行 <code>T2</code> 的处理器 <code>core2</code> 会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p>
<p>从 <code>自旋锁</code> 的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一直占用 <code>CPU</code> 请求这个自旋锁使得 <code>CPU</code> 不能去做其他的事情，直到获取这个锁为止，这就是 <code>自旋</code> 的含义。</p>
<p>当发生阻塞时，互斥锁可以让 <code>CPU</code> 去处理其他的任务；而自旋锁让 <code>CPU</code> 一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道 <code>自旋锁</code> 是比较耗费 <code>CPU</code> 的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(<span class="keyword">spinlock_t</span> *x);<span class="comment">//初始化</span></span><br><span class="line">spin_lock(x);   			  <span class="comment">//只有在获得锁的情况下才返回，否则一直“自旋”</span></span><br><span class="line">spin_trylock(x);  			  <span class="comment">//如立即获得锁则返回真，否则立即返回假</span></span><br><span class="line">spin_unlock(x);				  <span class="comment">//释放锁</span></span><br><span class="line">spin_is_locked(x)			  <span class="comment">//该宏用于判断自旋锁x是否已经被某执行单元保持（即被锁），如果是，   返回真，否则返回假。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="读写锁shared_mutex共享锁">读写锁(shared_mutex)/共享锁</span></h4><p><code>std::shared_mutex</code>有两种访问级别：</p>
<ul>
<li><strong>共享：</strong>多个线程可以共享这个锁的拥有权。一般用于数据的<strong>读操作</strong>，防止数据被写修改。</li>
<li><strong>互斥：</strong>仅仅一个线程可以拥有这个锁。一般用于<strong>写操作</strong>。</li>
<li>如果一个线程已经获取了 <code>互斥锁</code> ，则其他线程都无法获取该锁。</li>
<li>如果一个线程已经获取了 <code>共享锁</code> ，则其他任何线程都无法获取 <code>互斥锁</code> ，但是可以获取 <code>共享锁</code> 。</li>
</ul>
<hr>
<h4><span id="递归锁recursive_mutex可重入锁">递归锁(recursive_mutex)/可重入锁</span></h4><p>我们都知道，一般的互斥量对于同一个线程只能同时加锁一次（调用 <code>lock</code> ），如果连续调用两次以上便会出现死锁。但设想这样一个场景，如果在一个函数内给互斥量上了锁还没有解开，然后又调用了另一个函数，这个被调用的函数也去给互斥量上锁，这种情境下就会出现死锁。</p>
<p>对于互斥锁，分为递归锁和非递归锁。在不同的线程中调用已锁定的互斥锁，必然会导致死锁。但是在<strong>同一个线程中，如果想要多次获得一个锁，只能使用递归锁</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MutexLock mutex;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    mutex.unlock();  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">    foo();  </span><br><span class="line">    mutex.unlock();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，引入了递归锁的概念。</p>
<p><strong>递归锁</strong>，顾名思义，<strong>如果因为多次函数调用而导致出现多次上锁的情况，只有第一次会去真正加锁，后面的加锁操作会被自动忽略。</strong></p>
<p><strong>recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁）</strong>，来获得对互斥量对象的<strong>多层所有权</strong>，<code>recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和 <code>unlock()</code> 次数相同，除此之外，<code>recursive_mutex</code> 的特性和<code>mutex</code> 大致相同。</p>
<hr>
<h4><span id="定时锁time_mutex">定时锁(time_mutex)</span></h4><p><code>std::time_mutex</code> 比 <code>std::mutex</code> 多了两个成员函数，<code>try_lock_for()</code> ，<code>try_lock_until()</code> 。</p>
<p><strong>try_lock_for</strong> 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 <code>std::mutex</code> 的 <code>try_lock()</code> 不同，<code>try_lock</code> 如果被调用时没有获得锁则直接返回 <code>false</code>），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code>。</p>
<p><strong>try_lock_until</strong> 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code> 。</p>
<hr>
<h4><span id="两种基本的锁类型">两种基本的锁类型</span></h4><p>C++11 标准为我们提供了两种基本的锁类型，分别如下：</p>
<ul>
<li><strong>std::lock_guard</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁。<ul>
<li><strong>lock_guard</strong> 对象通常用于管理某个锁( <code>Lock</code> )对象，因此与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 <code>shared_ptr</code> 等智能指针管理动态分配的内存资源 )。</li>
<li>在 <code>lock_guard</code> 对象构造时，传入的 <code>Mutex</code> 对象(即它所管理的 <code>Mutex</code> 对象)会被<strong>当前线程</strong>锁住。在<code>lock_guard</code> 对象被析构时，它所管理的 <code>Mutex</code> 对象会自动解锁，由于不需要程序员手动调用 <code>lock</code> 和 <code>unlock</code> 对 <code>Mutex</code> 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 <code>Mutex</code> 对象可以正确进行解锁操作，极大地简化了程序员编写与 <code>Mutex</code> 相关的异常处理代码。</li>
<li>值得注意的是，<code>lock_guard</code> 对象并不负责管理 <code>Mutex</code> 对象的生命周期，<code>lock_guard</code> 对象只是简化了 <code>Mutex</code> 对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁。</li>
</ul>
</li>
<li><strong>std::unique_lock</strong>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。<ul>
<li><strong>unique_lock</strong> 提供了更好的上锁和解锁控制。顾名思义，<code>unique_lock</code> 对象以独占所有权的方式(unique owership)管理 <code>mutex</code> 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权。</li>
<li>在构造(或移动(move)赋值)时，<code>unique_lock</code> 对象需要传递一个 <code>Mutex</code> 对象作为它的参数，新创建的 <code>unique_lock</code> 对象负责传入的 <code>Mutex</code> 对象的上锁和解锁操作。</li>
</ul>
</li>
</ul>
<h5><span id="条件变量中只能使用unique_locklt-stdmutex-gt">条件变量中只能使用unique_lock&lt; std::mutex &gt;</span></h5><p><code>unique_lock</code> 和 <code>lock_guard</code> 都是管理锁的辅助类工具，都是 <code>RAII(资源定义即初始化)</code> 风格；它们是在定义时获得锁，在析构时释放锁。它们的主要区别在于 <code>unique_lock</code> 锁机制更加灵活，可以再需要的时候进行 <code>lock</code> 或者 <code>unlock</code> 调用，不非得是析构或者构造时。它们的区别可以通过成员函数就可以一目了然。</p>
<hr>
<h3><span id="raii资源获取即初始化">RAII/资源获取即初始化</span></h3><ul>
<li>资源在析构函数中被释放</li>
<li>该类的实例是堆栈分配的</li>
<li>资源是在构造函数中获取的。</li>
</ul>
<p><strong>RAII</strong>可以用作 <code>new</code> 和 <code>delete</code> 的替代方法，以使对象独立于其范围而存在。 这种技术包括将指针分配到在堆上分配的对象，并将其放在句柄/管理器对象中。 后者具有一个析构函数，将负责销毁该对象。 这将确保该对象可用于任何想要访问它的函数，并且该对象在句柄对象的生存期结束时将被销毁，而无需进行显式清理。</p>
<p>来自C++标准库的使用 <code>RAII</code> 的示例为 <code>std :: string</code> 和 <code>std :: vector</code> 。</p>
<p>标准库中使用RAII的其他示例是 <code>std :: shared_ptr</code>，<code>std :: unique_ptr</code> 和 <code>std :: lock_guard</code> 。</p>
<hr>
<h3><span id="c中原子操作cas">C++中原子操作/CAS</span></h3><p><strong>std::atomic&lt;&gt;</strong>是一个模板类，使用该模板类实例化的对象，提供了<strong>一些保证原子性的成员函数</strong>来实现共享数据的常用操作。</p>
<p>可以这样理解： 在以前，定义了一个共享的变量 <code>int i=0</code>，多个线程会用到这个变量，那么每次操作这个变量时，都需要 <code>lock</code> 加锁，操作完毕 <code>unlock</code> 解锁，以保证线程之间不会冲突；但是这样每次加锁解锁、加锁解锁就显得很麻烦，那怎么办呢？ 现在，实例化了一个类对象 <code>std::atomic&lt;int&gt; I=0</code> 来代替以前的那个变量（这里的对象 <code>I</code> 你就把它看作一个变量，看作对象反而难以理解了），每次操作这个对象时，就不用 <code>lock</code> 与 <code>unlock</code> ，这个对象自身就具有原子性（相当于加锁解锁操作不用你写代码实现，能自动加锁解锁了），以保证线程之间不会冲突。</p>
<h4><span id="cas">CAS</span></h4><p><strong>CAS操作</strong>——<code>Compare &amp; Set</code> 或是 <code>Compare &amp; Swap</code>，<strong>现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。</strong>有了这个原子操作，我们就可以用其来实现各种无锁（<code>lock free</code>）的数据结构。</p>
<p>这个操作用 <code>C</code> 语言来描述就是下面这个样子：（代码来自<a href="http://en.wikipedia.org/wiki/Compare-and-swap" target="_blank" rel="noopener">Wikipedia的Compare And Swap</a>词条）意思就是说，看一看内存 <code>*reg</code> 里的值是不是 <code>oldval</code> ，如果是的话，则对其赋值 <code>newval</code> 。<code>CAS</code> 的语义是“我认为 <code>V</code> 的值应该为 <code>A</code> ，如果是，那么将 <code>V</code> 的值更新为 <code>B</code> ，否则不修改并告诉 <code>V</code> 的值实际为多少”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">     *reg = newval;</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span> *accum, <span class="keyword">int</span> *dest, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *accum == *dest ) &#123;</span><br><span class="line">      *dest = newval;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CAS</code> 是项<strong>乐观锁技术</strong>，当多个线程尝试使用 <code>CAS</code> 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<code>CAS</code> 有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>另一种表述：<code>CAS</code> 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间<strong>先比较下旧值有没有发生变化</strong>，<strong>如果没有发生变化，才交换成新值，发生了变化则不交换</strong>。</p>
<p>与 <code>CAS</code> 相似的还有下面的原子操作：</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Fetch-and-add" target="_blank" rel="noopener">Fetch And Add</a>，一般用来对变量做 <code>+1</code> 的原子操作</li>
<li><a href="http://en.wikipedia.org/wiki/Test-and-set" target="_blank" rel="noopener">Test-and-set</a>，写值到某个内存位置并传回其旧值。汇编指令 <code>BST</code> </li>
<li><a href="http://en.wikipedia.org/wiki/Test_and_Test-and-set" target="_blank" rel="noopener">Test and Test-and-set</a>，用来测试 <code>Test-and-Set</code> 的资源争夺情况。</li>
</ul>
<h5><span id="gcc41">GCC4.1+</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br></pre></td></tr></table></figure>
<h5><span id="c11">C++11</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">atomic_compare_exchange_weak</span>( <span class="title">std</span>:</span>:atomic&lt;T&gt;* obj,</span><br><span class="line">                                   T* expected, T desired );</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">atomic_compare_exchange_weak</span>( <span class="title">volatile</span> <span class="title">std</span>:</span>:atomic&lt;T&gt;* obj,</span><br><span class="line">                                   T* expected, T desired );</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c中thread操作">C++中thread操作</span></h3><h4><span id="stdthread构造">std::thread构造</span></h4><table>
<thead>
<tr>
<th>default (1)</th>
<th>thread() noexcept;</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialization (2)</td>
<td>template <class fn,="" class...="" args=""> explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;… args);</class></td>
</tr>
<tr>
<td>copy [deleted] (3)</td>
<td>thread (const thread&amp;) = delete;</td>
</tr>
<tr>
<td>move (4)</td>
<td>thread (thread&amp;&amp; x) noexcept;</td>
</tr>
</tbody>
</table>
<ol>
<li>默认构造函数，创建一个空的 thread 执行对象。</li>
<li>初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</li>
<li>拷贝构造函数(被禁用)，意味着 <strong>thread 不可被拷贝构造</strong>。只能用<strong>右值引用配合move赋值操作</strong>。</li>
<li>move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。</li>
</ol>
<p>注意：可被 <code>joinable</code> 的 <code>thread</code> 对象必须在他们销毁之前被主线程 <code>join</code> 或者将其设置为 <code>detached</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(<span class="built_in">std</span>::move(t3))</span></span>; <span class="comment">// t4 is now running f2(). t3 is no longer a thread</span></span><br></pre></td></tr></table></figure>
<h4><span id="join">join()</span></h4><ul>
<li>阻塞主线程，直至 <code>this</code> 所标识的线程完成其执行。<code>this</code> 所标识的线程的完成同步于从 <strong>join()</strong> 的成功返回。</li>
<li>该方法简单暴力，主线程等待子进程期间什么都不能做。<code>thread::join()</code> 会清理子线程相关的内存空间，此后<code>thread object</code> 将不再和这个子线程相关了，即 <code>thread object</code> 不再 <code>joinable</code> 了，所以 <code>join</code> 对于一个子线程来说只可以被调用一次，为了实现更精细的线程等待机制，可以使用条件变量等机制。</li>
</ul>
<h4><span id="detach">detach()</span></h4><ul>
<li>从调用线程中分离出对象所代表的线程，从而使它们彼此独立执行。两个线程继续运行，而不会阻塞或以任何方式进行同步。</li>
<li>请注意，当任何一个执行结束时，其资源将被释放。</li>
<li>调用此函数后，线程对象变得不可连接，并且可以安全地销毁。</li>
<li>使用 <code>detach</code> ，那么新线程就会与原线程分离，如果原线程先执行完毕，销毁线程对象及局部变量，并且<strong>新线程有共享变量或引用</strong>之类，这样新线程可能使用的变量，就变成未定义，产生异常或不可预测的错误。</li>
</ul>
<h4><span id="wait成员函数">wait()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock )</span></span>;</span><br><span class="line"><span class="comment">//Predicate 谓词函数，可以普通函数或者lambda表达式</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );</span><br></pre></td></tr></table></figure>
<p><code>wait</code>  导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，可选地循环<strong>直至满足某谓词</strong>。条件变量的wait所必须是<strong>unique_lock而</strong>不是lock_guard，因为wait会在内部调用<strong>unique_lock.unlock</strong>先解锁，当被唤醒后，条件满足时，会<strong>unique_lock.lock</strong></p>
<h4><span id="wait_for成员函数">wait_for()成员函数</span></h4><p>函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function">cv_status <span class="title">wait_for</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span>, <span class="title">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">wait_for</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock,</span><br><span class="line">               <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span><br><span class="line">               Predicate pred);</span><br></pre></td></tr></table></figure>
<p><code>wait_for</code> 导致当前线程阻塞直至条件变量被<strong>通知</strong>，或<strong>虚假唤醒发生</strong>，或者<strong>超时返回</strong>。</p>
<p>以上两个类型的<strong>wait函数都在会阻塞时，自动释放锁权限，即调用unique_lock的成员函数unlock（），以便其他线程能有机会获得锁</strong>。这就是条件变量只能和 <code>unique_lock</code> 一起使用的原因，否则当前线程一直占有锁，线程被阻塞。</p>
<h4><span id="notify_allnotify_one">notify_all/notify_one</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//若任何线程在 *this 上等待，则解阻塞（唤醒)全部等待线程。</span></span><br></pre></td></tr></table></figure>
<h4><span id="虚假唤醒">虚假唤醒</span></h4><p>在正常情况下，<code>wait</code> 类型函数返回时要不是因为被唤醒，要不是因为超时才返回，但是在实际中发现，因此操作系统的原因，<code>wait</code> 类型在不满足条件时，它也会返回，这就导致了虚假唤醒。因此，我们一般都是使用带有谓词参数的 <code>wait</code> 函数，因为这种<code>(xxx, Predicate pred )</code>类型的函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!(xxx条件) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//虚假唤醒发生，由于while循环，再次检查条件是否满足，</span></span><br><span class="line">    <span class="comment">//否则继续等待，解决虚假唤醒</span></span><br><span class="line">    wait();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="面向对象的三大特性">面向对象的三大特性</span></h3><h4><span id="继承">继承</span></h4><h4><span id="封装">封装</span></h4><h4><span id="多态">多态</span></h4><hr>
<h3><span id="c11新特性">C++11新特性</span></h3><ul>
<li><p><code>nullptr</code> 替代 <code>NULL</code> </p>
</li>
<li><p>引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了<strong>类型推导</strong></p>
</li>
<li><p>基于范围的 <code>for</code> 循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : res)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类和结构体的中初始化列表</strong></p>
</li>
<li><p><strong>Lambda 表达式（匿名函数）</strong></p>
</li>
<li><p><strong>std::forward_list（单向链表）</strong></p>
</li>
<li><p><strong>右值引用和move语义</strong></p>
</li>
<li><p>…</p>
</li>
</ul>
<hr>
<h3><span id="c模板">⭐C++模板</span></h3><ul>
<li>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板<strong>通过具体类型产生不同的函数</strong>；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</li>
<li>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</li>
</ul>
<h4><span id="模板类存放位置h">模板类存放位置(.h)</span></h4><ul>
<li>模板定义很特殊。由<strong>template&lt;…&gt;</strong>处理的任何东西都意味着编译<strong>器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知</strong>。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</li>
<li>在分离式编译的环境下，编译器编译某一个 <code>.cpp</code> 文件时并不知道另一个 <code>.cpp</code> 文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</li>
<li>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</li>
<li>然而当实现该模板的 <code>.cpp</code> 文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的 <code>.obj</code> 中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</li>
</ul>
<h4><span id="模板类是什么时候实例化的">模板类是什么时候实例化的</span></h4><h4><span id="模板代码class声明和定义能够写在不同的文件吗">模板代码class声明和定义能够写在不同的文件吗</span></h4><h4><span id="模板类中能够使用虚函数吗">模板类中能够使用虚函数吗</span></h4><h4><span id="模板函数和模板类的特例化">模板函数和模板类的特例化</span></h4><h5><span id="引入原因"><strong>引入原因</strong></span></h5><p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但<strong>对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</strong></p>
<h5><span id="定义"><strong>定义</strong></span></h5><p>对单一模板提供的一个特殊实例，它将<strong>一个或多个模板参数绑定到特定的类型或值上</strong></p>
<ol>
<li><p><strong>模板函数特例化</strong></p>
<p>必须为原函数模板的每个模板参数都提供实参，且使用关键字 <code>template</code> 后跟一个空尖括号对 <code>&lt;&gt;</code> ，表明<strong>将原模板的所有模板参数提供实参</strong>，举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;v1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特例化的本质是<strong>实例化一个模板</strong>，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用<strong>特例化版本</strong>（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
<p><strong>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</strong></p>
</li>
<li><p><strong>类模板特例化</strong></p>
<p>类模板分为<strong>全特化</strong>和<strong>偏特化</strong>两种特化，全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(T1 i,T2 j):a(i),b(j)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"模板类"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 a;</span><br><span class="line">	T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;int , char&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i, <span class="keyword">char</span> j):a(i),b(j)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"全特化"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;char, T2&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">char</span> i, T2 j):a(i),b(j)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"偏特化"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	T2 b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面三句依次调用类模板、全特化与偏特化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; t1(<span class="number">0.1</span>,<span class="number">0.2</span>);<span class="comment">//类模板</span></span><br><span class="line">Test&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; t2(<span class="number">1</span>,<span class="string">'A'</span>);<span class="comment">//全特化</span></span><br><span class="line">Test&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; t3(<span class="string">'A'</span>,<span class="literal">true</span>);<span class="comment">//偏特化</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h4><span id="类模板和模板类的区别">类模板和模板类的区别？</span></h4><hr>
<h3><span id="c多态">⭐C++多态</span></h3><p><strong>封装，继承，多态是面向对象设计的三个特征</strong>，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。</p>
<h4><span id="多态有哪几种">多态有哪几种？</span></h4><p>多态是面向对象的重要特性之一，它是一种行为的封装，是同一种事物所表现出的多种形态，简单地说是”一个接口多种实现“。多态的实现主要分为<strong>静态多态</strong>和<strong>动态多态</strong>：</p>
<ul>
<li>静态多态主要是<strong>重载</strong>，在编译的时候就已经确定。<ul>
<li><strong>函数重载</strong></li>
<li><strong>运算符重载</strong></li>
<li><strong>模板</strong></li>
</ul>
</li>
<li>动态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。</li>
</ul>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，<strong>在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数</strong>。在子类中重新定义父类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<hr>
<h4><span id="虚函数">虚函数</span></h4><p>在有虚函数的类中，<strong>类的最开始部分是一个虚函数表的指针</strong>，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在 <code>代码段(.text)</code> 中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<p>虚表是一个<strong>指针数组</strong>，其元素是<strong>虚函数的指针</strong>，每个元素对应一个<strong>虚函数的函数指针</strong>。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。虚表内的条目，即<strong>虚函数指针的赋值发生在编译器的编译阶段</strong>，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<p>虚表是<strong>属于类</strong>的，而不是属于某个具体的对象，<strong>一个类只需要一个虚表</strong>即可。<strong>同一个类的所有对象都使用同一个虚表。</strong></p>
<p>⭐<code>Linux</code> 下虚表存储位置在<strong>只读数据段中(rodata)</strong>，<code>windows</code> 是在存储位置应该是<strong>常量区域。</strong> </p>
<p>为了指定对象的虚表，对象内部包含一个<strong>虚表的指针</strong>，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>void** __vfptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.jpg" alt="img"></p>
<ul>
<li>虚函数表是全局共享的元素，即全局仅有一个，<strong>在编译时就构造完成</strong></li>
<li>虚函数表类似一个数组，类对象中存储 <code>vptr</code> 指针，指向每个虚函数，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li>
<li>虚函数表存储虚函数的地址，即<strong>虚函数表的元素是指向类成员函数的指针</strong>，而类中虚函数的个数在编译时期可以确定，即<strong>虚函数表的大小可以确定</strong>，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中。</li>
</ul>
<h5><span id="虚表指针的初始化时间">虚表指针的初始化时间</span></h5><p>由于虚表指针<strong>vptr</strong>跟虚函数密不可分，对于<strong>有虚函数或者继承于拥有虚函数的基类</strong>，对该类进行实例化时，在<strong>构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面</strong>。</p>
<p><strong>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化</strong>。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。</p>
<p>虚函数位于代码段（<code>.text</code> ），也就是C++内存模型中的代码区。</p>
<hr>
<h4><span id="动态绑定">动态绑定</span></h4><p>如果将基类的成员函数声明为 <code>virtual</code> 的，然后用<strong>指向派生类对象的基类指针或者引用</strong>来<strong>调用该成员函数</strong>，那么程序会<strong>在运行时选择该派生类的函数而不是基类的函数</strong>，这种特性成为<strong>运行时绑定</strong>（<strong>动态绑定</strong>、<strong>晚绑定</strong>）。</p>
<p>派生类虚函数要达成运行时动态绑定的效果，必须和基类的函数名、参数列表完全相同，否则仅仅是对基类虚函数的<strong>隐藏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类 <code>A</code> 是基类，类 <code>B</code> 继承类 <code>A</code> ，类 <code>C</code> 又继承类 <code>B</code> 。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> ，其对象模型如下图所示。由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（<code>A vtbl</code>），类B的虚表（<code>B vtbl</code>），类C的虚表（<code>C vtbl</code>）。类 <code>A</code> ，类 <code>B</code> ，类 <code>C</code> 对象都拥有一个虚表指针<code>*__vptr</code>，用来指向自己所属类的虚表。</p>
<p><strong>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</strong>。</p>
<p><strong>生成子类虚表的过程：</strong></p>
<ol>
<li>将父类虚表内容拷贝到子类虚表上。</li>
<li>将子类重写的虚函数覆盖掉表中父类的虚函数。</li>
<li>如果子类有新增加的虚函数,按声明次序加到最后。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.jpg" alt="img"></p>
<p>我们把经过虚表调用虚函数的过程称为<strong>动态绑定</strong>，其表现出来的现象称为<strong>运行时多态</strong>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为<strong>静态绑定</strong>，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p>
<ol>
<li><p>通过<strong>指针或引用</strong>来调用函数</p>
</li>
<li><p>指针<strong>upcast</strong>向上转型（继承类向基类的转换称为 <code>upcast</code> ，也就是用一个基类指针指向派生类对象）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base *base = <span class="keyword">new</span> Derived();<span class="comment">//upcast, cast Derived to Base</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调用的是虚函数</strong></p>
</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<hr>
<h4><span id="虚继承与虚函数">虚继承与虚函数</span></h4><p><a href="https://blog.csdn.net/z769875464/article/details/82119495" target="_blank" rel="noopener">https://blog.csdn.net/z769875464/article/details/82119495</a></p>
<p>分情况讨论：基类中<strong>有/没有虚函数</strong>、继承是<strong>普通继承/虚继承</strong></p>
<h5><span id="虚继承要解决的问题">虚继承要解决的问题</span></h5><p><strong>虚继承</strong>是解决<strong>C++多重继承问题</strong>的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。</p>
<p><strong>vbptr</strong>指的是虚基类表指针（virtual base table pointer），该指针指向了一个<strong>虚基类表</strong>（virtual table），虚表中记录了<strong>虚基类与本类的偏移地址</strong>；通过偏移地址，这样就找到了虚基类成员，而<strong>虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX84lfZ0rGm9ia1ZzvLTT2I1udpL0BDt6F9StbnKg2TJVg0d6LbOoV97nzn2axKhb0sKV4MAKgGP1kg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>每个虚继承的子类都有一个虚基类指针<strong>vbptr</strong>（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）。需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<ol>
<li><p><strong>普通继承</strong>：这时不管子类是否重写了父类虚函数，或者是否含有新的虚函数，子类中都只有一个虚函数指针指向自己的虚函数表（因为没有继承的虚函数指针）。其中子类虚函数表的第一个函数是 <code>B::funA()</code> , 第二个是 <code>B::funB()</code> ；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚继承</strong>：当子类虚继承父类时，<strong>子类一定会生成一个虚基类指针vbptr</strong>。</p>
<ol>
<li>若<strong>父类有虚函数指针</strong>则拷贝。最后，若自己有新的虚函数则会产生一个新的子类的虚函数指针。</li>
<li>若只是<strong>重写了父类的虚函数</strong>，则只会继承父类的虚函数指针而不会产生自己的虚函数指针。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180827214626276?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180827214736229?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
<li><p><strong>普通多继承</strong></p>
<p>在<strong>普通多继承且父类有虚函数</strong>的情况下，<strong>子类只会继承父类的虚函数指针并不会生成新的自己的虚函数指针</strong>。<strong>若自己有新的虚函数，会将新的虚函数地址放置在第一个继承的父类的虚函数指针指向的虚函数表的最后</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sizeof(C)=8</code> ，并且 <code>funC</code> 函数放置在了 <code>funA</code> 函数之后。 </p>
<p><img src="https://img-blog.csdn.net/20180827215540235?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20180827215608475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
<li><p><strong>多重继承+虚继承</strong></p>
<p>父类有虚函数且都为虚继承的情况下，肯定会<strong>产生一个虚基类指针vbptr指向他的虚基类A和B</strong>，然后<strong>分别继承父类的虚函数指针vfptr</strong>，最后<strong>根据自己是否有新的虚函数来决定是否产生新的自己的虚函数指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A, <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>sizeof(c) = 12</strong></p>
<p><img src="https://img-blog.csdn.net/20180827220036482?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A, <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>sizeof(C)=16</strong></p>
<p><img src="https://img-blog.csdn.net/20180827220133990?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
</ol>
<ol start="5">
<li><p><strong>菱形继承</strong></p>
<ol>
<li><p><strong>直接继承和间接继承间都是普通继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funD</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样 <strong>sizeof(D)=16</strong>，原因在于 <code>A</code> 的成员数据 <code>a</code> 拷贝了两份。但是虚函数指针<strong>只是简单继承了 <code>B</code> 和 <code>C</code> 的虚函数指针。</strong></p>
<p><img src="https://img-blog.csdn.net/20180827220613306?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
<li><p><strong>中间父类是虚继承，最后是普通继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funD</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>sizeof(D)=20</strong>。可以看出来这时 <code>B</code> 和 <code>C</code> 都有 <code>3</code> 个指针，分别是自己的<strong>虚基类指针</strong>、<strong>自己的虚函数指针</strong>、<strong>A的虚函数指针</strong>。但是 <code>D</code> 继承时 <code>A</code> 的<strong>虚函数指针只继承一份，其他的全部继承下来</strong>。若 <code>A</code> 中有数据成员的话，<code>D</code> 中也<strong>只会存在一份</strong>，这样就避免了多重继承下的二义性问题。</p>
<p><img src="https://img-blog.csdn.net/20180827220946739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
<li><p><strong>所有情况下都是虚继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funD</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>sizeof(D)=28</strong>。这时因为是虚继承并且 <code>D</code> 中也有自己新的虚函数，所有会多创建一个虚基类指针和一个新的虚函数指针。</p>
<p><img src="https://img-blog.csdn.net/20180827221411477?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o3Njk4NzU0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h5><span id="总结">总结</span></h5><ul>
<li>父类中有虚函数时会产生一个<strong>虚函数指针</strong>(指向父类的虚函数表)<ul>
<li>若子类单继承时会继承父类的这个指针</li>
<li>若子类自己有新的虚函数也会将函数地址<strong>放在此虚函数指针所指虚函数表的最后</strong>。</li>
</ul>
</li>
<li>多继承时子类会同时继承多个虚函数指针，可以寻址多个虚表。这时<strong>子类自己的虚函数会将函数地址放在第一个继承来的虚函数指针指向虚表的最后。</strong></li>
<li>在<strong>虚继承</strong>的情况下，不管是单继承还是多继承，子类都会创建一个<strong>虚基类指针vbptr</strong>，指向一个<strong>虚基类表</strong>。<ul>
<li>此外子类会继承父类的虚函数指针，当子类仅重写父类虚函数的情况下，不会创建新的虚函数指针。</li>
<li>一旦子类有自己的虚函数，则子类会创建一个新的虚函数指针指向一个新的虚函数表，内部保存自己的虚函数的地址。</li>
</ul>
</li>
</ul>
<hr>
<h4><span id="为什么析构函数必须是虚函数">⭐为什么析构函数必须是虚函数？</span></h4><p>将<strong>可能会被继承的父类</strong>的析构函数设置为虚函数，可以保证当我们 <code>new</code> 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p><strong>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是十分必要的。</strong></p>
<p><strong>在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。这样在调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent construct function"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Parent()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent destructor function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son construct function"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Son()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son destructor function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Parent* p = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Son destructor function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br></pre></td></tr></table></figure>
<p>⭐<strong>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</strong></p>
<hr>
<h4><span id="为什么c默认的析构函数不是虚函数">为什么C++默认的析构函数不是虚函数？</span></h4><p>C++默认的析构函数不是虚函数是因为虚函数<strong>需要额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是<strong>只有当需要当作父类时，设置为虚函数。</strong></p>
<hr>
<h4><span id="为什么构造函数不能是虚函数">为什么构造函数不能是虚函数？</span></h4><p>1.<strong>从存储空间角度：</strong> 虚函数对应一个 <code>vtable</code> ，这个 <code>vtable</code> 其实是存储在<strong>对象的内存空间</strong>的。问题出来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到<code>vtable</code> ，所以构造函数不能是虚函数。<br><strong>2，从使用角度：</strong> 构造函数本身就是要<strong>初始化实例</strong>，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。<strong>虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数</strong>。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。<br><strong>3、构造函数不需要是虚函数，也不允许是虚函数：</strong>因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过基类的指针或引用去访问它。<br><strong>4、从实现上看，</strong><code>vtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数。</p>
<hr>
<h4><span id="静态成员及静态成员函数能不能被继承">静态成员及静态成员函数能不能被继承？</span></h4><p>⭐<strong>静态数据成员和静态成员函数可以被继承！</strong>具体如下：</p>
<ol>
<li>父类的 <code>static</code> 变量和函数在派生类中依然可用，但是<strong>受访问性控制</strong>（比如，父类的 <code>private</code> 域中的就不可访问），而且对 <code>static</code> 变量来说，派生类和父类中的 <code>static</code> 变量是<strong>共用空间</strong>的，这点在利用 <code>static</code> 变量进行引用计数的时候要特别注意。</li>
<li><code>static</code> 函数没有“虚函数”一说。因为 <code>static</code> 函数实际上是<strong>加上了访问控制的全局函数</strong>，全局函数哪来的什么虚函数的概念？</li>
<li>派生类的 <code>friend</code> 函数可以访问派生类本身的一切变量，包括从父类继承下来的 <code>protected</code> 域中的变量。但是对父类来说，他并不是 <code>friend</code> 的。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。所以 <code>static</code> 成员的这种应该算是继承。</li>
</ol>
<hr>
<h4><span id="友元可以继承吗">友元可以继承吗？</span></h4><p>⭐<strong>不能！</strong></p>
<p>友元只是能访问<strong>指定类的私有和保护成员的自定义函数</strong>，<strong>不是被指定类的成员</strong>，自然不能继承。 使用友元类时注意：</p>
<ol>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>A</code> 不一定是类 <code>B</code> 的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类 <code>B</code> 是类 <code>A</code> 的友元，类 <code>C</code> 是 <code>B</code> 的友元，类 <code>C</code> 不一定是类 <code>A</code> 的友元，同样要看类中是否有相应的声明。</li>
</ol>
<hr>
<h4><span id="虚函数virtual可以是内联函数inline吗当虚函数表现多态性的时候不能内联">虚函数(virtual)可以是内联函数(inline)吗？(当虚函数表现多态性的时候不能内联)</span></h4><ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是<strong>当虚函数表现多态性的时候不能内联。</strong></li>
<li><strong>内联是在编译器建议编译器内联</strong>，而<strong>虚函数的多态性在运行期</strong>，编译器无法知道运行期调用哪个代码，因此<strong>虚函数表现为多态性时（运行期）不可以内联</strong>。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：<strong>编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生</strong>。(上面第二种情况就是发生了运行期多态，是采用对象的指针或者引用、<code>upcast</code> 调用了对象的函数)</li>
</ul>
<hr>
<h4><span id="多态中构造函数析构函数调用顺序">多态中构造函数/析构函数调用顺序</span></h4><ol>
<li>基类对象首先被创建。</li>
<li>派生类构造函数应通过<strong>成员初始化列表</strong>（<strong>调用顺序和继承顺序相关</strong>）将基类信息传递给基类构造函数 ，可以使用初始化列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。</li>
<li>派生类构造函数<strong>应初始化派生类新增的数据成员</strong>。派生类对象析构时，程序<strong>首先调用派生类析构函数，再调用基类析构函数。</strong></li>
</ol>
<hr>
<h4><span id="类成员函数中重载重写隐藏的区别">类成员函数中重载/重写/隐藏的区别？</span></h4><ul>
<li><strong>函数重载(overload)：重载函数通常用来命名一组 <code>功能相似</code> 的函数</strong><ul>
<li>函数要在 <code>相同的类域</code></li>
<li>函数的 <code>名字要相同</code> </li>
<li>函数的 <code>参数列表或返回值不同</code> </li>
</ul>
</li>
<li><strong>函数重写/覆盖(override)：覆盖是指 <code>派生类函数覆盖基类函数</code> </strong><ul>
<li>函数是要在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>基类函数 <code>必须是虚函数</code></li>
<li>两个函数的 <code>参数相同</code> </li>
</ul>
</li>
<li><strong>函数重定义/隐藏(hide)：指派生类的函数屏蔽了与其同名的基类函数</strong><ul>
<li>两个函数在 <code>不同的类域</code> </li>
<li>两个函数的 <code>名称相同</code> </li>
<li>两个函数的 <code>参数不同</code> </li>
<li><strong>如果派生类函数与基类函数参数相同，但是在基类函数中没有virtual关键字，发生函数隐藏</strong></li>
</ul>
</li>
</ul>
<hr>
<h4><span id="钻石继承问题">钻石继承问题</span></h4><p>为了解决菱形继承带来的问题，C++中引入了<strong>虚基类</strong>，其作用是在<strong>间接继承共同基类时只保留一份基类成员</strong>。虚继承是一种机制，<strong>类通过虚继承指出它希望共享虚基类的状态</strong>。对给定的虚基类，<strong>无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象</strong>。共享基类子对象称为虚基类。虚基类用 <code>virtual</code> 声明继承关系就行了。这样一来，D就只有A的一份拷贝。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():a(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span>  <span class="keyword">public</span> B ,  <span class="keyword">public</span> C &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">	D d;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(d);</span><br><span class="line">	d.a=<span class="number">10</span>;</span><br><span class="line">	d.printA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c的四种构造函数">C++的四种构造函数</span></h3><p>C++中的构造函数可以分为4类：</p>
<ul>
<li><p><strong>默认构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(）；<span class="comment">//没有参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(<span class="keyword">int</span> num，<span class="keyword">int</span> age）；<span class="comment">//有参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复制(拷贝)构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(Student&amp;）；<span class="comment">//形参是本类对象的引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移动构造函数？</strong></p>
<p><a href="https://www.cnblogs.com/qingergege/p/7607089.html" target="_blank" rel="noopener">https://www.cnblogs.com/qingergege/p/7607089.html</a></p>
</li>
<li><p><strong>转移构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(<span class="keyword">int</span> r) ；<span class="comment">//形参时其他类型变量，且只有一个形参</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student() &#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    Student(<span class="keyword">int</span> a, <span class="keyword">int</span> n) : age(a), num(n) &#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student&amp; s)&#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    Student(<span class="keyword">int</span> r)&#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Student()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1 age:%d, num:%d\n"</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s3 age:%d, num:%d\n"</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">//s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">//s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">//s2 age:10, num:1002</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>默认构造函数</strong>和<strong>初始化构造函数</strong>在定义类的对象，完成对象的初始化工作</li>
<li><strong>复制构造函数</strong>用于<strong>复制本类的对象</strong></li>
<li><strong>转换构造函数</strong>用于<strong>将其他类型的变量，隐式转换为本类对象</strong></li>
</ul>
<h4><span id="拷贝构造函数和赋值运算符重载的区别">拷贝构造函数和赋值运算符重载的区别？</span></h4><ul>
<li><p>拷贝构造函数是<strong>函数</strong>，赋值运算符是<strong>运算符重载</strong>。</p>
</li>
<li><p>拷贝构造函数会<strong>生成新的类对象</strong>，赋值运算符不能。</p>
</li>
<li><p>拷贝构造函数是直接构造一个新的类对象，所以在<strong>初始化对象前不需要检查源对象和新建对象是否相同</strong>；赋值运算符需要上述操作并提供两套不同的复制策略，另外<strong>赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉</strong>。</p>
</li>
<li><p><strong>形参传递是调用拷贝构造函数</strong>（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = s;    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    <span class="comment">// 赋值运算符操作</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3><span id="c的四种cast">C++的四种cast</span></h3><h4><span id="static_cast">static_cast</span></h4><p>在C++语言中 <code>static_cast</code> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。例如将整型数据转换为浮点型数据。</p>
<p>主要用法有如下几种：</p>
<ol>
<li><p>用于类层次结构中基类和派生类之间指针或引用的转换。</p>
<p>进行<strong>上行转换</strong>（把派生类的指针或引用转换成基类表示）是<strong>安全</strong>的<br>进行<strong>下行转换</strong>（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，是<strong>不安全</strong>的</p>
</li>
<li><p>用于基本数据类型之间的转换，如把 <code>int</code> 转换成 <code>char</code> 。这种转换的安全也要开发人员来保证。</p>
</li>
<li><p>把空指针转换成目标类型的空指针。</p>
</li>
<li><p>把任何类型的表达式转换为 <code>void</code> 类型。</p>
</li>
</ol>
<ul>
<li>注意：<code>static_cast</code> 不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</li>
<li><code>static_cast</code> : 可以实现C++中内置基本数据类型之间的相互转换。</li>
<li>如果涉及到类的话，<code>static_cast</code> 只能在<strong>有相互联系的类型</strong>中进行相互转换,不一定包含虚函数。</li>
</ul>
<hr>
<h4><span id="const_cast">const_cast</span></h4><p><strong>const_cast&lt;type_id&gt; (expression)</strong></p>
<p><code>const_cast</code> 用于强制去掉 <code>const</code> / <code>volatile</code> 这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是<strong>去除指向常数对象的指针或引用的常量性</strong>，其去除常量性的对象必须为指针或引用。用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li>
<li>常量对象被转换成非常量对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> *q =<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    *q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="string">" "</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=10 *p=20 *q=20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，原来的 <code>a</code> 的常量性并没有被去除，而指向常量的指针 <code>p</code> 被转化成非常量指针，并且仍然指向原来的对象，并且指向的值被 <code>q</code> 改变成 <code>20</code> 。</p>
<hr>
<h4><span id="reinterpret_cast">reinterpret_cast</span></h4><p><strong>reinterpret_cast&lt;type_id&gt; (expression) </strong>主要有三种强制转换用途：</p>
<ol>
<li>改变指针或引用的类型。</li>
<li>将指针或引用转换为一个足够长度的整形。</li>
<li>将整型转换为指针或引用类型。</li>
</ol>
<p>其中， <code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。<code>reinterpret_cast</code> 可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。整型指针通过 <code>reinterpret_cast</code> 强制转换成了双精度浮点型指针如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code> 可以将指针或引用转换为一个足够长度的整形，此中的足够长度具体长度需要多少则取决于操作系统，如果是32位的操作系统，就需要4个字节及以上的整型，如果是64位的操作系统则需要8个字节及以上的整型。</p>
<hr>
<h4><span id="dynamic_cast">⭐dynamic_cast</span></h4><p><strong>用法：dynamic_cast&lt;type_id&gt; (expression)</strong></p>
<ol>
<li><p>其他三种都是<strong>编译时完成</strong>的，<code>dynamic_cast</code> 是<strong>程序运行</strong>时处理的，运行时要进行<strong>类型检查</strong>。</p>
</li>
<li><p>不能用于内置的基本数据类型的强制转换。</p>
</li>
<li><p><code>dynamic_cast</code> 转换如果成功的话返回的是<strong>指向类的指针或引用</strong>，转换失败的话则会返回 <code>NULL</code> 。</p>
</li>
<li><p><code>dynamic_cast</code>涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换</p>
</li>
<li><p>使用 <code>dynamic_cast</code> 进行转换的，<strong>基类中一定要有虚函数，否则编译不通过</strong>。<br>基类中需要检测有虚函数的原因：</p>
<ul>
<li>类中存在虚函数，就说明它有想<strong>要让基类指针或引用指向派生类对象</strong>的情况，此时转换才有意义。<br>这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。</li>
</ul>
</li>
<li><p>在类的转换时，在类层次间进行<strong>上行转换</strong> (子类指针转为父类指针) 时，<code>dynamic_cast</code> 和 <code>static_cast</code> 的效果是一样的。在进行<strong>下行转换</strong> (父类指针转为子类指针) 时，<code>dynamic_cast</code> 具有类型检查的功能，比 <code>static_cast</code> 更安全。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base* pB = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">if</span>(Derived* pD = <span class="keyword">static_cast</span>&lt;Derived*&gt;(pB))&#123;&#125;</span><br><span class="line"><span class="comment">//下行转换是不安全的(坚决抵制这种方法)</span></span><br><span class="line"></span><br><span class="line">Derived* pD = <span class="keyword">new</span> Derived();</span><br><span class="line"><span class="keyword">if</span>(Base* pB = <span class="keyword">static_cast</span>&lt;Base*&gt;(pD))&#123;&#125;</span><br><span class="line"><span class="comment">//上行转换是安全的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。<code>dynamic_cast</code> 操作符则<strong>可以在运行期对可能产生问题的类型转换进行检查。这个检查主要来自<em>虚函数(virtual function)</em></strong> 。在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名(function siguature)的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。</p>
</li>
</ol>
<hr>
<h4><span id="哪种cast更加接近c的强制类型转换">哪种cast更加接近C的强制类型转换？</span></h4><p>C风格的强制转换(Type Cast)容易理解,不管什么类型的转换都可以使用使用下面的方式.：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeName b = (TypeName)a;</span><br></pre></td></tr></table></figure>
<p><strong>static_cast</strong> 作用和C语言风格强制转换的效果基本一样，都没有运行时的类型检查来保证转换的安全性。</p>
<hr>
<h3><span id="c智能指针">C++智能指针</span></h3><p><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a></p>
<p>C++提出了智能指针，有以下四种<code>auto_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>, <code>unique_ptr</code>。其中后三个是 <code>C++11</code> 支持的，第一个已经被 <code>C++11</code> 弃用。</p>
<p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是<strong>栈上</strong>的对象，所以当函数（或程序）结束时<strong>会自动被释放通过智能指针管理分配的内存单元</strong>。</p>
<h4><span id="auto_ptr弃用">auto_ptr(弃用)</span></h4><p><code>auto_ptr</code> 采用<strong>所有权模式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，相当于 <code>p2</code> 剥夺了 <code>p1</code> 的所有权，但是当程序运行时访问 <code>p1</code> 将会报错。所以 <code>auto_ptr</code> 的缺点是：存在潜在的内存崩溃问题。</p>
<hr>
<h4><span id="unique_ptr替换auto_ptr">unique_ptr(替换auto_ptr)</span></h4><p><code>unique_ptr</code> 实现<strong>独占式拥有或严格拥有</strong>概念，保证<strong>同一时间内只有一个智能指针</strong>可以指向该对象，所以 <code>unique_ptr</code> <strong>不支持普通的拷贝和赋值</strong>操作，不能用在 <code>STL</code> 标准容器中。它对于避免资源泄露 (例如“以new创建对象后因为发生异常而忘记调用delete”) 特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;</span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>同时，当程序试图将一个 <code>unique_ptr</code> 赋值给另一个时，如果源 <code>unique_ptr</code> 是个临时右值，编译器允许这么做；如果源 <code>unique_ptr</code> 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                          <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));       <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>#1</code> 留下悬挂的 <code>unique_ptr(pu1)</code> ，这可能导致危害。而 <code>#2</code> 不会留下悬挂的 <code>unique_ptr</code> ，因为它调用 <code>unique_ptr</code> 的构造函数，该构造函数创建的临时对象在其所有权让给 <code>pu3</code> 后就会被销毁</p>
<p>如果想要完成上面 <code>#1</code> 的操作，需要将一个 <code>unique_ptr</code> 赋给另一个，可以使用 <code>std::move()</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">std</span>::move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="shared_ptr">shared_ptr</span></h4><p><code>shared_ptr</code> 实现共享式拥有概念：多个智能指针可以指向相同对象，该对象和其相关资源会在<strong>最后一个引用被销毁</strong>时候释放。</p>
<p><code>shared_ptr</code> 使用计数机制来表明资源被几个指针共享。可以通过成员函数 <code>use_count()</code> 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 <code>auto_ptr</code> , <code>unique_ptr</code> , <code>weak_ptr</code> 来构造。当我们调用 <code>release()</code> 时，当前指针会释放资源所有权，计数减一。当计数等于 <code>0</code> 时，资源会被释放。</p>
<p>智能指针是个<strong>模板类</strong>，可以指定类型，<strong>传入指针通过构造函数初始化</strong>。也可以使用<strong>make_shared</strong>函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如 <code>std::shared_ptr p4 = new int(1);</code> 的写法是错误的</p>
<ul>
<li>智能指针<strong>将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</strong></li>
<li>每次创建类的新对象时，<strong>初始化指针并将引用计数置为1</strong></li>
<li>当对象作为另一对象的副本而创建时，<strong>拷贝构造函数拷贝指针并增加与之相应的引用计数</strong></li>
<li>对一个对象进行赋值时，<strong>赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</strong></li>
<li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li>
</ul>
<p>成员函数：</p>
<ul>
<li><p><code>use_count()</code> 返回引用计数的个数</p>
</li>
<li><p><code>unique()</code> 返回是否是独占所有权(use_count为 1 )</p>
</li>
<li><p><code>swap</code> 交换两个 <code>shared_ptr</code> 对象(即交换所拥有的对象)</p>
</li>
<li><p><code>reset</code> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li><p><code>get</code> 返回内部对象(指针), 由于已经重载了 <code>()</code> 方法, 因此和直接使用对象是一样的。</p>
<p>如 <code>shared_ptr&lt;int&gt; sp(new int(1));</code>  sp 与 sp.get() 是等价的。</p>
</li>
</ul>
<p><strong>引用计数带来的副作用</strong> <code>循环引用问题</code><br>A对象的指针指向B对象，B对象的指针指向了A对象。两个指针相互指向。<code>造成堆里的内存无法正常回收，造成内存泄漏。</code> 这个时候就需要 <code>weak_ptr</code> 了。</p>
<hr>
<h4><span id="weak_ptr">weak_ptr</span></h4><p><code>weak_ptr</code> 是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象，进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code> 。它指向一个由 <code>shared_ptr</code> 管理的对象而不影响所指对象的生命周期，也就是说，<strong>它只引用，不计数</strong>。</p>
<p><code>weak_ptr</code> 只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 工作, <strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>, 它的构造和析构不会引起引用记数的增加或减少。</p>
<h5><span id="weak_ptr是用来解决shared_ptr相互引用时的死锁问题"><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题：</strong></span></h5><p>如果两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。<code>weak_ptr</code> 是对对象的一种弱引用，不会增加对象的引用计数。</p>
<p><code>weak_ptr</code> 和 <code>shared_ptr</code> 之间可以相互转化，<code>shared_ptr</code> 可以直接赋值给<code>weak_ptr</code> ，<code>weak_ptr</code> 也可以通过调用 <code>lock</code> 函数来获得 <code>shared_ptr</code> 。</p>
<h5><span id="weak_ptr是不保证内存有效的">weak_ptr是不保证内存有效的</span></h5><p>如果一块内存被 <code>shared_ptr</code> 和 <code>weak_ptr</code> 同时引用，当所有 <code>shared_ptr</code> 析构了之后，不管还有没有 <code>weak_ptr</code> 引用该内存，内存也会被释放。<strong>所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</strong></p>
<h5><span id="如何判断weak_ptr的对象是否失效">如何判断weak_ptr的对象是否失效？</span></h5><ol>
<li><code>expired()</code> ：检查被引用的对象是否已删除。</li>
<li><code>lock()</code> 会返回 <code>shared_ptr</code> 指针，判断该指针是否为空。</li>
<li><code>use_count()</code> 也可以得到 <code>shared_ptr</code> 引用的个数，但速度较慢。</li>
</ol>
<p>具体栗子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会只输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>出现了循环引用，当要跳出函数时，智能指针 <code>pa</code> ，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code> ，导致跳出函数时资源没有被释放(A\B的析构函数没有被调用)，如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 <code>A</code> 里面的 <code>shared_ptr pb_;</code> 改为 <code>weak_ptr pb_;</code> 运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">B delete</span><br><span class="line">A delete</span><br></pre></td></tr></table></figure>
<p>资源 <code>B</code> 的引用开始就只有 <code>1</code> ，当 <code>pb</code> 析构时，<code>B</code> 的计数变为 ​<code>0</code> ，<code>B</code> 得到释放，<code>B</code> 释放的同时也会使 <code>A</code> 的计数减一，同时 <code>pa</code> 析构时使 <code>A</code> 的计数减一，那么 <code>A</code> 的计数为 <code>0</code> ， <code>A</code> 得到释放。</p>
<p>注意的是我们不能通过 <code>weak_ptr</code> 直接访问对象的方法，比如 <code>B</code> 对象中有一个方法 <code>print()</code> ,我们不能这样访问，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;pb_-&gt;print()</span><br></pre></td></tr></table></figure>
<p><code>pb_</code> 是一个 <code>weak_ptr</code> ，应该先调用 <code>lock()</code> 函数把它转化为 <code>shared_ptr</code> ，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> p = pa-&gt;pb_.lock();</span><br><span class="line">p-&gt;print();</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>shared_ptr 和 unique_ptr 区别</strong></p>
<p><code>unique_ptr</code> 具有唯一性，对指向的对象值存在唯一的 <code>unique_ptr</code> 。<code>unique_ptr</code> 不可复制，赋值，但是<code>std::move()</code> 可以转换对象的所有权，局部变量的返回值除外。与 <code>shared_ptr</code> 相比，若自定义删除器，<code>unique_ptr</code>需要在声明处指定删除器类型，而 <code>shared_ptr</code> 不需要，<code>shared_ptr</code> 自定义删除器只需要指定删除器对象即可；在赋值时，<code>shared_ptr</code> 可以随意赋值，删除器对象也会被赋值给新的对象。因为在 <code>unique_ptr</code> 的实现中，删除器对象是作为 <code>unique_ptr</code> 的一部分，而 <code>shared_ptr</code> 的删除器对象保存在<code>control_block</code> 中。</p>
<hr>
<h4><span id="智能指针原理">智能指针原理</span></h4><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p>
<hr>
<h4><span id="智能指针是线程安全的吗">智能指针是线程安全的吗？</span></h4><p><code>shared_ptr</code> 本身不是 <code>100%</code> 线程安全的。</p>
<p>它的引用计数本身是安全且无锁的，智能指针的引用计数在手段上使用了<strong>atomic原子操作</strong>，只要 <code>shared_ptr</code> 在拷贝或赋值时增加引用，析构时减少引用就可以了。首先原子是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的。</p>
<p>但对象的读写则不是，因为<code>shared_ptr</code> 有<strong>两个数据成员</strong>，读写操作不能原子化：一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象，当智能指针发生拷贝的时候，标准库的实现是<strong>先拷贝智能指针</strong>，<strong>再拷贝引用计数对象</strong>（拷贝引用计数对象的时候，会使 <code>use_count++</code>），这两个操作并不是原子操作，隐患就出现在这里。<strong>两个线程中智能指针的引用计数同时++或–，这个操作不是原子的，假设引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了，违背了原子性。</strong></p>
<p>根据 <code>boost</code> 文档，<code>shared_ptr</code> 的线程安全级别和内建类型、标准库容器、<code>std::string</code> 一样，即：</p>
<ul>
<li>一个 <code>shared_ptr</code> 对象实体可被多个线程同时读取；</li>
<li>两个 <code>shared_ptr</code> 对象实体可以被两个线程同时写入，<code>析构</code> 算写操作；</li>
<li>如果要从多个线程读写同一个 <code>shared_ptr</code> 对象，那么需要加锁。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>读</code> 是安全的。</li>
<li>同一个 <code>shared_ptr</code> 被多个线程 <code>写</code> 是不安全的。</li>
<li>同一个 <code>shared_ptr</code> 对象不能被多线程直接修改，但可以通过原子函数完成。</li>
<li>共享引用计数的不同的 <code>shared_ptr</code> 被多个线程 <code>写</code>  是安全的。</li>
</ul>
<hr>
<h3><span id="cthis指针">C++this指针</span></h3><ul>
<li><code>this</code> 指针是<strong>类的指针</strong>，<strong>指向对象的首地址</strong>。</li>
<li><code>this</code> 指针形如 <strong>A * const this</strong>，其中 <code>A</code> 是类</li>
<li><code>this</code> 指针<strong>只能在成员函数中使用，在全局函数、静态成员函数中都不能用this</strong>。</li>
<li><code>this</code> 指针<strong>只有在成员函数中才有定义</strong>，且存储位置会因编译器不同有不同存储位置。</li>
<li>大多数编译器通过<strong>ecx（寄数寄存器）</strong>传递 <code>this</code> 指针，传递效率比较高。</li>
<li>在获得一个对象后，我们不能通过对象使用 <code>this</code> 指针。只有在成员函数里才有 <code>this</code> 指针的位置。</li>
</ul>
<p>一个对象的 <code>this</code> 指针并不是对象本身的一部分，不会影响 <code>sizeof(对象)</code> 的结果。<code>this</code> 作用域是在类内部，当在类的<strong>非静态成员函数</strong>中访问类的<strong>非静态成员</strong>的时候（全局函数，静态函数中不能使用 <code>this</code> 指针），编译器会自动将<strong>对象本身的地址作为一个隐含参数传递给函数</strong>。也就是说，即使你没有写上 <code>this</code> 指针，编译器在编译的时候也是加上 <code>this</code> 的，它作为非静态成员函数的隐含形参，对各成员的访问均通过 <code>this</code> 进行。</p>
<p><strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的 <code>this</code> 参数传递进去。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.func(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//此处，编译器将会编译成：</span></span><br><span class="line">A::func(&amp;a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c对象的内存模型">C++对象的内存模型</span></h3><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613564872855.png" alt="1613564872855"></p>
<h4><span id="普通对象模型">普通对象模型</span></h4><p>对象是如何在内存中布局的？</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>存放位置</th>
<th>访问范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>非静态数据成员</td>
<td>每一个对象体内</td>
<td>为该对象专有</td>
</tr>
<tr>
<td>静态数据成员</td>
<td>程序的静态存储区内，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>成员函数（静态/非静态）</td>
<td>程序的代码段中，只有一份实体</td>
<td>为该类所有对象共享</td>
</tr>
<tr>
<td>类内嵌套的各种类型（typedef、class、struct、enum等）</td>
<td>与放在类外面定义的类型除了定义域之外没有本质区别</td>
<td>遵循类内部的访问规则</td>
</tr>
</tbody>
</table>
<p>因此，构成对象本身的<strong>只有数据</strong>，类的成员函数不属于任何一个对象。<strong>非静态成员函数与对象之间的关系是通过this指针绑定的</strong>。</p>
<h5><span id="类的对象存储空间大小">类的对象存储空间大小</span></h5><ul>
<li>非静态成员的数据类型大小之和。    </li>
<li>编译器加入的额外成员变量（<strong>如指向虚函数表的指针</strong>）。</li>
<li>为了边缘对齐优化加入的<strong>padding</strong>。</li>
</ul>
<h4><span id="派生类的对象模型">派生类的对象模型</span></h4><p>派生类的对象是如何在内存中布局的？</p>
<h5><span id="派生类构造函数执行顺序">派生类构造函数执行顺序</span></h5><ol>
<li><p>虚基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</p>
</li>
<li><p>基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</p>
</li>
<li><p>类类型的成员对象的构造函数（按照初始化顺序）</p>
</li>
<li><p>派生类自己的构造函数。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>成员</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承自基类的非静态数据成员</td>
<td>作为对象自己专用的数据</td>
</tr>
<tr>
<td>继承自基类的非静态成员函数</td>
<td>作为类的成员函数一样访问</td>
</tr>
<tr>
<td>虚函数（继承的或者新增的）</td>
<td>所有虚函数的地址都存放在vtable里</td>
</tr>
<tr>
<td>多态类每一个对象中的vptr</td>
<td>函数指针的指针，指向所属类的vtable</td>
</tr>
<tr>
<td>继承自基类的vptr</td>
<td>继承和重用该vptr</td>
</tr>
<tr>
<td>多重继承的多个分支</td>
<td>每个分支都继承一个vptr并生成一个对应的vtable</td>
</tr>
</tbody>
</table>
<p><code>vptr</code> 在派生类对象中的相对位置不会随着继承的层次改变而改变，一般编译器会将 <code>vptr</code> 放在所有数据成员的最前面。为了支持 <code>RTTI</code> ，编译器会为每一个多态类创建一个 <code>type_info</code> 对象，并把其地址保存在该类 <code>vtable</code> 中的第一个位置。</p>
<h4><span id="vtable中虚函数指针的排列顺序">vtable中虚函数指针的排列顺序</span></h4><ol>
<li>如果虚函数是第一次出现，则把它的函数地址指针依次插入到 <code>vtable</code> 的尾部。</li>
<li>如果派生类改写了基类的虚函数，则这个函数的地址在派生类 <code>vtable</code> 中的位置与其在基类 <code>vtable</code> 中的位置一致，而与其在派生类中的声明位置无关。也就是说<strong>一旦虚函数指针在 <code>vtable</code> 的位置确定，则它的位置就不会因为继承层次的改变而改变。</strong></li>
<li>派生类没有改写的基类虚函数被继承，位置与原先在 <code>vtable</code> 中的位置相同。</li>
</ol>
<h4><span id="空类含有虚函数的类的大小">空类/含有虚函数的类的大小</span></h4><h5><span id="为何空类的大小不是0呢">为何空类的大小不是0呢？</span></h5><p>为了确保两个不同对象的地址不同，必须如此。</p>
<p>类的实例化是在内存中分配一块地址，每个实例都有独一无二的内存地址。空类也会实例化，为保证空类实例化后的独一无二性，编译器会给空类隐含的添加一个字节。所以，空类的 <code>sizeof</code> 为 <code>1</code> ，而不是 <code>0</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;&#125;</span><br><span class="line">    ~B() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>class B</code> 在 <code>class A</code> 的基础上添加了构造函数和析构函数。由于构造函数和析构函数的调用与类型的实例无关（调用它们只需要知道函数地址即可），在它的实例中不需要增加任何信息。所以 <code>sizeof(B)</code> 和 <code>sizeof(A)</code> 一样，都是1。</p>
<h5><span id="继承关系中的类大小">继承关系中的类大小</span></h5><ol>
<li><p>父类有虚函数，子类继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此时，类 <code>A</code> 和类 <code>B</code> 都不是空类，其 <code>sizeof</code> 都是 <code>4</code> ，因为它们都具有<strong>虚函数表的地址</strong>。</p>
</li>
<li><p>父类是空类，子类以<strong>虚基类方式</strong>继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，<code>A</code> 是空类，其大小为 <code>1</code> ；<code>B</code> 不是空类，其大小为 <code>4</code> ，因为含有指向虚基类的指针。</p>
</li>
<li><p>多重空类继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father1</span>&#123;</span>&#125;; <span class="class"><span class="keyword">class</span> <span class="title">Father2</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span>Father1, Father2&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>它们的 <code>sizeof</code> 都是 <code>1</code> 。</p>
</li>
</ol>
<hr>
<h3><span id="c内存分区">C++内存分区</span></h3><p><code>C/C++</code> 中内存分5大区：<strong>栈，堆，全局/静态存储区(static)，常量存储区(const)，代码区</strong></p>
<ul>
<li><strong>栈(stack)</strong>：指那些由编译器在需要的时候分配，不需要时⾃动清除的变量所在的存储区，效率高，分配的内存空间有限，形参和局部变量分配在栈区，栈是向地地址生长的数据结构，是一块连续的内存</li>
<li><strong>堆(heap)</strong>：由程序员控制内存的分配和释放的存储区，是向高地址生长的数据结构，是不连续的存储空间，堆的分配(malloc)和释放(free)有程序员控制，容易造成二次删除和内存泄漏</li>
<li><strong>静态存储区(static)/全局区/data区+bss区</strong>：存放全局变量和静态变量的存储区，初始化的变量放在<strong>初始化区</strong>，未初始化的变量放在<strong>未初始化区</strong>。在程序结束后释放这块空间。<ul>
<li><code>data</code> 区里主要存放的是已经初始化的全局变量、静态变量和常量。</li>
<li><code>bss</code> 区主要存放的是未初始化的全局变量、静态变量，这些未初始化的数据在程序执行前会自动被系统初始化为 <code>0</code> 或者 <code>NULL</code> </li>
</ul>
</li>
<li><strong>常量存储区(const)</strong>：存放<strong>常量字符串</strong>的存储区，只能读不能写，<code>const</code> 修饰的全局变量<strong>存储在常量区</strong>（取决于编译器），<code>const</code> 修饰的局部变量在<strong>栈区</strong></li>
<li><strong>程序代码区(text)</strong>：存放源程序二进制代码</li>
</ul>
<hr>
<hr>
<h3><span id="c中指针和引用的区别">C++中指针和引用的区别</span></h3><ol>
<li>指针是一个变量，存储的是一个地址，有自己的一块空间，而引用只是一个别名；</li>
<li>使用 <code>sizeof</code> 看一个指针的大小是 <code>4</code> ，而引用则是被引用对象的大小；</li>
<li>指针可以被初始化为 <code>NULL</code> ，而引用必须被初始化且必须是一个已有对象的引用；</li>
<li>作为参数传递时，是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而直接对引用的修改都会改变引用所指向的对象；</li>
<li>可以有 <code>const</code> 指针，但是没有 <code>const</code> 引用；<ul>
<li><strong>指针常量</strong> <code>int *const P1</code>：指针常量约束的是该指针所指的地址，即指针变量本身，而并不是对象本身，地址不能够改变，但是对象值可以改变。<code>const</code> 在 <code>*</code> 后，表示约束的量是指针的地址。</li>
<li><strong>指向常量的指针</strong> <code>const int *P1</code> ：用 <code>const</code> 约束指针对所指对象进行访问时，这个指针称为指向常量的指针。<code>const</code> 在 <code>*</code> 前，表示约束的是指针量本身。<strong>指向常量的指针可以获取变量的地址，但限制用指针间址访问对象方式为“只读</strong>。</li>
</ul>
</li>
<li>指针在初始化后可以改变指向，但是引用只能是一个对象的引用，不能被改变；</li>
<li>指针可以有多级指针（<code>**p</code>），而引用只有一级；</li>
<li>指针和引用使用 <code>++</code> 运算符的意义不一样：引用自增被引用对象的值，指针自增内存地址</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起<strong>内存泄露</strong>。</li>
</ol>
<hr>
<h3><span id="c中new与malloc的区别">C++中new与malloc的区别</span></h3><p><code>new</code> 和 <code>malloc</code> 的内存是分配在堆上的。也有说 <code>new</code> 是分配在自由存储区而 <code>malloc</code> 分配在堆上，自由存储区可以是堆也可以不是，具体要看 <code>new</code> 内部的实现。操作系统在堆上维护一个空闲内存链表，当需要分配内存的时候，就查找这个表，找到一块内存大于所需内存的区域，分配内存并将剩余的内存空间返还到空闲链表上(如果有剩余的话)。</p>
<ol>
<li><p><strong>属性</strong>：<code>malloc</code> 和 <code>free</code> 是<strong>库函数</strong>，而 <code>new</code> 和 <code>delete</code> 是 <code>C++</code> <strong>操作符</strong>；</p>
</li>
<li><p><strong>分配大小参数</strong>：<code>new</code> 自己计算需要的空间大小，比如 <code>int * a = new</code> ，<code>malloc</code> 需要指定大小，例如 <code>int * a = malloc(sizeof(int));</code> </p>
</li>
<li><p><strong>返回类型</strong>：<code>new</code> 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 <code>new</code> 是<strong>符合类型安全性的操作符</strong>。而 <code>malloc</code> 内存分配成功则是返回 <code>void *</code> ，需要通过<strong>强制类型转换</strong>将 <code>void*</code> 指针转换成我们需要的类型。</p>
<p><code>new</code> 是类型安全的，<code>malloc</code> 不是。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));<span class="comment">//编译无错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分配失败</strong>：<code>new</code> 内存分配失败时，会抛出 <code>bac_alloc</code> 异常。<code>malloc</code> 分配内存失败时返回 <code>NULL</code> 。</p>
</li>
<li><p><strong><code>new</code> 在动态分配内存的时候可以初始化对象，调用其构造函数</strong>，<code>delete</code> 在释放内存时调用对象的析构函数。而 <code>malloc</code> 只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回 <code>NULL</code> 。而 <code>malloc</code> 仅仅分配内存空间，<code>free</code> 仅仅回收空间，不具备调用构造函数和析构函数功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo* foo = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Foo));<span class="comment">//Foo是一个类</span></span><br><span class="line">Foo* foo = <span class="keyword">new</span> Foo()；</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义类型</strong>：<code>new</code> 是 <code>C++</code> 操作符，是关键字，而 <code>operator new</code> 是 <code>C++</code> 库函数。 <code>new</code> 会先调用 <code>operator new</code> 函数，申请足够的内存（通常底层使用 <code>malloc</code> 实现）。然后<strong>调用类型的构造函数，初始化成员变量</strong>，最后返回自定义类型指针。<code>delete</code> 先调用析构函数，然后调用 <code>operator delete</code> 函数释放内存（通常底层使用 <code>free</code> 实现）。</p>
</li>
<li><p><code>opeartor new</code> / <code>operator delete</code> 可以重载，而 <code>malloc</code> 不行</p>
</li>
<li><p><code>new</code> 可以调用 <code>malloc</code> 来实现，但是 <code>malloc</code> 不能调用 <code>new</code> 来实现</p>
</li>
<li><p><strong>处理数组</strong>：对于数组，C++定义 <code>new[]</code> 专门进行动态数组分配，用 <code>delete[]</code> 进行销毁。<code>new[]</code> 会一次分配内存，然后多次调用构造函数；<code>delete[]</code> 会先多次调用析构函数，然后一次性释放。</p>
</li>
<li><p><strong>malloc能够直观地重新分配内存</strong>：使用 <code>malloc</code> 分配的内存后，如果在使用过程中发现内存不足，可以使用<code>realloc</code> 函数进行内存重新分配实现内存的扩充。<code>realloc</code> 先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域；<code>new</code> 没有这样直观的配套设施来扩充内存。</p>
</li>
</ol>
<h4><span id="newdelete是如何实现的">new/delete是如何实现的？</span></h4><ul>
<li><code>new</code> 的实现过程是：首先调用名为<strong>operator new</strong>的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来<strong>运行该类型的一个构造函数</strong>，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针</li>
<li><code>delete</code> 的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li>
</ul>
<h4><span id="mallocfree是如何实现的">malloc/free是如何实现的？</span></h4><p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由<strong>brk</strong>、<strong>mmap</strong>、<strong>munmap</strong>这些系统调用实现的;</p>
<h4><span id="delete和delete区别">delete和delete[]区别</span></h4><ul>
<li><strong>delete</strong>只会调用一次析构函数。</li>
<li><strong>delete[]</strong>会调用数组中每个元素的析构函数，<strong>数组中的元素按逆序的顺序进行销毁</strong>；</li>
</ul>
<h4><span id="malloccallocrealloc函数">malloc/calloc/realloc函数</span></h4><h5><span id="malloc函数">malloc函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num_size)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//申请20个int类型的空间；</span></span><br></pre></td></tr></table></figure>
<h5><span id="calloc函数">calloc函数</span></h5><ul>
<li><p>省去了人为空间计算的过程</p>
</li>
<li><p>同时<strong>malloc</strong>申请的空间的值是随机初始化的，<strong>calloc</strong>申请的空间的值是<strong>初始化为0的</strong>；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> n,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<h5><span id="realloc函数">realloc函数</span></h5><p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c-内存对齐">C++ 内存对齐</span></h3><p>现代计算机中内存空间都是按照 <code>byte</code> 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的<strong>首地址的值</strong>是某个数 <code>k</code> （通常它为4或8）的倍数，这就是所谓的内存对齐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，32位系统下，<code>int</code> 占 <code>4 byte</code> ，<code>char</code> 占一个 <code>byte</code> ，那么将它们放到一个结构体中应该占 <code>4 + 1 = 5 byte</code>；但是实际上，<code>sizeof(s)</code> 得到的结果是 <code>8 byte</code> ，这就是内存对齐所导致的。</p>
<p><strong>为什么要内存对齐？</strong></p>
<p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，四字节，<code>8</code> 字节，<code>16</code> 字节甚至 <code>32</code> 字节为单位来存取内存，我们将上述这些存取单位称为<strong>内存存取粒度</strong>。</p>
<p>现在考虑 <code>4</code> 字节存取粒度的处理器取 <code>int</code> 类型变量（<code>32</code> 位系统），该处理器只能从地址为 <code>4</code> 的倍数的内存开始读取数据。这样处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p>
<p>每个特定平台上的编译器都有自己的默认<strong>对齐系数</strong>（也叫对齐模数）。<code>gcc</code> 中默认 <code>#pragma pack(4)</code> ，可以通过预编译命令 <code>#pragma pack(n)</code> ，<code>n = 1,2,4,8,16</code> 来改变这一系数。</p>
<p>有效对其值：是给定值 <code>#pragma pack(n)</code> 和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p><strong>内存对齐规则：</strong></p>
<ul>
<li>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 <code>offset</code> 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</li>
<li><strong>结构体的总大小</strong>为有效对齐值的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">&#125;x3;</span><br></pre></td></tr></table></figure>
<p><code>x1</code> , <code>x2</code> , <code>x3</code> 的 <code>sizeof</code> 结果分别是 <code>8</code> ,  <code>12</code> , <code>8</code> 。</p>
<p>内存结构分别如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg" alt="img"></p>
<hr>
<h3><span id="c存储类型">C++存储类型</span></h3><p>C++中<strong>存储类型的说明符</strong>有四个：<strong>auto</strong>, <strong>register</strong>, <strong>static</strong>和<strong>extern</strong>。前两者称为<code>自动</code>类型，后两者分别为<code>静态</code>和<code>外部</code>类型。此外还有 <code>mutable存储类</code> 和 <code>thread_local 存储类</code> 。</p>
<hr>
<h4><span id="auto-自动变量">auto 自动变量</span></h4><p>用 <code>auto</code> 说明的变量，通常 <code>auto</code> 省略。局部变量都是自动类型。其生命期开始于块的执行，结束于块的结束。</p>
<p>自动变量的空间分配在<strong>栈</strong>中，在程序运行过程中，块开始执行时系统<strong>自动</strong>分配空间（未初始化时值为随机数），块执行结束时系统<strong>自动</strong>释放空间。因此，自动变量的<strong>生命期和作用域是一致的</strong>。</p>
<hr>
<h4><span id="register-寄存器变量">register 寄存器变量</span></h4><p>用 <code>register</code> 说明的变量，如 <code>register int i</code> ; 系统将这样说明的变量尽可能保存在寄存器中，以提高程序运行速度。但不同的编译器对哪些变量可以说明为寄存器变量有不同的规定，而且一般的编译器都会对寄存器的使用进行优化，所以不提倡使用寄存器变量。</p>
<hr>
<h4><span id="extern关键字">extern关键字</span></h4><p><code>extern</code> 是一种<strong>外部声明</strong>的关键字，字面意思就是<strong>在此处声明</strong>某种变量或函数，<strong>在外部定义</strong>。</p>
<p><code>extern</code> 关键字的主要作用是<strong>扩大变量/函数的作用域</strong>，使得其它源文件和头文件可以复用同样的变量/函数，也起到类似“分块储存”的作用，划分代码。如图所示，在一个头文件里做了外部声明，就能把变量的定义部分和函数体的实现部分转移到其它地方了。</p>
<p><img src="https://img2018.cnblogs.com/blog/1751504/201908/1751504-20190812103953084-1639356587.png" alt="img"></p>
<p>此外 <code>extern</code> 也可用来进行<strong>链接指定</strong>：当它与 <code>C</code> 一起连用时，如: <code>extern &quot;C&quot; void fun(int a, int b);</code> 则告诉<strong>编译器在编译 <code>fun</code> 这个函数名时按着 <code>C</code> 的规则去翻译相应的函数名而不是 <code>C++</code> 的</strong>，<code>C++</code> 的规则在翻译这个函数名时会把 <code>fun</code> 这个名字变得面目全非，可能是 <code>fun@aBc_int_int#%$</code> 也可能是别的，因为 <code>C++</code> 支持函数的重载。</p>
<p><strong>对于extern关键字：只在头文件中做声明，真理总是这么简单</strong>。</p>
<hr>
<h4><span id="thread_local-存储类">thread_local 存储类</span></h4><p><code>thread_local</code> 变量是 <code>C++11</code> 新引入的一种存储类型。它会影响变量的存储周期( <code>Storage duration</code> )。只有<code>thread_local</code> 关键字修饰的变量具有线程周期( <code>thread duration</code> )，这些变量(或者说对象）在线程开始的时候被生成( <code>allocated</code> )，在线程结束的时候被销毁( <code>deallocated</code> )。并且每 一个线程都拥有一个独立的变量实例。<code>thread_local</code> 可以和<code>static</code> 与 <code>extern</code>关键字联合使用，这将影响变量的链接属性。</p>
<hr>
<h3><span id="static-关键字">static 关键字</span></h3><p>static最重要的四个作用：<strong>隐藏</strong>、<strong>持久</strong>、<strong>初始化为0</strong>和<strong>修饰类成员</strong></p>
<p>静态变量存储在<strong>全局存储区(静态存储区)</strong>，在整个程序运行期间一直存在。如果程序未显式给出初始化值，系统自动初始化为全 <code>0</code>，且初始化只进行一次。静态变量占有的空间要到整个程序执行结束才释放，故静态变量具有<strong>全局生命期</strong>。</p>
<h4><span id="隐藏">隐藏</span></h4><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p>
<h4><span id="持久static变量中的记忆功能和全局生存期">持久：static变量中的记忆功能和全局生存期</span></h4><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。static可以控制变量的可见范围，保持变量内容的持久。</p>
<p>静态变量根据定义位置的不同还分为 <code>局部静态变量</code> 和 <code>全局静态变量</code> 。</p>
<p>所有不加 <code>static</code> 的全局变量和函数具有<strong>全局可见性</strong>，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</p>
<ol>
<li><p><strong>局部静态变量：</strong></p>
<p>是指在块中定义的静态变量，当块第一次被执行的时候，编译器在<strong>全局存储区</strong>为其开辟空间并保存数据，该空间一直到整个程序结束才释放。该变量具有<strong>局部作用域</strong>，但却具有<strong>全局生命期</strong>。当定义它的函数或者语句块结束的时候，作用域结束。:star:但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且变量的值不变。</p>
</li>
<li><p><strong>全局静态变量：</strong></p>
<p>全局静态变量在声明他的文件之外是不可见的，作用域是从定义之处-&gt;文件结尾。</p>
</li>
<li><p><strong>静态函数：</strong></p>
<p>在函数返回类型前加 <code>static</code> ，函数就定义为静态函数。函数的定义和声明在默认情况下都是 <code>extern</code> 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用 <code>static</code> 修饰，那么这个函数只可在本 <code>cpp</code> 内使用，不会同其他 <code>cpp</code> 中的同名函数引起冲突。</p>
<p>注意：不要在头文件中声明 <code>static</code> 的全局函数，不要在 <code>cpp</code> 内声明非 <code>static</code> 的全局函数，如果你要在多个 <code>cpp</code> 中复用该函数，就把它的声明提到头文件里去，否则 <code>cpp</code> 内部声明需加上static修饰。</p>
<p>C++为了管理静态成员，提供了静态函数，静态函数对外提供接口，并且<strong>静态函数只能访问静态成员</strong>。</p>
<ul>
<li><strong>静态成员函数的意义不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。</strong></li>
<li><strong><code>static</code> 修饰成员函数，仅出现在声明处，不可在定义处。</strong></li>
<li>静态成员函数只能访问静态数据成员。原因：非静态成员函数在调用时 <strong>this</strong> 指针被当作参数传进。<strong>而静态成员函数是属于类，不属于对象</strong>，没有 <strong>this</strong> 指针。</li>
</ul>
</li>
<li><p><strong>类的静态成员：</strong></p>
<p>在类中，静态成员可以实现多个对象之间的<strong>数据共享</strong>，并且使用静态数据成员还<strong>不会破坏隐藏的原则</strong>，即保证了安全性。因此，静态成员是<strong>类的所有对象中共享的成员</strong>，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
</li>
<li><p><strong>类的静态函数：</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)。</p>
<ol>
<li>静态成员函数<strong>是类的一个特殊的成员函数</strong></li>
<li>静态成员函数<strong>属于整个类所有，没有this指针</strong></li>
<li>静态成员函数<strong>只能直接访问静态成员变量和静态成员函数</strong></li>
<li><strong>可以通过类名直接访问类的公有静态成员函数</strong></li>
<li><strong>可以通过对象名访问类的公有静态成员函数</strong></li>
<li><strong>定义静态成员函数，直接使用static关键字修饰即可</strong></li>
</ol>
<p>这里面有一种很常见的情况是，在 <code>sort()</code> 函数中，<code>sort</code> 函数的参数 <code>cmp</code> 的调用要求不带 <code>this</code> 指针，对于类内函数，他们都有一个隐式的 <code>this</code> 指针在第一个参数内，因此要么把 <code>cmp</code> 写在类外，要么加上 <code>static</code> 声明，<code>static</code> 声明后的成员函数不带有 <code>this</code> 指针。所以要写成如下形式：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态全局变量</strong>：注意使用 <code>static</code> 修饰变量，就不能使用 <code>extern</code> 来修饰，即 <code>static</code> 和 <code>extern</code> 不可同时出现。<code>static</code> 修饰的全局变量的声明与定义同时进行，即当你在头文件中使用 <code>static</code> 声明了全局变量，同时它也被定义了。</p>
<h4><span id="static成员函数不能被virtual修饰">static成员函数不能被virtual修饰</span></h4><p><strong><code>static</code> 成员不属于任何对象或实例，所以加上virtual没有任何实际意义</strong>；静态成员函数没有 <code>this</code> 指针，虚函数的实现是为每一个对象分配一个 <code>vptr</code> 指针，<strong>而vptr是通过this指针调用的，所以不能为virtual</strong>；</p>
<p>虚函数的调用关系，<strong>this-&gt;vptr-&gt;vtable-&gt;virtual function</strong></p>
<hr>
<h3><span id="const常量const函数">const常量/const函数</span></h3><h4><span id="const常量">const常量</span></h4><ul>
<li><code>const</code> 修饰数据成员，称为<strong>常数据成员</strong>。<strong>常数据成员可被普通成员函数和常成员函数来使用</strong>，不可以更改。</li>
<li><code>const</code> 常数据成员在使用前必须被初始化，也就是定义的同时就要初始化，之后不能再去赋值，只能使用。可以<ul>
<li>类中(不推荐）</li>
<li>初始化参数列表中(这是在类对象生成之前唯一一次改变 <code>const</code> 成员的值的机会了)。</li>
</ul>
</li>
</ul>
<p><code>const</code> 变量在类中初始化（下面两个，类的初始化列表优先级高）</p>
<ul>
<li>采用<strong>类的初始化列表</strong>进行初始化</li>
<li>类中变量定义的时候初始化 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span><span class="title">data</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> data = <span class="number">100</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="const函数">const函数</span></h4><ul>
<li><code>const</code> 修饰函数放在声明之后，实现体之前。</li>
<li><code>const</code> 修饰函数<strong>不能修改类内的数据成员变量</strong>。</li>
<li><code>const</code> 修饰函数只能调用 <code>const</code> 函数。非 <code>const</code> 函数可以调用 <code>const</code> 函数。</li>
<li><code>const</code> 修饰的全局函数在定义和声明处都需要 <code>const</code> 修饰符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">   <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">char</span> Screen::get() <span class="keyword">const</span> &#123;  </span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="const对象只能调用const成员函数">const对象：只能调用const成员函数</span></h4><h4><span id="const形参">const形参</span></h4><p><code>const</code> 形参可以接收 <code>const</code> 和非 <code>const</code> 类型的实参，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 可以是 int 型或者 const int 型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="堆和栈的区别">堆和栈的区别</span></h3><ul>
<li><strong>申请方式不同</strong>：栈由系统自动分配；堆是自己申请和释放的。</li>
<li><strong>申请大小限制不同：</strong>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
<li><strong>申请效率不同</strong>：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
<hr>
<h3><span id="c运算符重载">C++运算符重载</span></h3><ul>
<li>我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</li>
<li>两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</li>
<li>引入运算符重载，是为了实现类的多态性；</li>
<li>当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</li>
<li>从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</li>
<li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li>
<li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</li>
</ul>
<hr>
<h3><span id="c中null和nullptr的区别">C++中NULL和nullptr的区别</span></h3><p><strong>NULL</strong>来自C语言，一般由宏定义实现，而 <strong>nullptr</strong> 则是C++11的新增关键字。</p>
<p>在C语言中，<strong>NULL</strong>被定义为 <code>(void*)0</code> ，而在C++语言中，<strong>NULL</strong>则被定义为整数 <code>0</code> 。</p>
<p>编译器一般对其实际定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在C++中指针必须有明确的类型定义。但是将<strong>NULL</strong>定义为0带来的另一个问题是<strong>无法与整数的0区分</strong>。因为C++中允许<strong>有函数重载</strong>，所以可以试想如下函数定义情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"char*"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：int</span></span><br></pre></td></tr></table></figure>
<p>那么在传入<strong>NULL</strong>参数时，会把<strong>NULL</strong>当做整数0来看。<strong>nullptr</strong>在C++11被引入用于解决这一问题，<strong>nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</strong>对不同指针类型的函数重载，此时如果传入<strong>nullptr</strong>指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
<hr>
<h3><span id="cc源程序到可执行程序exe的全过程">C/C++源程序到可执行程序exe的全过程</span></h3><p>一个现代编译器的主要工作流程如下：</p>
<p>源程序（source code）→预处理器（preprocessor）→编译器（compiler）→汇编程序（assembler）→目标程序（object code）→连接器（链接器，Linker）→可执行程序（executables）。</p>
<p><img src="https://img-blog.csdnimg.cn/2019051218542467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTkyMDQ4,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4><span id="1-预处理生成testi">1. 预处理(生成test.i)</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c &gt; test.i  或  gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>
<p><strong>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</strong></p>
<ol>
<li>删除所有的#define，替换所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li>
<li>删除所有的注释，“//”和“/**/”。</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</li>
</ol>
<p><strong>C语言的宏替换和文件包含的工作，不归入编译器的范围，而是交给独立的预处理器。</strong></p>
<p>C语言中源代码文件的文件扩展名为.c，头文件的文件扩展名为.h，经预编译之后，生成xxx.i文件。</p>
<p>在C++，源代码文件的扩展名是.cpp或.cxx，头文件的文件扩展名为.hpp，经预编译之后，生成xxx.ii文件。</p>
<h4><span id="2-编译生成tests">2. 编译(生成test.s)</span></h4><p><strong>编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.c -o test.s 或 gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>这里的汇编所说的是一个过程，将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。相当于windows下的<strong>.obj文件</strong>。这里生成的目标文件里面就是二进制文件。另外，在这需要注意的是，会形成符号表，给这些符号会分配虚拟地址。</p>
<ol>
<li><strong>词法分析：</strong>利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的<strong>字符序列分割成一系列的记号</strong>。词法分析产生的<strong>记号分类</strong>有：关键字、标识符、字面量(数字、字符串)、特殊符号(加号、等号等)</li>
<li><strong>语法分析：</strong>语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的<strong>语法树是一种以表达式为节点的树</strong>。得到各种表达式的组合：赋值表达式、加法表达式、乘法表达式、数组表达式和括号表达式组成的复杂表达式。<strong>在语法分析的同时，就把运算符的优先级确定了下来，如果出现表达式不合法，——各种括号不匹配、表达式中缺少操作，编译器就会报错。</strong></li>
<li>语义分析：语义分析器则对<strong>表达式是否有意义</strong>进行判断，其分析的语义是<strong>静态语义</strong>——在编译期能确定的语义，相对应的动态语义是在运行期才能确定的语义。其中，<strong>静态语义通常包括：声明和类型的匹配，类型的转换</strong>，那么语义分析就会对这些方面进行检查，例如将一个int型赋值给int*型时，<strong>语义分析程序会发现这个类型不匹配，编译器就会报错。</strong></li>
</ol>
<h4><span id="3-汇编生成testo">3. 汇编(生成test.o)</span></h4><p><strong>汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.c -o test.o 或 gcc -c test.s -o test.o 或 gcc -c test.i -o test.o</span><br><span class="line">gcc -c x1.c x2.c  结果将生成：两个目标文件x1.o  x2.o</span><br></pre></td></tr></table></figure>
<p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
<p>但是，经过预编译、编译、汇编之后，生成机器可以执行的目标文件之后，还有<strong>一个问题——变量a和数组arr的地址还没有确定</strong>。这就需要链接器来搞定</p>
<h4><span id="4-链接生成默认aout">4. 链接(生成默认a.out)</span></h4><p><strong>连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件</strong></p>
<p><code>.c</code> 文件经过编译器、汇编器之后得到目标文件 <code>.o</code> ，目标文件再与库进行链接得到可执行文件 <code>.out</code> 。<br><strong>库其实就是一组目标文件的打包</strong>，这些目标文件中都是一些常用的代码。</p>
<p>我们在 <code>fun.c</code> 模块中定义了函数 <code>foo()</code> ，在 <code>main.c</code> 模块中引用了 <code>foo()</code> 函数，在编译过程当中，编译器并不知道 <code>main.c</code> 中 <code>foo()</code> 的地址，所以将调用 <code>foo()</code> 的指令的目标地址部分搁置，<br>等到了链接的阶段，链接器会去找到 <code>foo()</code> 定义的那个模块，在 <code>main.o</code> 中填入正确的函数地址，这个修改地址的过程被叫做<strong>重定位</strong>，每个被修正的地方叫<strong>重定位入口</strong>。</p>
<p>链接所完成的任务是<strong>合并段表</strong>，然后把<strong>符号表合并</strong>并且对<strong>符号表进行重定位</strong>。</p>
<ul>
<li>所谓<strong>合并段表</strong>，源代码编译生成的 <code>a.out</code> 会包含很多段，数据段文本段 <code>bss</code> 段等等，这些段是合并出来的，在编译过程中划分出来的，不同的数据会对应到不同的段中，在 <code>.o</code> 文件中其实已经发生了分段。</li>
<li><strong>符号表合并</strong>和<strong>重定位</strong>说的是<strong>最后只生成了一个符号表</strong>，这个符号表是由前面汇编形成的多个符号表进行合并。在这里不在同一个符号表的符号，要对他们进行重定位。</li>
</ul>
<h5><span id="静态链接">静态链接</span></h5><ul>
<li>以一组可重定位目标文件和命令行参数作为输入，生成一个<strong>完全链接</strong>的可以加载和运行的可执行目标文件。</li>
<li><strong>将链接库的代码复制到可执行程序中</strong></li>
</ul>
<p>静态链接做的事：</p>
<ul>
<li><strong>符号解析</strong>：将目标文件符号引用和定义联系起来（因为某些符号是引用其他模块的符号）</li>
<li><strong>重定位</strong>：编译器、汇编器生成从地址0开始的代码和数据，链接器把每个符号定义和一个存储器位置联系起来，然后修改所有对这些符号的引用，使得从另一个位置开始执行。 </li>
</ul>
<h5><span id="动态链接">动态链接</span></h5><p>函数的定义在动态链接库或共享对象的目标文件中</p>
<ul>
<li>在链接阶段，动态链接库<strong>只提供符号表等少量信息保证所有符号引用都有定义</strong>（不像静态链接直接复制过去），保证编译顺利通过。</li>
<li>在可执行文件执行时，<strong>动态连接库将函数等内容映射到运行时相应进程的虚地址空间</strong>。</li>
</ul>
<h5><span id="目标文件">目标文件</span></h5><ul>
<li>可重定位目标文件：含二进制代码、数据，因引用了其他模块的符号而不能执行</li>
<li>共享目标文件/动态库： .so文件</li>
<li>可执行文件</li>
</ul>
<hr>
<h3><span id="右值引用">右值引用</span></h3><p><strong>左值与右值</strong></p>
<p>左值可以取地址、位于等号左边；而右值没法取地址，位于等号右边。</p>
<p>有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<h4><span id="左值引用">左值引用</span></h4><p><strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure>
<p>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。但是，<strong>const左值引用</strong>是可以指向右值的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<p><code>const</code> 左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用 <code>const &amp;</code> 作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p>
<h4><span id="右值引用">右值引用</span></h4><p>右值引用的标志是 <code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>
<h4><span id="右值引用有办法指向左值吗">右值引用有办法指向左值吗</span></h4><p>可以通过 <code>std::move()</code> 实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>
<p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>。</p>
<p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参是个右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span> </span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// ref_a_left是个左值引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// ref_a_right是个右值引用</span></span><br><span class="line"> </span><br><span class="line">    change(a); <span class="comment">// 编译不过，a是左值，change参数要求右值</span></span><br><span class="line">    change(ref_a_left); <span class="comment">// 编译不过，左值引用ref_a_left本身也是个左值</span></span><br><span class="line">    change(ref_a_right); <span class="comment">// 编译不过，右值引用ref_a_right本身也是个左值</span></span><br><span class="line">     </span><br><span class="line">    change(<span class="built_in">std</span>::move(a)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_right)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_left)); <span class="comment">// 编译通过</span></span><br><span class="line"> </span><br><span class="line">    change(<span class="number">5</span>); <span class="comment">// 当然可以直接接右值，编译通过</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    <span class="comment">// 打印这三个左值的地址，都是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::move()</code> 会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以 <code>move</code> 返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：</p>
<p><strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p>
<p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 </p>
<p><strong>总的来说：</strong></p>
<ol>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以<strong>避免拷贝</strong>。</li>
<li>右值引用可以直接指向右值，也可以通过 <code>std::move</code> 指向左值；而左值引用只能指向左值( <code>const</code> 左值引用也能指向右值)。</li>
<li>作为函数形参时，右值引用更灵活。虽然 <code>const</code> 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// 编译失败，const左值引用不能修改指向变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> &amp;&amp; n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">5</span>);</span><br><span class="line">    f2(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际场景中，右值引用和 <code>std::move</code> 被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。在 <code>STL</code> 的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如 <code>std::vector</code> 的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<p>移动构造函数即：把被拷贝者的数据移动过来，被拷贝者后边就不要这个数据了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2：std::vector和std::string的实际例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"aacasxs"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.push_back(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.emplace_back(<span class="built_in">std</span>::move(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.emplace_back(<span class="string">"axcsddcas"</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::vector方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有些 <code>STL</code> 类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_a = <span class="built_in">std</span>::make_unique&lt;A&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = <span class="built_in">std</span>::move(ptr_a); <span class="comment">// unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr_b = ptr_a; <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<h4><span id="完美转发-stdforward">完美转发 std::forward()</span></h4><p>和<code>std::move</code>一样，<code>std::forward</code>也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换。</p>
<p>与 <code>move</code> 相比，<code>forward</code> 更强大，<code>move</code> 只能转出来右值，<code>forward</code> 都可以。</p>
<blockquote>
<p>std::forward<t>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</t></p>
</blockquote>
<h4><span id="autoampamp也是这个意思">auto&amp;&amp;也是这个意思</span></h4><p>迭代器中如果使用 <code>auto&amp;&amp;</code> 代表着接受任何初始化程序，无论它是左值表达式还是右值表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>         =&gt; will copy the <span class="built_in">vector</span>, but we wanted a reference</span><br><span class="line"><span class="keyword">auto</span>&amp;        =&gt; will only bind to modifiable lvalues</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;  =&gt; will bind to anything but make it <span class="keyword">const</span>, giving us const_iterator</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; =&gt; will bind only to rvalues</span><br></pre></td></tr></table></figure>
<p>所以说大部分情况下，<code>auto</code> 和 <code>auto&amp;&amp;</code> 能够解决大部分问题。</p>
<hr>
<h3><span id="c内联函数">C++内联函数</span></h3><h4><span id="内联函数有什么优点">内联函数有什么优点？</span></h4><ol>
<li><code>inline</code> 函数代码是被放到<strong>符号表</strong>中，使用时像宏一样展开，没有调用的开销，效率很高；</li>
<li><code>inline</code> 函数和普通函数相比可以加快程序运行的速度，因为<strong>不需要中断调用，在编译的时候内联函数可以直接嵌入到目标代码中。</strong></li>
<li><code>inline</code> 函数是真正的函数，所以要进行一系列的数据类型检查；</li>
<li><code>inline</code> 函数作为类的成员函数，可以使用类的保护成员及私有成员；</li>
</ol>
<h4><span id="内联函数适用场景">内联函数适用场景</span></h4><ul>
<li>使用宏定义的地方都可以使用 <code>inline</code> 函数</li>
<li>作为<strong>作为某个类的成员函数</strong>来<strong>读写类的私有成员或者保护成员，会提高效率</strong></li>
</ul>
<p>C++中支持内联函数，其目的是为了<strong>提高函数的执行效率，它以省去函数调用的开销来提高执行效率。</strong>：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。用关键字 <code>inline</code> 放在函数定义(<strong>注意是定义而非声明</strong>)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上<strong>内联地</strong>展开，假设我们将 <code>max</code> 定义为内联函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>cout&lt;&lt;max(a, b)&lt;&lt;endl;</code> 的时候，编译时会展开为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;(a &gt; b ? a : b)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>Effective C++</code> 中，<code>Prefer consts，enums，and inlines to #defines</code>，建议我们用内联函数来替代宏定义。</p>
<h4><span id="缺点">缺点</span></h4><ol>
<li><strong>代码膨胀：</strong>内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li><strong>inline 函数无法随着函数库升级而升级</strong>：inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li><strong>是否内联，程序员不可控</strong>：内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4><span id="构造函数-析构函数-虚函数可否声明为内联函数">构造函数、析构函数、虚函数可否声明为内联函数？</span></h4><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为 <code>inline</code> 同 <code>register</code> 一样，只是个建议，编译器并不一定真正的内联。</p>
<h5><span id="构造函数和析构函数声明为内联函数是没有意义的"><strong>构造函数和析构函数声明为内联函数是没有意义的</strong></span></h5><p>《Effective C++》中所阐述的是：<strong>将构造函数和析构函数声明为inline是没有什么意义的</strong>，<strong>即编译器并不真正对声明为inline的构造和析构函数进行内联操作</strong>，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p>
<h5><span id="将虚函数声明为inline要分情况讨论"><strong>将虚函数声明为inline，要分情况讨论</strong></span></h5><p>如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p>
<p>综上，当是指向派生类的指针（多态性）调用声明为 <code>inline</code> 的虚函数时，不会内联展开；当是<strong>对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下</strong></p>
<h4><span id="将内联函数放入头文件">将内联函数放入头文件</span></h4><p>关键字 <code>inline</code> 必须与函数定义体放在一起才能使函数成为内联，仅将 <code>inline</code> 放在函数声明前面不起任何作用。定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125;   <span class="comment">// 自动地成为内联函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 <code>inline</code> 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p>
<p>当然内联函数定义也可以放在源文件中，但此时<strong>只有定义的那个源文件可以用它</strong>，而且<strong>必须为每个源文件拷贝一份定义</strong>(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。</p>
<hr>
<h3><span id="宏定义define">宏定义#Define</span></h3><h4><span id="宏定义和函数区别">宏定义和函数区别？</span></h4><ul>
<li>宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</li>
<li>宏定义属于<strong>在结构中插入代码，没有返回值</strong>；函数调用具有返回值。</li>
<li>宏定义<strong>参数没有类型，不进行类型检查</strong>；<strong>函数参数具有类型，需要检查类型</strong>。</li>
<li>宏定义不用在最后加分号。</li>
</ul>
<h4><span id="宏定义和typedef区别">宏定义和typedef区别？</span></h4><ul>
<li><p>宏主要用于定义<strong>常量及书写复杂的内容</strong>；<code>typedef</code> 主要用于定义<strong>类型别名</strong>。</p>
</li>
<li><p><strong>宏替换发生在预编译阶段</strong>，属于文本插入替换；<code>typedef</code> 是<strong>编译的一部分，发生在编译阶段</strong>。</p>
</li>
<li><p><strong>宏不检查类型</strong>；<strong>typedef会检查数据类型</strong>。</p>
</li>
<li><p>宏不是语句，不在在最后加分号；<strong>typedef是语句，要加分号标识结束</strong>。</p>
</li>
<li><p><strong>作用域不同</strong>：<code>#define</code> 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而<code>typedef</code> 有自己的作用域。</p>
</li>
<li><p>注意对指针的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTPTR1 int*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* INTPTR2;</span><br><span class="line">INTPTR1 p1, p2;</span><br><span class="line">INTPTR2 p3, p4;</span><br></pre></td></tr></table></figure>
<p>含义分别为：声明一个指针变量p1和一个整型变量p2，声明两个指针变量p3、p4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTPTR1 int*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* INTPTR2;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> INTPTR1 p1 = &amp;a;</span><br><span class="line"><span class="keyword">const</span> INTPTR2 p2 = &amp;b;</span><br><span class="line">INTPTR2 <span class="keyword">const</span> p3 = &amp;c;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const INTPTR1 p1</code> 是一个<strong>常量指针</strong>，即不可以通过 <code>p1</code> 去修改 <code>p1</code> 指向的内容，但是 <code>p1</code> 可以指向其他内容。</li>
<li><code>const INTPTR2 p2</code> 是一个<strong>指针常量</strong>，不可使 <code>p2</code> 再指向其他内容。因为 <code>INTPTR2</code> 表示一个指针类型，因此用 <code>const</code> 限定，表示封锁了这个指针类型。</li>
<li><code>INTPTR2 const p3</code> 是一个<strong>指针常量</strong></li>
</ul>
</li>
</ul>
<h4><span id="宏定义与内联函数的区别">宏定义与内联函数的区别？</span></h4><ol>
<li><p>内联函数在<strong>编译时展开</strong>，宏在<strong>预编译时展开</strong>；</p>
</li>
<li><p>内联函数直接<strong>嵌入到目标代码中</strong>，宏是简单的做<strong>文本替换</strong>；</p>
<p>所以这时候宏定义会出意想不到的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= ADD(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//所得的结果却是210</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------其实本质就是--------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a= x + y * <span class="number">10</span>;  <span class="comment">//编译器并不会给其加括号</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内联函数有<strong>类型检测、语法判断</strong>等功能，宏没有；</p>
</li>
<li><p><code>inline</code> 函数是函数，宏定义不是；</p>
</li>
<li><p>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；</p>
</li>
<li><p>C++中引入了类及类的访问控制，在涉及到<strong>类的保护成员和私有成员</strong>就不能用宏定义来操作。</p>
</li>
</ol>
<h4><span id="宏定义和const的区别">宏定义和const的区别</span></h4><h5><span id="编译阶段">编译阶段</span></h5><ul>
<li><code>define</code> 是在编译的<strong>预处理</strong>阶段起作用，而 <code>const</code> 是在<strong>编译、运行</strong>的时候起作用</li>
</ul>
<h5><span id="安全性">安全性</span></h5><ul>
<li><code>define</code> 只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</li>
<li><code>const</code> 常量有<strong>数据类型</strong>，<strong>编译器可以对其进行类型安全检查</strong></li>
</ul>
<h5><span id="内存占用">内存占用</span></h5><ul>
<li><code>define</code> 只是将宏名称进行替换，在内存中会产生多分相同的备份。<code>const</code> 在<strong>程序运行中只有一份备份</strong>，且可以执行<strong>常量折叠</strong>，能将复杂的的表达式计算出结果放入常量表</li>
<li>宏替换发生在编译阶段之前，属于文本插入替换；<code>const</code> 作用发生于编译过程中。</li>
<li>宏不检查类型；<code>const</code> 会<strong>检查数据类型</strong>。</li>
<li>宏定义的数据<strong>没有分配内存空间</strong>，只是插入替换掉；<code>const</code> 定义的变量只是值不能改变，但要分配内存空间。</li>
</ul>
<hr>
<h3><span id="c11类型说明符autodecltypedecltypeauto">C++11类型说明符auto/decltype/decltype(auto)</span></h3><h4><span id="auto">auto</span></h4><p>C++11新标准引入了<strong>auto</strong>类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p><strong>auto</strong> 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 <strong>auto</strong> 定义的变量必须有初始值。</p>
<h4><span id="decltype">decltype</span></h4><p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</p>
<p>还有可能是函数的返回类型为某表达式的值类型。</p>
<p>在这些时候<strong>auto</strong>显得就无力了，所以C++11又引入了第二种类型说明符<strong>decltype</strong>，它的作用是<strong>选择并返回操作数的数据类型</strong>。<strong>在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(func()) sum = <span class="number">5</span>; <span class="comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>; <span class="comment">// a的类型是int, 所以b的类型也是int</span></span><br><span class="line"><span class="comment">//不论是顶层const还是底层const, decltype都会保留   </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c; <span class="comment">// d的类型和c是一样的, 都是顶层const</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f; <span class="comment">// g也是底层const</span></span><br><span class="line"><span class="comment">//引用与指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>; <span class="comment">// k的类型是 const int&amp;</span></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>; <span class="comment">// 此时是int类型</span></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp;类型, c和j绑定在一起</span></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i; <span class="comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></span><br></pre></td></tr></table></figure>
<h4><span id="decltypeauto">decltype(auto)</span></h4><p><strong>decltype(auto)</strong>是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将 <code>=</code> 号左边的表达式替换掉<strong>auto</strong>，再根据<strong>decltype</strong>的语法规则来确定类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="volitalemutableexplicit关键字">Volitale/mutable/explicit关键字</span></h3><h4><span id="volitale关键字">Volitale关键字</span></h4><p> <code>volatile</code> 关键字直译应该是 <code>易变的</code> ，也就是它修饰的对象有可能突然发生不可预期的改变。被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p>
<p><code>volatile</code> 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>，从而可以<strong>提供对特殊地址的稳定访问</strong>。</p>
<p><code>volatile</code> 可理解为编译器警告指示字；<code>volatile</code> 用于告诉编译器必须每次去内存中取变量值；<code>volatile</code>主要修饰可能被多个线程访问的变量；<code>volatile</code> 也可以修饰可能被未知因数更改的变量。</p>
<p>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。<strong>多线程中被几个任务共享的变量需要定义为volatile类型</strong>。当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p>
<p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在<strong>主存(物理内存)</strong>当中的，这时就存在一个问题，由于CPU执行速度很快，而<strong>从内存读取数据</strong>和<strong>向内存写入数据</strong>的过程跟<strong>CPU执行指令的速度</strong>比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。</p>
<p>为了处理这个问题，在CPU里面就有了<strong>高速缓存(Cache)</strong>的概念。当程序在运行过程中，会将运算需要的数据<strong>从主存复制一份到CPU的高速缓存当中</strong>，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将<strong>高速缓存中的数据刷新到主存当中</strong>。</p>
<p>这一过程在单线程运行是没有问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存。这时就会出现同一个变量在两个高速缓存中的<strong>值</strong>不一致问题了。例如：两个线程分别读取了 <code>t</code> 的值，假设此时 <code>t</code> 的值为0，并且把 <code>t</code> 的值存到了各自的高速缓存中，然后线程1对 <code>t</code> 进行了加1操作，此时 <code>t</code> 的值为1，并且把 <code>t</code> 的值写回到主存中。但是线程2中高速缓存的值还是0，进行加1操作之后，<code>t</code> 的值还是为1，然后再把 <code>t</code> 的值写回主存。此时，就出现了 <code>线程不安全</code> 问题了。</p>
<p>按照 <a href="https://link.zhihu.com/?target=http%3A//web.archive.org/web/20180120044239/http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html" target="_blank" rel="noopener">Hans Boehm &amp; Nick Maclaren 的总结</a>，<code>volatile</code> 只在三种场合下是合适的。</p>
<ul>
<li>和信号处理（signal handler）相关的场合；</li>
<li>和内存映射硬件（memory mapped hardware）相关的场合；</li>
<li>和非本地跳转（<code>setjmp</code> 和 <code>longjmp</code>）相关的场合。换句话说也就是</li>
</ul>
<p>也就是：</p>
<p><strong>1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；</strong></p>
<p><strong>2) 多任务环境下各任务间共享的标志应该加volatile；</strong></p>
<p><strong>3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</strong></p>
<h5><span id="volatile指针">volatile指针</span></h5><p>和 <code>const</code> 修饰词类似，<code>const</code> 有常量指针和指针常量的说法，<code>volatile</code> 也有相应的概念：</p>
<ul>
<li>修饰由指针指向的对象、数据是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span>* vpch;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针自身的值——一个代表地址的整数变量，是 <code>const</code> 或 <code>volatile</code> 的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>(1) 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</strong></p>
<p>(2) 除了基本类型外，对用户定义类型也可以用 <code>volatile</code> 类型进行修饰。</p>
<p>(3) C++中一个有 <code>volatile</code> 标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用<code>const_cast</code> 来获得对类型接口的完全访问。此外，<code>volatile</code> 像 <code>const</code> 一样会从类传递到它的成员。</p>
<h5><span id="可见性">可见性</span></h5><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的<strong>工作空间</strong>中读取。<br>例如我们上面说的，当线程1对 <code>t</code> 进行了加1操作并把数据写回到主存之后，线程2就会知道它自己工作空间内的 <code>t</code> 已经被修改了，当它要执行加1操作之后，就会去主存中读取。这样，两边的数据就能一致了。<br>假如一个变量被声明为 <code>volatile</code> ，那么这个变量就具有了<strong>可见性</strong>的性质了。这就是 <code>volatile</code> 关键的作用之一了。</p>
<hr>
<h4><span id="mutable-关键字">mutable 关键字</span></h4><ul>
<li><p><strong>mutable</strong> 关键字仅适用于类的对象。它允许对象的成员替代常量。也就是说，<code>mutable</code> 成员可以通过 <code>const</code> 成员函数修改。</p>
</li>
<li><p><strong>mutable</strong>的中文意思是“可变的，易变的”，跟<strong>constant</strong>（既C++中的const）是反义词。在C++中，<strong>mutable也是为了突破const的限制而设置的</strong>。</p>
</li>
<li><strong>被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中</strong>。</li>
</ul>
<p>我们知道，如果<strong>类的成员函数不会改变对象的状态</strong>，那么这个成员函数一般会声明成<strong>const</strong>的。但是，有些时候，我们需要在<strong>const</strong>函数里面<strong>修改一些跟类状态无关的数据成员</strong>，那么这个函数就应该被<strong>mutable</strong>来修饰，并且放在函数后后面关键字位置。</p>
<hr>
<h4><span id="explicit关键字">explicit关键字</span></h4><p><strong>explicit</strong>关键字用来修饰类的构造函数，<strong>被修饰的构造函数的类，不能发生相应的隐式类型转换</strong>，只能以显示的方式进行类型转换，注意以下几点：</p>
<ul>
<li><strong>explicit</strong> 关键字<strong>只能用于类内部的构造函数声明上</strong></li>
<li><strong>explicit</strong> 关键字<strong>作用于单个参数的构造函数</strong></li>
<li>被<strong>explicit</strong>修饰的构造函数的类，<strong>不能发生相应的隐式类型转换</strong></li>
</ul>
<hr>
<h3><span id="union-联合体">union 联合体</span></h3><p>联合(union)是一种节省空间的特殊的类，一个 <code>union</code> 可以有多个数据成员，但是<strong>在任意时刻只有一个数据成员可以有值</strong>。<strong>当某个成员被赋值后其他成员变为未定义状态</strong>。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 <code>public</code></li>
<li>可以含有构造函数、析构函数</li>
<li><strong>不能含有引用类型的成员</strong></li>
<li><strong>不能继承自其他类，不能作为基类</strong></li>
<li>不能含有虚函数</li>
<li>匿名 <code>union</code> 在定义所在作用域可直接访问 <code>union</code> 成员</li>
<li>匿名 <code>union</code> 不能包含 <code>protected</code> 成员或 <code>private</code> 成员</li>
<li>全局匿名联合必须是静态 <code>static</code> 的</li>
</ul>
<hr>
<h3><span id="finaloverride关键字">final/override关键字</span></h3><h5><span id="override">override</span></h5><p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用 <code>override</code> ，当你手一抖，将 <code>foo()</code> 写成了 <code>f0o()</code> 会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，<code>override</code> 的作用就出来了，它<strong>指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，这个函数是B新增的，不是继承的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f0o</span><span class="params">()</span> override</span>; <span class="comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5><span id="final继承的终点">final(继承的终点)</span></h5><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在<strong>类名和虚函数</strong>后添加 <code>final</code> 关键字，添加 <code>final</code> 关键字后被继承或重写，编译器会报错。</p>
<p>例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> final</span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: B is final</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> B &#123;&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="深拷贝与浅拷贝">深拷贝与浅拷贝</span></h3><p>C++中类的拷贝有两种：<strong>深拷贝</strong>，<strong>浅拷贝</strong>：当出现类的等号赋值时，即会调用拷贝函数。</p>
<h4><span id="深拷贝与浅拷贝的区别"><strong>深拷贝与浅拷贝的区别</strong></span></h4><ol>
<li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但<strong>当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂</strong>现象，所以，此时，必须采用深拷贝。</li>
<li>深拷贝与浅拷贝的区别就在于深拷贝<strong>会在堆内存中另外申请空间来储存数据</strong>，从而也就解决了指针悬挂的问题。而浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。简而言之，当<strong>数据成员中有指针时，必须要用深拷贝</strong>。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180201123405115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvc2hhbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。</p>
<p>深拷贝的实现一般如下，即自己定义拷贝构造函数来实现深拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student();</span><br><span class="line">	~Student();</span><br><span class="line">	Student(<span class="keyword">const</span> Student &amp;s);<span class="comment">//深拷贝构造函数，const防止对象被改变</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Student::Student() &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">Student::~Student() &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; (<span class="keyword">int</span>)name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> name;</span><br><span class="line">	name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;s) &#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(name, s.name, <span class="built_in">strlen</span>(s.name));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="拷贝初始化和直接初始化">拷贝初始化和直接初始化</span></h3><p>当用于<strong>类类型对象</strong>时，初始化的拷贝形式和直接形式有所不同：</p>
<ul>
<li>直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。</li>
<li>拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。</li>
</ul>
<p>举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">"I am a string"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(str1)</span></span>;<span class="comment">//str1是已经存在的对象，直接调用构造函数对str2进行初始化</span></span><br><span class="line"><span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">"I am a string"</span>;<span class="comment">//先为字符串"I am a string"创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span></span><br><span class="line"><span class="built_in">string</span> str4 = str1;<span class="comment">//这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>为了提高效率，允许编译器跳过创建临时对象这一步，</strong>直接调用构造函数构造要创建的对象，这样就完全等价于<strong>直接初始化了</strong>（语句1和语句3等价）。但是需要辨别两种情况。<ul>
<li>当拷贝构造函数为<strong>private</strong>时：语句3和语句4在编译时会报错</li>
<li>使用<strong>explicit</strong>修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li>
</ul>
</li>
</ul>
<hr>
<h3><span id="必须在构造函数初始化列表里进行初始化的数据成员">必须在构造函数初始化列表里进行初始化的数据成员</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="built_in">string</span> &amp;name;</span><br><span class="line">    Address addr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">int</span> grade, <span class="built_in">string</span> name): grade(grade), name(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常量成员</strong>：常量成员只能初始化不能赋值，所以必须放在初始化列表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>引用类型</strong>：引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。(<strong>声明后需要马上初始化</strong>)</li>
<li><strong>对象成员</strong>：成员是其他类的对象，例如上面的 <code>Address addr</code> 成员。如果把它放在构造函数的初始化列表里，此时会调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>，对这个类对象进行初始化。如果把它放在构造函数体中，会先调用 <code>Address</code> 类的<strong>默认构造函数</strong>，然后再调用 <code>Address</code> 类的<strong>拷贝构造函数</strong>。从性能上考虑，把对象成员的初始化放在初始化列表里性能会更高。</li>
<li><strong>调用成员类的构造函数：</strong>如果我们有一个<strong>类成员</strong>，它本身是一个类或者是一个结构，而且这个成员它<strong>只有一个带参数的构造函数，而没有默认构造函数</strong>，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。</li>
<li><strong>调用一个基类的构造函数而它拥有一组参数时；</strong></li>
</ul>
<h4><span id="成员初始化列表做了什么">成员初始化列表做了什么</span></h4><ol>
<li><p>编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p>
</li>
<li><p><strong>list</strong>中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p>
</li>
</ol>
<h4><span id="赋值初始化与列表初始化的区别">赋值初始化与列表初始化的区别</span></h4><ul>
<li>对于在函数体中赋值初始化，是在所有的数据成员被分配内存空间后才进行的。</li>
<li>列表初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)，<strong>那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</strong></li>
</ul>
<hr>
<h3><span id="定位内存泄露及检测">定位内存泄露及检测</span></h3><p><a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" target="_blank" rel="noopener">https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html</a></p>
<ol>
<li><p>在 <code>windows</code> 平台下通过 <code>CRT</code> 中的库函数进行检测；</p>
<ul>
<li><p><strong>检查方法</strong></p>
<p>在 <code>main</code> 函数最后面一行，加上一句<strong>_CrtDumpMemoryLeaks</strong>()。调试程序，自然关闭程序让其退出，查看输出：输出这样的格式，被{}包围的453就是我们需要的<strong>内存泄漏定位值</strong>，<code>868 bytes lon</code> g就是说这个地方有868比特内存没有释放。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">453</span>&#125;normal block at <span class="number">0x02432CA8</span>,<span class="number">868</span> bytes <span class="keyword">long</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>定位代码位置</strong></li>
</ul>
<p>在 <code>main</code> 函数第一行加上<strong>_CrtSetBreakAlloc(453)</strong>，意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include</p>
</li>
<li><p>在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置</p>
</li>
<li><p><code>Linux</code> 下通过工具 <code>valgrind</code> 检测</p>
</li>
</ol>
<hr>
<h3><span id="c函数调用的压栈过程">C++函数调用的压栈过程</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> param1, <span class="keyword">int</span> param2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = param1;</span><br><span class="line">    <span class="keyword">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"var1=%d,var2=%d"</span>, f(var1), f(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//var1=1,var2=2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当函数从入口函数 <code>main</code> 函数开始执行时，编译器会将我们<strong>操作系统的运行状态</strong>，<strong><code>main</code> 函数的返回地址</strong>、<code>main</code> 的参数、<code>main</code> 函数中的变量、进行依次压栈；</li>
<li>当 <code>main</code> 函数开始调用 <code>func()</code> 函数时，编译器此时会将 <strong><code>main</code> 函数的运行状态</strong>进行压栈，再将 <code>func()</code> 函数的返回地址、<code>func()</code> 函数的参数<strong>从右到左</strong>、<code>func()</code> 定义变量依次压栈；</li>
<li>当 <code>func()</code> 调用 <code>f()</code> 的时候，编译器此时会将 <strong><code>func()</code> 函数的运行状态</strong>进行压栈，再将 <code>f()</code> 的返回地址、 <code>f()</code> 函数的参数<strong>从右到左</strong>、<code>f()</code> 定义变量依次压栈。</li>
<li>从代码的输出结果可以看出，函数 <code>f(var1)</code> 、<code>f(var2)</code> 依次入栈，而后先执行 <code>f(var2)</code> ，再执行 <code>f(var1)</code> ，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</li>
</ul>
<hr>
<h3><span id="手写strcpymemcpystrcatstrcmp等函数">手写strcpy，memcpy，strcat，strcmp等函数</span></h3><h4><span id="strcpy">strcpy</span></h4><ol>
<li><code>const</code> 修饰：源字符串参数用 <code>const</code> 修饰，防止修改源字符串；</li>
<li>空指针检查：源指针和目的指针都有可能会出现空指针的情况，所以应该对其进行检查；</li>
<li>为什么要设置 <code>ret</code> 指针以及返回 <code>ret</code> 指针的位置，由于目的指针 <code>dst</code> 已经在进行移动了，所以用辅助指针 <code>ret</code> 表明首指针；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数是没有考虑重叠的</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dst);</span><br><span class="line">    assert(src);</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑重叠</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(src) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dst &gt; src &amp;&amp; dst &lt; src + size) &#123;</span><br><span class="line">        dst = dst + size - <span class="number">1</span>;</span><br><span class="line">        src = src + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">            *dst-- = *src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">            *dst++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="memcpy">memcpy</span></h4><p>对于地址重叠的情况，该函数的行为是未定义的。因此自己动手实现 <code>memcpy()</code> 时就需要考虑地址重叠的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> *ret = dst;</span><br><span class="line">	<span class="keyword">char</span>* pdst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">	<span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">	<span class="keyword">if</span> (pdst &gt; src || pdst &lt; psrc + size) &#123;</span><br><span class="line">		pdst = pdst + size - <span class="number">1</span>;</span><br><span class="line">		psrc = psrc + size - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst-- = *psrc--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">			*pdst++ = *psrc++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strlen">strlen</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    assert(<span class="literal">NULL</span> != str);</span><br><span class="line">    <span class="keyword">while</span> (*str++ != <span class="string">'\0'</span>) &#123;　</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcat">strcat</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*dst,<span class="keyword">const</span> <span class="keyword">char</span>*src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">while</span> (*dst != <span class="string">'\0'</span>)	</span><br><span class="line">        dst++;<span class="comment">//要在循环体内++；因为要是*strDest最后指向该字符串的结束标志’\0’</span></span><br><span class="line">	<span class="keyword">while</span> ((*dst++ = *src++) != <span class="string">'\0'</span>);<span class="comment">//赋值+自增+判断非结尾</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="strcmp">strcmp</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!str1 || !str2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (*str1 == *str2 &amp;&amp; str1 != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		str1++;</span><br><span class="line">		str2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="memmove">memmove</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *pdst, <span class="keyword">const</span> <span class="keyword">void</span>* psrc, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pdst || !psrc)   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span>* dst = (<span class="keyword">char</span>*)pdst;</span><br><span class="line">	<span class="keyword">char</span> *src = (<span class="keyword">char</span>*)psrc;</span><br><span class="line">	<span class="keyword">char</span> *ret = dst;</span><br><span class="line">	<span class="keyword">if</span> (dst &lt; src || dst &gt;(src + n - <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst++) = *(src++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dst = dst + n - <span class="number">1</span>;</span><br><span class="line">		src = src + n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*(dst--) = *(src--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="c实现堆排序原地算法">⭐C++实现堆排序(原地算法)</span></h3><p><a href="https://www.cnblogs.com/wanglei5205/p/8733524.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanglei5205/p/8733524.html</a></p>
<p><a href="https://www.cnblogs.com/yinheyi/p/10836167.html" target="_blank" rel="noopener">https://www.cnblogs.com/yinheyi/p/10836167.html</a></p>
<p>堆使用一个数组表示， 它可以当作一个完全二叉树，除了最底层之外，其它层都是满的，并且最底层也是从左到右填充的。当堆的下标（数组的下标）从1开始时比较好计算。因为：</p>
<ol>
<li>当父结点为 <code>i</code> 时，左孩子为 <code>2i</code> ,  右孩子为 <code>2i+1</code> ;</li>
<li>当孩子结点的下标为 <code>j</code> 时，父结点的下标为 <code>j/2</code>  (根结点为父结点）;</li>
<li>一个结点的下标为 <code>k</code> 时， 则它所有的深度为 <code>floor(logK)</code> ;</li>
<li><p>当一个堆共 <code>n</code> 个元素时，它的高度为 <code>floor(logN)</code> 。</p>
<pre><code>        1
    /       \
    2             3
/   \         /    \
4      5       6       7
/ \    / \     /  \   /   \
8    9  10  11  12   13 14   15
</code></pre><p>但是呢，数组的下标都是从0开始的，所以呢，我们写代码时，还是需要从0开始，而此时：</p>
<pre><code>1. 当父结点的下标为 `i` 时，左孩子为 `2i+1`, 右孩子为 `2*(i+1)` 
        2. 当孩子结点的下标为 `j` 时，父结点的下标为 `(j-1)/2` 。

            0
        /       \
     1             2
   /   \         /    \
 3      4       5       6
/ \    / \     /  \   /   \
</code></pre><p>   7    8  9  10  11   12 13   14</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三个宏，分别用于求左孩子/右孩子/父结点的下标。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT(i) (((i) &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT(i) (((i) + 1) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT(i) (((i) - 1) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs &lt; rhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">greate</span><span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs &gt; rhs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*Comp)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 交换两个元素的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; lhs, <span class="keyword">int</span>&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _nTemp = lhs;</span><br><span class="line">    lhs = rhs;</span><br><span class="line">    rhs = _nTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设一个节点的左子树与右子树都满足堆的性质，而该节点不满足最大堆或最小堆的性质，该</span></span><br><span class="line"><span class="comment">// 函数实现调整节点位置，维护堆的性质。</span></span><br><span class="line"><span class="comment">// 输入参数分别表示: 堆的数组/数组长度/节点i的下标/表示比较的二元谓词</span></span><br><span class="line"><span class="comment">// 复杂度为O(logN).</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> nLength_, <span class="keyword">int</span> nIndex_, Comp CompFunc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">nullptr</span> || nIndex_ &gt;= nLength_ || nIndex_ &lt; <span class="number">0</span> || CompFunc == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _nLeft = LEFT(nIndex_);</span><br><span class="line">    <span class="keyword">int</span> _nRight = RIGHT(nIndex_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最大值节点的下标;</span></span><br><span class="line">    <span class="keyword">int</span> _nLargest = nIndex_;</span><br><span class="line">    <span class="keyword">if</span> (_nLeft &lt; nLength_ &amp;&amp; !CompFunc(<span class="built_in">array</span>[_nLargest], <span class="built_in">array</span>[_nLeft])) &#123;</span><br><span class="line">        _nLargest = _nLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_nRight &lt; nLength_ &amp;&amp; !CompFunc(<span class="built_in">array</span>[_nLargest], <span class="built_in">array</span>[_nRight])) &#123;</span><br><span class="line">        _nLargest = _nRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此时不需要维护堆的性质，直接返回   */</span></span><br><span class="line">    <span class="keyword">if</span> (_nLargest == nIndex_)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    swap(<span class="built_in">array</span>[nIndex_], <span class="built_in">array</span>[_nLargest]);</span><br><span class="line">    Heapify(<span class="built_in">array</span>, nLength_, _nLargest, CompFunc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个数组建立一个最小堆或最大堆。</span></span><br><span class="line"><span class="comment">// 输入参数为：一维数组/数组的长度/表示比较的二元谓词，用于控制建最小堆还是最大堆</span></span><br><span class="line"><span class="comment">// 复杂度为O(N).</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BulidHeap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> nLength_, Comp CompFunc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">nullptr</span> || nLength_ &lt;= <span class="number">1</span> || CompFunc == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的父节点开始调用Heapify()函数来建堆。</span></span><br><span class="line">    <span class="comment">// 堆调整的过程是从右到左，从下到上的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = PARENT(nLength_ - <span class="number">1</span>); i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        Heapify(<span class="built_in">array</span>, nLength_, i, CompFunc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序的函数</span></span><br><span class="line"><span class="comment">// 说明：1. 通过建立[最大堆]可以实现[从小到大]的排序;</span></span><br><span class="line"><span class="comment">//       2. 通过建立[最小堆]可以实现[从大到小]的排序</span></span><br><span class="line"><span class="comment">//       3. 堆排序为原址排序，它不需要借助额外的空间.(归并排序不是原址排序）</span></span><br><span class="line"><span class="comment">//       4. 堆排序的复杂度为O(NlogN).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 堆排序的思想 (以从小到大排序说明）：</span></span><br><span class="line"><span class="comment">//       第一步：建立一个最大堆;</span></span><br><span class="line"><span class="comment">//       第二步：把首元素与最后一个元素进行交换;</span></span><br><span class="line"><span class="comment">//       第三步：把堆的大小减1,对新的堆进行维护维的性质;</span></span><br><span class="line"><span class="comment">//       第四步：把首元素与倒数第二个元素进行交换;</span></span><br><span class="line"><span class="comment">//       第五步：把堆的大小减1,对新的堆进行维护维的性质;</span></span><br><span class="line"><span class="comment">//       .......</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> nLength_, Comp CompFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">nullptr</span> || nLength_ &lt;= <span class="number">1</span> || CompFunc == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BulidHeap(<span class="built_in">array</span>, nLength_, CompFunc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nLength_; i &gt;= <span class="number">2</span>; <span class="comment">/* 循环内 */</span>)        <span class="comment">// i表示当前堆的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[--i]);</span><br><span class="line">        Heapify(<span class="built_in">array</span>, i, <span class="number">0</span>, CompFunc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************    测试     *****************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> nLength_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == <span class="built_in">array</span> || nLength_ &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength_; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1243</span>, <span class="number">0</span>, <span class="number">223</span>, <span class="number">443</span>, <span class="number">123</span>, <span class="number">-12</span>, <span class="number">-129</span> &#125;;</span><br><span class="line"></span><br><span class="line">    PrintArray(<span class="built_in">array</span>, <span class="number">10</span>);</span><br><span class="line">    HeapSort(<span class="built_in">array</span>, <span class="number">10</span>, greate);</span><br><span class="line">    PrintArray(<span class="built_in">array</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3><span id="手写单例模式">手写单例模式</span></h3><p>线程安全懒汉式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // shared_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;  // mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt; Ptr;</span><br><span class="line">    ~Singleton()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"destructor called!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Singleton(Singleton&amp;)=delete;</span></span><br><span class="line">    <span class="comment">//Singleton&amp; operator=(const Singleton&amp;)=delete;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Ptr <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "double checked lock"</span></span><br><span class="line">        <span class="keyword">if</span>(m_instance_ptr==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(m_mutex);</span><br><span class="line">            <span class="keyword">if</span>(m_instance_ptr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">              m_instance_ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructor called!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Ptr m_instance_ptr;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialization static variables out of class</span></span><br><span class="line">Singleton::Ptr Singleton::m_instance_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton::Ptr instance = Singleton::get_instance();</span><br><span class="line">    Singleton::Ptr instance2 = Singleton::get_instance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="三个线程交替打印">三个线程交替打印</span></h3><hr>
<h3><span id="海量数据问题">海量数据问题</span></h3><h4><span id="十亿整数随机生成可重复中前k最大的数">十亿整数（随机生成，可重复）中前K最大的数</span></h4><p>类似问题的解决方法思路：首先哈希将数据分成 <code>N</code> 个文件，然后对每个文件建立 <code>K</code> 个元素最小/大堆（根据要求来选择）。最后将文件中剩余的数插入堆中，并维持 <code>K</code> 个元素的堆。最后将 <code>N</code> 个堆中的元素合起来分析。可以采用归并的方式来合并。在归并的时候为了提高效率还需要建一个 <code>N</code> 个元素构成的最大堆，先用 <code>N</code> 个堆中的最大值填充这个堆，然后就是弹出最大值，指针后移的操作了。当然这种问题在现在的互联网技术中，一般就用 <code>map-reduce</code> 框架来做了。<br>大数据排序相同的思路：先哈希（哈希是好处是分布均匀，相同的数在同一个文件中），然后小文件装入内存快排，排序结果输出到文件。最后建堆归并。</p>
<h4><span id="十亿整数随机生成可重复中出现频率最高的一千个">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></h4><p>在大规模数据处理中，常遇到的一类问题是，在海量数据中找出出现频率最高的前K个数，或者从海量数据中找出最大的前K个数，这类问题通常称为<strong>top K</strong>问题，如：在搜索引擎中，统计搜索最热门的 <code>10</code>个查询词；在歌曲库中统计下载率最高的前10首歌等等。</p>
<p>针对 <strong>top k</strong>类问题，通常比较好的方案是<strong>分治+trie树/hash+小顶堆</strong>，即先将数据集按照 <code>hash</code> 方法分解成多个小数据集，然后使用 <code>trie</code> 树或者 <code>hash</code> 统计每个小数据集中的 <code>query</code> 词频，之后用小顶堆求出每个数据集中出频率最高的前 <code>K</code> 个数，最后在所有 <code>top K</code> 中求出最终的 <code>top K</code> 。</p>
<hr>
<h3><span id="布隆过滤器">布隆过滤器</span></h3><h4><span id="什么情况下需要布隆过滤器">什么情况下需要布隆过滤器？</span></h4><ul>
<li>字处理软件中，需要检查一个英语单词是否拼写正确</li>
<li>在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上</li>
<li>在网络爬虫里，一个网址是否被访问过</li>
<li>yahoo, gmail等邮箱垃圾邮件过滤功能</li>
<li>如果一个黑名单网站包含100亿个黑名单网页，每个网页最多占64B，设计一个系统，判断当前的URL是否在这个黑名单当中，要求额外空间不超过30GB，允许误差率为万分之一。这种情况，如果全都在内存中查询的话，需要的内存是640GB。</li>
</ul>
<h4><span id="布隆过滤器的原理">布隆过滤器的原理。</span></h4><p><strong>布隆过滤器</strong>(Bloom Filter)是由布隆(Burton Howard Bloom)在1970年提出的。它实际上是由<strong>一个很长的二进制向量和一系列随机映射函数</strong>组成。</p>
<p>布隆过滤器可以用于<strong>检索一个元素是否在一个集合</strong>中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p><img src="https://pic1.zhimg.com/80/v2-da022f1196cfbe2f439a21cd64208e10_720w.jpg" alt="img"></p>
<h4><span id="位图bitmap">位图(bitmap)</span></h4><p>布隆过滤器其中重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有1个 <code>bit</code> ，而每个 <code>bit</code> 只有 <code>0</code> 和 <code>1</code> 两种状态。如上图 <code>bit array</code> 所示。<code>bit array</code> 也叫 <code>bitmap</code> ，大小也就是布隆过滤器的大小。</p>
<p>假设我们有 <code>k</code> 个哈希函数，且每个哈希函数的输出范围都大于 <code>m</code> ，接着将输出值对 <code>k</code> 取余（%m）,就会得到 <code>k</code> 个 <code>[0, m-1]</code> 的值，由于每个哈希函数之间相互独立，因此这 <code>k</code> 个数也相互独立，最后将这 <code>k</code> 个数对应到<code>bitarray</code> 上并标记为 <code>1</code> 。</p>
<p>等到要判断某一个元素是否存在时，将输入对象经过这 <code>k</code> 个哈希函数计算得到 <code>k</code> 个值，然后判断对应 <code>bitarray</code> 的 <code>k</code> 个位置是否都为 <code>1</code> ，<strong>如果有一个不为1，那么这个输入对象则不在这个集合中；如果都是黑，那说明在集合中，但有可能会误判</strong>，由于当输入对象过多，而集合也就是 <code>bitarray</code> 过小，则会出现大部分为黑的情况，那样就容易发生误判！因此使用布隆过滤器是需要容忍错误率的，即使很低很低！</p>
<h4><span id="布隆过滤器大小计算">布隆过滤器大小计算</span></h4><p>假设输入对象个数为 <code>n</code> ，<code>bitarray</code> 大小（也就是布隆过滤器大小）为 <code>m</code> ，所容忍的误判率 <code>p</code> 和哈希函数的个数 <code>k</code> 。计算公式如下：（<strong>小数向上取整</strong>）</p>
<p><img src="https://pic1.zhimg.com/80/v2-fc1fb96508a363b17d1bb7737dc51e54_720w.jpg" alt="img"></p>
<p>假设一个网页黑名单有URL为100亿，每个样本为64B，失误率为0.01%，经过上述公式计算后，需要布隆过滤器大小为25GB，这远远小于使用哈希表的640GB的空间。</p>
<p>并且由于是通过 <code>hash</code> 进行查找的，所以基本都可以在 <code>O(1)</code> 的时间完成。</p>
<h4><span id="布隆过滤器可能出现误判怎么保证无误差">布隆过滤器可能出现误判，怎么保证无误差？</span></h4><hr>
<h3><span id="静态链接与动态链接">静态链接与动态链接</span></h3><hr>
<h3><span id="c抽象类和接口的区别">C++抽象类和接口的区别</span></h3><p>抽象类（Abstract Class）与接口（Interface）是面向对象程序设计中两个重要的概念。两者在自身特性及应用方法上存在诸多相似性，如都不能实例化、都可以被继承（严格来说对于接口应该叫做实现）等等。</p>
<p>在C++中，如果想定义一个接口，<strong>可以通过将一个类中所有函数定义为纯虚函数来做到</strong>。类似的，C++中也没有 <code>abstract</code> 关键字用于定义抽象类，而是<strong>如果一个类中至少含有一个纯虚函数且它的函数不全为纯虚函数，则这个类被称为抽象类。</strong></p>
<ol>
<li><p><strong>抽象类</strong></p>
<p>抽象类是特殊的类，只是不能被实例化，但是其中的方法可以包含具体实现代码。抽象类除此以外，具有类的其他特性，重要的是<strong>抽象类可以包括抽象方法</strong>，这是普通类所不能的。<strong>抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。</strong>另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们。</p>
</li>
<li><p><strong>接口</strong></p>
<p><strong>接口是一组方法声明的集合，</strong>其中应仅包含方法的声明，不能有任何实现代码。接口是引用类型的，类似于类和抽象类的相似之处有三点：</p>
<ol>
<li>不能实例化</li>
<li>包含未实现的方法声明</li>
<li>派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员(不仅是方法包括其他成员)  </li>
</ol>
</li>
</ol>
<hr>
<h3><span id="c-traits-萃取">C++ traits 萃取</span></h3><p><a href="https://www.cnblogs.com/pugang/archive/2012/10/17/2727378.html" target="_blank" rel="noopener">https://www.cnblogs.com/pugang/archive/2012/10/17/2727378.html</a></p>
<p><a href="https://blog.csdn.net/u012442719/article/details/50827771" target="_blank" rel="noopener">https://blog.csdn.net/u012442719/article/details/50827771</a></p>
<p><a href="https://light-city.club/sc/src_analysis/stl/traits/" target="_blank" rel="noopener">https://light-city.club/sc/src_analysis/stl/traits/</a></p>
<p><strong>traits</strong>相当于一个类型推断技术，用来获取类型信息的。本质定义是加上一层间接性，换来以定的灵活性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span> &#123;</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> value = <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void&gt; &#123;</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> value = <span class="literal">true</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;is_void&lt;<span class="keyword">int</span>&gt;::value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;is_void&lt;<span class="keyword">void</span>&gt;::value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="区别以下指针类型">区别以下指针类型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">10</span>]</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>]</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>int *p[10]</strong>表示<strong>指针数组</strong>，强调数组概念，是一个数组变量，数组大小为 <code>10</code> ，数组内每个元素都是指向 <code>int</code> 类型的指针变量。</li>
<li><strong>int (*p)[10]</strong>表示<strong>数组指针</strong>，强调是指针，只有一个变量，是指针类型，不过指向的是一个 <code>int</code> 类型的数组，这个数组大小是 <code>10</code> 。</li>
<li><strong>int *p(int)</strong>是<strong>函数声明</strong>，函数名是 <code>p</code> ，参数是 <code>int</code> 类型的，返回值是 <code>int *</code> 类型的。</li>
<li><strong>int (*p)(int)</strong>是<strong>函数指针</strong>，强调是指针，该指针指向的函数具有 <code>int</code> 类型参数，并且返回值是 <code>int</code> 类型的。</li>
</ul>
<hr>
<h3><span id="变量声明和定义的区别">变量声明和定义的区别</span></h3><ul>
<li>声明仅仅是把<strong>变量的声明的位置及类型</strong>提供给编译器，<strong>并不分配内存空间</strong>；<strong>定义要在定义的地方为其分配存储空间。</strong></li>
<li>相同变量<strong>可以在多处声明（外部变量extern），但只能在一处定义。</strong></li>
</ul>
<hr>
<h3><span id="如何用代码判断大小端存储">如何用代码判断大小端存储</span></h3><ul>
<li><strong>大端存储</strong>：字数据的高字节存储在低地址中</li>
<li><strong>小端存储</strong>：字数据的低字节存储在低地址中</li>
</ul>
<p>对于32bit的数字<strong>0x12345678</strong></p>
<p><strong>小端：</strong></p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000</th>
<th>0x4001</th>
<th>0x4002</th>
<th>0x4003</th>
</tr>
</thead>
<tbody>
<tr>
<td>存放内容</td>
<td>0x12</td>
<td>0x34</td>
<td>0x56</td>
<td>0x78</td>
</tr>
</tbody>
</table>
<p><strong>大端：</strong></p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000</th>
<th>0x4001</th>
<th>0x4002</th>
<th>0x4003</th>
</tr>
</thead>
<tbody>
<tr>
<td>存放内容</td>
<td>0x78</td>
<td>0x56</td>
<td>0x34</td>
<td>0x12</td>
</tr>
</tbody>
</table>
<h4><span id="强制类型转换判断法">强制类型转换判断法</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span></span><br><span class="line">    <span class="keyword">char</span> c = (<span class="keyword">char</span>)(a);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x12</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"big endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">0x34</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"little endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="union判断法">Union判断法</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> endian &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//a和ch共用4字节的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (value.ch == <span class="number">0x12</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"big endian"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value.ch == <span class="number">0x34</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"little endian"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="strlen和sizeof区别">strlen和sizeof区别</span></h4><ul>
<li><code>sizeof</code> 是<strong>运算符</strong>，并不是函数，<strong>结果在编译时得到而非运行中获得</strong>；<code>strlen</code> 是字符处理的<strong>库函数</strong>。</li>
<li><code>sizeof</code> 参数<strong>可以是任何数据的类型或者数据</strong>（<code>sizeof</code> 参数不退化）；<code>strlen</code> 的参数<strong>只能是字符指针且结尾是’\0’的字符串</strong>。</li>
<li>因为 <code>sizeof</code> 值在编译时确定，所以<strong>不能用来得到动态分配</strong>（运行时分配）存储空间的大小。</li>
</ul>
<hr>
<h4><span id="数组名和指向数组首元素的指针的区别">数组名和指向数组首元素的指针的区别</span></h4><ul>
<li>二者均可通过<strong>增减偏移量来访问数组中的元素</strong>。</li>
<li>数组名不是真正意义上的指针，可以理解为<strong>常指针</strong>，所以<strong>数组名没有自增、自减等操作</strong>。</li>
<li>当数组名当做形参传递给调用函数后，就失去了原有特性，<strong>退化成一般指针</strong>，多了自增、自减操作，但 <code>sizeof</code> 运算符不能再得到原数组的大小了。</li>
</ul>
<h2><span id="stl">STL</span></h2><h3><span id="stl六大部件">STL六大部件</span></h3><ul>
<li><p><strong>容器(Containers)</strong></p>
<ul>
<li><p><strong>顺序容器</strong></p>
<ul>
<li><p><strong>Array 数组</strong></p>
</li>
<li><p><strong>Vector 数组</strong>：线性连续空间</p>
</li>
<li><p><strong>Deque 双端队列</strong>：<code>deque</code> 是分段连续线性空间，随时可以增加一段新的空间</p>
</li>
<li><p><strong>List 双向链表</strong></p>
</li>
<li><p><strong>Forward List 单向链表</strong></p>
<p><strong>注：这里面没有stack和queue是因为stack和queue本质上底层是用Deque+list实现的，属于配接器。</strong></p>
</li>
</ul>
</li>
<li><p><strong>关联容器</strong></p>
<ul>
<li><strong>Set/Multiset 集合(红黑树)</strong></li>
<li><strong>Map/Multimap 哈希(红黑树)</strong></li>
</ul>
</li>
<li><p><strong>无序容器</strong>(本质上属于关联容器)</p>
<ul>
<li><strong>Unordered_set/Multiset 无序集合(哈希表)</strong></li>
<li><strong>Unordered_map/Multimap 无序哈希(哈希表)</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分配器(Allocators)</strong></p>
<ul>
<li>实现了动态空间配置、空间管理、空间释放的 <code>class template</code> </li>
</ul>
</li>
<li><p><strong>算法(Algorithms)</strong></p>
<ul>
<li>各种常用算法如 <code>sort</code> , <code>search</code> , <code>copy</code> , <code>erase</code> 等等</li>
<li><strong>从语言层面来讲，STL的六大组件，其他的都是类模板（class template），只有算法属于函数模板（function template）</strong></li>
<li><strong>从功能流程上来说：算法是看不见容器的，它对容器一无所知，只能通过迭代器来获得所有需要的信息；迭代器需要能够回答算法的所有需求，这样才能实现算法的功能；</strong></li>
</ul>
</li>
<li><p><strong>迭代器(Iterators)</strong></p>
<ul>
<li>扮演容器和算法之间的胶合剂，相当于 <code>泛型指针</code> ，可以迭代取出容器内的元素。重载了operator <code>*</code> , <code>-&gt;</code> , <code>.</code> , <code>++</code> , <code>--</code> 等等</li>
</ul>
</li>
<li><p><strong>配接器(Adapters)</strong></p>
<ul>
<li>一种用来修饰容器(containers)或仿函数(functors)或者迭代器(iterators)接口的东西</li>
</ul>
</li>
<li><p><strong>仿函数(Functors)</strong></p>
<ul>
<li>行为类似函数，是一种重载了 <code>operator()</code> 的 <code>class</code> 或者 <code>class template</code> ，一般函数指针可以视为狭义的仿函数。</li>
</ul>
</li>
</ul>
<hr>
<h3><span id="hash-map冲突如何解决">Hash Map冲突如何解决？</span></h3><p>哈希表（Hash table，也叫散列表）， 是根据关键码值( <code>Key value</code> )而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>哈希表的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p><strong>直接定址</strong>与<strong>解决冲突</strong>是哈希表的两大特点。</p>
<h5><span id="哈希函数">哈希函数</span></h5><ol>
<li><strong>直接定制法</strong>：哈希函数为关键字的线性函数如  $H(key)=a\times key+b$</li>
<li><strong>数字分析法</strong>：此种方法通常用于数字位数较长的情况，必须数字存在一定规律，其必须知道数字的分布情况</li>
<li><strong>平方取中法</strong>：如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。这种方法适合<strong>事先不知道数据并且数据长度较小的情况</strong></li>
<li><strong>折叠法</strong>：如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为 <code>hash</code> 地址。</li>
<li><strong>除留余数法</strong>：<code>H(key)=key MOD p</code> (p&lt;=m m为表长) <code>p</code> 应为不大于 <code>m</code> 的质数或是不含 <code>20</code> 以下的质因子的合数，这样可以减少地址的重复(冲突)。</li>
</ol>
<h5><span id="哈希冲突解决方案">哈希冲突解决方案</span></h5><ol>
<li><p><strong>开放定制法</strong></p>
<p>对于哈希函数 <code>H(key)</code> ，如果 $key_1$ 和 $key_i$ 哈希冲突，那么 $key_i$ 存储的位置为 $H_i=(H(key)+d_i)mod (m)$</p>
<ol>
<li><p><strong>线性探测再散列</strong>：$d_i=c∗i$</p>
<p>例如可以取 $d_i=1$，即冲突后存储在冲突后一个位置，如果仍然冲突继续向后线性探测。</p>
</li>
<li><p><strong>平方探测再散列</strong>：$d_i=1^2,-1^2,2^2,-2^2……$</p>
</li>
<li><p>随机探测再散列(双探测再散列)：$d_i$ 是一组伪随机数列</p>
</li>
</ol>
</li>
<li><p><strong>链地址法</strong></p>
<p>产生 <code>hash</code> 冲突后在存储数据后面加一个指针，指向后面冲突的数据(链地址法是可以直接删除元素的)</p>
<p><img src="https://img-blog.csdn.net/20180520012305597" alt="这里写图片描述"></p>
</li>
<li><p><strong>公共溢出区法</strong><br>建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。</p>
</li>
<li><p><strong>再散列法(rehash)</strong></p>
<p>准备若干个 <code>hash</code> 函数，如果使用第一个 <code>hash</code> 函数发生了冲突，就使用第二个 <code>hash</code> 函数，第二个也冲突，使用第三个……</p>
</li>
</ol>
<hr>
<h3><span id="hash_map扩容发生什么">Hash_map扩容发生什么</span></h3><ol>
<li>创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到<em>sqrt</em>(<em>n</em>)范围内的数)  </li>
<li>将原来桶里的数通过<strong>指针的转换</strong>，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换)</li>
<li>通过swap函数将新桶和旧桶交换，销毁新桶</li>
</ol>
<blockquote>
<p>代码</p>
</blockquote>
<p>当发生哈希冲突时，返回一个不小于n的素数来作为下一个桶(unordered_map的默认桶数为10。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">inline</span> <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line">_Prime_rehash_policy::</span><br><span class="line">_M_next_bkt(<span class="built_in">std</span>::<span class="keyword">size_t</span> __n) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* __p = <span class="built_in">std</span>::lower_bound(__prime_list, __prime_list + _S_n_primes, __n);</span><br><span class="line">    _M_next_resize = </span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(__builtin_ceil(*__p * _M_max_load_factor));</span><br><span class="line"><span class="keyword">return</span> *__p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>prime_list</code> 用l <code>lower_bound</code> 来找到第一个大于等于给定值 <code>n</code> 的素数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __prime_list[] = <span class="comment">// 256 + 1 or 256 + 48 + 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="number">2u</span>l, <span class="number">3u</span>l, <span class="number">5u</span>l, <span class="number">7u</span>l, <span class="number">11u</span>l, <span class="number">13u</span>l, <span class="number">17u</span>l, <span class="number">19u</span>l, <span class="number">23u</span>l, <span class="number">29u</span>l, <span class="number">31u</span>l,</span><br><span class="line">    <span class="number">37u</span>l, <span class="number">41u</span>l, <span class="number">43u</span>l, <span class="number">47u</span>l, <span class="number">53u</span>l, <span class="number">59u</span>l, <span class="number">61u</span>l, <span class="number">67u</span>l, <span class="number">71u</span>l, <span class="number">73u</span>l, <span class="number">79u</span>l,</span><br><span class="line">    <span class="number">83u</span>l, <span class="number">89u</span>l, <span class="number">97u</span>l, <span class="number">103u</span>l, <span class="number">109u</span>l, <span class="number">113u</span>l, <span class="number">127u</span>l, <span class="number">137u</span>l, <span class="number">139u</span>l, <span class="number">149u</span>l，</span><br><span class="line">    <span class="comment">// 后面还有很多</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>哈希表的内部结构为<strong>在每个元素中维护一个单链表</strong>, 然后在单链表上执行元素的<strong>插入</strong>、<strong>搜寻</strong>、<strong>删除</strong>等操作，每个元素被称为<strong>桶(bucket)</strong>，底层构建先采用 <code>H1</code> 计算出 <code>key</code> 的 <code>hash code</code> ，再通过除留余数法 <code>H2</code> 得到其对应的桶。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value, <span class="keyword">typename</span> _Alloc,</span><br><span class="line">    <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,</span><br><span class="line">    <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash,</span><br><span class="line">    <span class="keyword">typename</span> _RehashPolicy, <span class="keyword">typename</span> _Traits&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Hashtable</span></span></span><br><span class="line"><span class="class"><span class="title">private</span>:</span></span><br><span class="line">    __bucket_type*      _M_buckets;  <span class="comment">//_ Hash_node_base *</span></span><br><span class="line">    size_type           _M_bucket_count;    <span class="comment">// bucket 节点个数</span></span><br><span class="line">    __node_base     _M_before_begin;    <span class="comment">// _NodeAlloc::value_type</span></span><br><span class="line">    size_type           _M_element_count;   <span class="comment">// //hashtable中list节点个数</span></span><br><span class="line">    _RehashPolicy       _M_rehash_policy;  <span class="comment">// rehash策略</span></span><br><span class="line">    __bucket_type       _M_single_bucket;  <span class="comment">// 只需要一个桶用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="unordered_map和map底层实现有什么区别">Unordered_map和map底层实现有什么区别？</span></h3><p><code>HashSet(unordered_set)</code> 和 <code>HashMap(unordered_map)</code> 都是以 <code>hashtable</code> 作为底层机制，提供与 <code>set</code> 和<code>map</code> 完全相同的操作，但是 <code>Hash</code> 版本的容器不提供自动排序的功能，非 <code>Hash</code> 的版本是以 <code>RB-tree</code> 作为底层机制，也就提供排序的能力。总体来说，<code>hash_map</code> 查找速度会比 <code>map</code> 快，而且查找速度基本和数据数据量大小，属于常数级别；而 <code>map</code> 的查找速度是 <code>log(n)</code> 级别。</p>
<h4><span id="map与unordered_map的区别">map与unordered_map的区别</span></h4><p>他们俩存储时是根据 <code>key</code> 的 <code>hash</code> 值判断元素是否相同，而 <code>unordered_map</code> 内部元素是无序的，<code>map</code> 中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时 <code>map</code> 的 <code>key</code> 需要定义<code>operator&lt;</code>。而 <code>unordered_map</code> 需要定义 <code>hash_value</code> 函数并且重载 <code>operator==</code> 。但是很多系统内置的数据类型都自带这些。总结： <code>map</code> 重载 <code>&lt;</code> 运算符，<code>unordered_map</code> 重载 <code>==</code> 运算符。</p>
<p><strong>set/map</strong>底层实现的机制是<strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，默认是按升序排序的。在红黑树上做查找、插入、删除操作的时间复杂度为 <code>O(logN)</code> 。(<strong>比较稳定</strong>)</p>
<p><strong>红黑树的缺点</strong>：空间占用率高，每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</p>
<p><strong>std::unordered_map</strong>对应哈希表，哈希表的特点就是<strong>查找效率高</strong>，时间复杂度为常数级别<strong>O(1)</strong>，而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 <code>std::unordered_map</code> 容器。而如果对<strong>内存大小比较敏感</strong>或者<strong>数据存储要求有序</strong>的话，则可以用 <code>std::map</code> 容器。</p>
<h4><span id="为什么用红黑树红黑树查询效率为什么快">为什么用红黑树？红黑树查询效率为什么快？</span></h4><p>红黑树不仅是作为 <code>AVL</code> 的工程版本，在增加节点颜色、不严格平滑等特性实现了更高效的插入和删除。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。<strong>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种弱平衡二叉树，相对于要求严格的 <code>AVL</code> 树来说，它的<strong>旋转次数少</strong>，所以对于<strong>搜索，插入，删除操作较多的情况</strong>下，通常使用红黑树。<code>AVL</code> 树是高度平衡的，频繁的插入和删除，会引起频繁的 <code>rebalance</code> ，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多<strong>两次</strong>旋转，删除最多<strong>三次</strong>旋转。</p>
<p>红黑树满足以下特征：</p>
<ol>
<li><strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</strong></li>
<li><strong>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;=2bd</strong></li>
<li><strong>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;=2log(n+1)</strong></li>
</ol>
<hr>
<h3><span id="为何map和set的插入删除效率比用其他序列容器高">为何map和set的插入删除效率比用其他序列容器高？</span></h3><p>对于<strong>关联容器</strong>来说，不需要做内存拷贝和内存移动。说对了，确实如此。<code>map</code> 和 <code>set</code> 容器内所有元素都是以红黑树节点（如下）的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line">  /  \</span><br><span class="line"> B    C</span><br><span class="line">/ \  /  \</span><br><span class="line">D E  F  G</span><br></pre></td></tr></table></figure>
<p>因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点就OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p>
<h4><span id="为什么每次insert之后以前保存的iterator不会失效">为什么每次insert之后，以前保存的iterator不会失效</span></h4><p><code>iterator</code> 这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于 <code>vector</code> 来说，每一次删除和插入，指针都有可能失效，调用 <code>push_back</code> 在尾部插入也是如此。因为为了保证内部数据的连续存放，<code>iterator</code> 指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时 <code>push_back</code> 的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。</p>
<hr>
<h3><span id="vector相关">vector相关</span></h3><h4><span id="vector空间的动态增长">vector空间的动态增长</span></h4><h4><span id="vector底层数据结构vector底层是如何删除元素">vector底层数据结构，vector底层是如何删除元素</span></h4><h4><span id="push_back时间复杂度">push_back()时间复杂度</span></h4><p><a href="https://www.cnblogs.com/youxam/p/vector.html" target="_blank" rel="noopener">https://www.cnblogs.com/youxam/p/vector.html</a></p>
<p>对于 <code>std::vector</code> 的 <code>push_back</code> 函数， <a href="https://www.cnblogs.com/youxam/p/cplusplus.com" target="_blank" rel="noopener">cplusplus.com</a> 上的复杂度解释如下:</p>
<blockquote>
<p>Constant (amortized time, reallocation may happen).<br>常数 (均摊时间， 可能发生重新分配)</p>
</blockquote>
<p>它的原理想必大家都知道， 当大小达到容量之后， 为了保证内存的连续性， 就会再开一个新的<strong>capacity</strong>为之前的二倍大的内存块， 把之前的复制过去。每次复制时间复杂度为 <code>O(n)</code> , 直觉上， 每次 <code>push_back</code> 的时间复杂度不太像 <code>O(1)</code> , 但由于只有很少的情况下才会复制， 所以均摊时间确实很快。</p>
<p>测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e5</span>; i++) &#123;</span><br><span class="line">		v.push_back(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (last != (<span class="keyword">int</span>)v.capacity()) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.capacity() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			last = v.capacity();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072</span><br></pre></td></tr></table></figure>
<p> 当执行 <strong>push_back</strong> 操作，该 <strong>vector</strong> 需要分配更多空间时，它的容量(<strong>capacity</strong>)会增大到原来的 <strong>m</strong> 倍。现在我们来<strong>均摊分析方法</strong>来计算 <strong>push_back</strong> 操作的时间复杂度。</p>
<p>​    假定有 <strong>n</strong> 个元素,倍增因子为 <strong>m。</strong>那么完成这 <strong>n</strong> 个元素往一个 <strong>vector</strong> 中的 <strong>push_back</strong>操作，需要重新分配内存的次数大约为 <strong>logm(n)</strong>，第 <strong>i</strong> 次重新分配将会导致复制 <strong>m^i</strong> (也就是当前的<strong>vector.size()</strong> 大小)个旧空间中元素，因此 <strong>n</strong> 次 <strong>push_back</strong> 操作所花费的总时间约为 <strong>n*m/(m - 1)</strong>：</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613806083822.png" alt="1613806083822"></p>
<p>  很明显这是一个等比数列，那么 <strong>n</strong> 个元素，<strong>n</strong> 次操作，每一次操作需要花费时间为 <strong>m / (m - 1)</strong>，在 <code>STL</code> 中 <strong>m</strong> 为 <code>2</code> ，所以摊还时间复杂度是 <code>O(2)</code> </p>
<hr>
<h4><span id="push_back与emplace_back的区别">push_back与emplace_back的区别</span></h4><p><strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造</strong>，效率更高。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//初始构造函数</span></span><br><span class="line">    Person(<span class="built_in">string</span> p_name, <span class="keyword">int</span> p_age): name(<span class="built_in">std</span>::move(p_name)), age(p_age) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"I have been constructed"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//拷贝构造函数</span></span><br><span class="line">     Person(<span class="keyword">const</span> Person&amp; other): name(<span class="built_in">std</span>::move(other.name)), age(other.age) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"I have been copy constructed"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//转移构造函数</span></span><br><span class="line">     Person(Person&amp;&amp; other): name(<span class="built_in">std</span>::move(other.name)), age(other.age) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"I have been moved"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    e.emplace_back(<span class="string">"Jane"</span>, <span class="number">23</span>); <span class="comment">//不用构造类对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p.push_back(Person(<span class="string">"Mike"</span>,<span class="number">36</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//emplace_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//push_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//I am being moved.</span></span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="stl里的内存池实现">STL里的内存池实现</span></h3><p>首先我们需要明确, 内存池的目的到底是什么?我们每次使用 <code>new T</code> 来初始化类型 <code>T</code> 的时候, 其实发生了<strong>两步</strong>操作：</p>
<p> 第一步是<strong>内存分配</strong>， 这一步使用的其实不是 <code>new</code> 而是 <code>operator new</code> (也可以认为就是C语言中的 <code>malloc</code> )，这一步是直接和操作系统打交道的，操作系统可能需要经过相对繁琐的过程才能将一块指向空闲内存的指针返回给用户，所以这也是 <code>new</code> 比较耗时的一部分。</p>
<p>第二步是<strong>使用构造函数初始化该内存</strong>，这是我们比较熟悉。既然内存分配耗时。那我们很容易想到的就是一次性分配一大块内存，然后在用户需要的时候再划分其中一部分给用户。这样<strong>一次分配，多次使用</strong>， 自然而然提高了效率。而用来<strong>管理这所谓的一大块内存的数据结构</strong>，也就是今天我们要说的<strong>内存池</strong>。另外一个好处在于，频繁地使用 <code>new</code> 将导致系统内存空间碎片化严重，容易导致的后果就是很难找到一块连续的大块内存，空间利用率低。</p>
<p><code>STL</code> 内存分配分为<strong>一级分配器</strong>和<strong>二级分配器</strong>，一级分配器就是采用<strong>malloc分配内存</strong>，二级分配器采用<strong>内存池</strong>。</p>
<p>第二级配置器目的解决小型区块造成的内存碎片问题。</p>
<p>二级分配器设计的非常巧妙，分别给 <code>8byte</code> ，<code>16byte</code> ,…, <code>128byte</code> 等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块 <code>10K</code> 的内存，那么就找到最小的大于等于 <code>10byte</code> 的块，也就是 <code>16byte</code> ，从 <code>16byte</code> 的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。如果要分配的内存大于 <code>128byte</code> 则直接调用一级分配器。为了节省维持链表的开销，内存池采用了一个 <code>union</code> 结构体，分配器使用 <code>union</code> 里的 <code>next</code> 指针来指向下一个节点，而用户则使用 <code>union</code> 的空指针来表示该节点的地址。</p>
<p>使用<strong>自由链表(free-list)技巧</strong>。主动将不论什么小额区块的内存需求量上调至 <code>8</code> 的倍数。如需求 <code>30</code> ，则上调至<code>32</code> 。内存池可以认为由上面的一个<strong>指针数组</strong>和下面的<strong>自由链表</strong>两部分组成, 指针数组中第一个指针指向的是存放内存大小为 <code>8bytes</code> 的节点串接而成的自由链表, 之后依次是内存 <code>16bytes</code> , <code>24bytes</code> 直到 <code>128bytes</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Align = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MaxBytes = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfFreeLists = MaxBytes / Align;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfAddedNodesForEachTime = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span> MemNode &#123;</span><br><span class="line">		MemNode*	_next;</span><br><span class="line">		<span class="keyword">char</span>		_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> obj *freeLists[NumberOfFreeLists];</span><br></pre></td></tr></table></figure>
<p><code>union</code> 每个成员的起始地址都是开头的位置，所以每次仅能使用一个成员，在链表中由<code>_next</code> 指向下个内存块的地址，在分配内存时由 <code>_data</code> 指向内存首地址，长度为1 的数组放在结构体最后一个成员位置，可以访问给结构体多分配的地址空间，这种技术叫做<strong>柔性数组</strong>。这样做的好处减少了对内存块管理时额外的内存损耗。想想我们学习数据结构时实现的链表，都是通过结构体的一个成员来指向下个节点的地址，多出了一个指针 <code>4Byte</code> 的内存消耗。参考 <code>STL</code> ，内存块的管理如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20180513143317500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Nzg3MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="内存块示意图"></p>
<h4><span id="内存的分配和回收">内存的分配和回收</span></h4><p><img src="https://img-blog.csdn.net/20140904101111437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20140904101133171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2VnZW5famFh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>每次从系统申请内存时都通过一个辅助函数将内存增到为 <code>8</code> 的倍数，上层请求内存时寻找最小能容纳当前请求的头节点索引；当找到索引位置时，如果内存块不为空，则取出当前内存块，将之后的链表节点向前移动，如果内存不够的话，再次向系统请求新的内存。内存回收时与此理相同，通过辅助函数找到索引位置，将内存块放入首部位置，之前的内存块后移。</p>
<hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/19/316. 去除重复字母/" rel="next" title="Leetcode_316 去除重复字母">
                <i class="fa fa-chevron-left"></i> Leetcode_316 去除重复字母
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/24/操作系统总结/" rel="prev" title="操作系统总结">
                操作系统总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">345</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">C++线程中的几种锁/互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.</span> <span class="nav-text">互斥锁(Mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.</span> <span class="nav-text">条件变量(condition_variable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.</span> <span class="nav-text">自旋锁(spinlock_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.</span> <span class="nav-text">读写锁(shared_mutex)/共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.</span> <span class="nav-text">递归锁(recursive_mutex)/可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.</span> <span class="nav-text">定时锁(time_mutex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.</span> <span class="nav-text">两种基本的锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">条件变量中只能使用unique_lock&lt; std::mutex &gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">RAII/资源获取即初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.</span> <span class="nav-text">C++中原子操作/CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">GCC4.1+</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">C++11</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.</span> <span class="nav-text">C++中thread操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.1.</span> <span class="nav-text">std::thread构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.2.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.3.</span> <span class="nav-text">detach()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.4.</span> <span class="nav-text">wait()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.5.</span> <span class="nav-text">wait_for()成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.6.</span> <span class="nav-text">notify_all/notify_one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.7.</span> <span class="nav-text">虚假唤醒</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.</span> <span class="nav-text">面向对象的三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.</span> <span class="nav-text">C++11新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.</span> <span class="nav-text">⭐C++模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.1.</span> <span class="nav-text">模板类存放位置(.h)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.2.</span> <span class="nav-text">模板类是什么时候实例化的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.3.</span> <span class="nav-text">模板代码class声明和定义能够写在不同的文件吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.4.</span> <span class="nav-text">模板类中能够使用虚函数吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.5.</span> <span class="nav-text">模板函数和模板类的特例化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">引入原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.6.</span> <span class="nav-text">类模板和模板类的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.</span> <span class="nav-text">⭐C++多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.1.</span> <span class="nav-text">多态有哪几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.2.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">虚表指针的初始化时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.3.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.4.</span> <span class="nav-text">虚继承与虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">虚继承要解决的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.5.</span> <span class="nav-text">⭐为什么析构函数必须是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.6.</span> <span class="nav-text">为什么C++默认的析构函数不是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.7.</span> <span class="nav-text">为什么构造函数不能是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.8.</span> <span class="nav-text">静态成员及静态成员函数能不能被继承？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.9.</span> <span class="nav-text">友元可以继承吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.10.</span> <span class="nav-text">虚函数(virtual)可以是内联函数(inline)吗？(当虚函数表现多态性的时候不能内联)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.11.</span> <span class="nav-text">多态中构造函数/析构函数调用顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.12.</span> <span class="nav-text">类成员函数中重载/重写/隐藏的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.13.</span> <span class="nav-text">钻石继承问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.9.</span> <span class="nav-text">C++的四种构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.9.1.</span> <span class="nav-text">拷贝构造函数和赋值运算符重载的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.</span> <span class="nav-text">C++的四种cast</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.2.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.3.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.4.</span> <span class="nav-text">⭐dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.5.</span> <span class="nav-text">哪种cast更加接近C的强制类型转换？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.</span> <span class="nav-text">C++智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.1.</span> <span class="nav-text">auto_ptr(弃用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.2.</span> <span class="nav-text">unique_ptr(替换auto_ptr)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.3.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.4.</span> <span class="nav-text">weak_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.4.1.</span> <span class="nav-text">weak_ptr是用来解决shared_ptr相互引用时的死锁问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.4.2.</span> <span class="nav-text">weak_ptr是不保证内存有效的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.4.3.</span> <span class="nav-text">如何判断weak_ptr的对象是否失效？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.5.</span> <span class="nav-text">智能指针原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.6.</span> <span class="nav-text">智能指针是线程安全的吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.</span> <span class="nav-text">C++this指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.</span> <span class="nav-text">C++对象的内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.1.</span> <span class="nav-text">普通对象模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">类的对象存储空间大小</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.2.</span> <span class="nav-text">派生类的对象模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">派生类构造函数执行顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.3.</span> <span class="nav-text">vtable中虚函数指针的排列顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.4.</span> <span class="nav-text">空类/含有虚函数的类的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.4.1.</span> <span class="nav-text">为何空类的大小不是0呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.4.2.</span> <span class="nav-text">继承关系中的类大小</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.</span> <span class="nav-text">C++内存分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.</span> <span class="nav-text">C++中指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.</span> <span class="nav-text">C++中new与malloc的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.1.</span> <span class="nav-text">new/delete是如何实现的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.2.</span> <span class="nav-text">malloc/free是如何实现的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.3.</span> <span class="nav-text">delete和delete[]区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.4.</span> <span class="nav-text">malloc/calloc/realloc函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.4.1.</span> <span class="nav-text">malloc函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.4.2.</span> <span class="nav-text">calloc函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.4.3.</span> <span class="nav-text">realloc函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.17.</span> <span class="nav-text">C++ 内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.18.</span> <span class="nav-text">C++存储类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.18.1.</span> <span class="nav-text">auto 自动变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.18.2.</span> <span class="nav-text">register 寄存器变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.18.3.</span> <span class="nav-text">extern关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.18.4.</span> <span class="nav-text">thread_local 存储类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.</span> <span class="nav-text">static 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.1.</span> <span class="nav-text">隐藏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.2.</span> <span class="nav-text">持久：static变量中的记忆功能和全局生存期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.3.</span> <span class="nav-text">static成员函数不能被virtual修饰</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.</span> <span class="nav-text">const常量/const函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.1.</span> <span class="nav-text">const常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.2.</span> <span class="nav-text">const函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.3.</span> <span class="nav-text">const对象：只能调用const成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.4.</span> <span class="nav-text">const形参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.</span> <span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.22.</span> <span class="nav-text">C++运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.</span> <span class="nav-text">C++中NULL和nullptr的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.</span> <span class="nav-text">C/C++源程序到可执行程序exe的全过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.1.</span> <span class="nav-text">1. 预处理(生成test.i)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.2.</span> <span class="nav-text">2. 编译(生成test.s)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.3.</span> <span class="nav-text">3. 汇编(生成test.o)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.4.</span> <span class="nav-text">4. 链接(生成默认a.out)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.4.1.</span> <span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.4.2.</span> <span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.4.3.</span> <span class="nav-text">目标文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.</span> <span class="nav-text">右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.3.</span> <span class="nav-text">右值引用有办法指向左值吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.4.</span> <span class="nav-text">完美转发 std::forward()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.5.</span> <span class="nav-text">auto&amp;&amp;也是这个意思</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.</span> <span class="nav-text">C++内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.1.</span> <span class="nav-text">内联函数有什么优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.2.</span> <span class="nav-text">内联函数适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.4.</span> <span class="nav-text">构造函数、析构函数、虚函数可否声明为内联函数？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.4.1.</span> <span class="nav-text">构造函数和析构函数声明为内联函数是没有意义的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.4.2.</span> <span class="nav-text">将虚函数声明为inline，要分情况讨论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.5.</span> <span class="nav-text">将内联函数放入头文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.</span> <span class="nav-text">宏定义#Define</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.1.</span> <span class="nav-text">宏定义和函数区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.2.</span> <span class="nav-text">宏定义和typedef区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.3.</span> <span class="nav-text">宏定义与内联函数的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.4.</span> <span class="nav-text">宏定义和const的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.4.1.</span> <span class="nav-text">编译阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.4.2.</span> <span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.4.3.</span> <span class="nav-text">内存占用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.28.</span> <span class="nav-text">C++11类型说明符auto/decltype/decltype(auto)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.28.1.</span> <span class="nav-text">auto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.28.2.</span> <span class="nav-text">decltype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.28.3.</span> <span class="nav-text">decltype(auto)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.</span> <span class="nav-text">Volitale/mutable/explicit关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.1.</span> <span class="nav-text">Volitale关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.1.1.</span> <span class="nav-text">volatile指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.1.2.</span> <span class="nav-text">可见性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.2.</span> <span class="nav-text">mutable 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.3.</span> <span class="nav-text">explicit关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.30.</span> <span class="nav-text">union 联合体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.</span> <span class="nav-text">final/override关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.0.1.</span> <span class="nav-text">override</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.0.2.</span> <span class="nav-text">final(继承的终点)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.32.</span> <span class="nav-text">深拷贝与浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.32.1.</span> <span class="nav-text">深拷贝与浅拷贝的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.33.</span> <span class="nav-text">拷贝初始化和直接初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.34.</span> <span class="nav-text">必须在构造函数初始化列表里进行初始化的数据成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.34.1.</span> <span class="nav-text">成员初始化列表做了什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.34.2.</span> <span class="nav-text">赋值初始化与列表初始化的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.35.</span> <span class="nav-text">定位内存泄露及检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.36.</span> <span class="nav-text">C++函数调用的压栈过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.37.</span> <span class="nav-text">手写strcpy，memcpy，strcat，strcmp等函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.37.1.</span> <span class="nav-text">strcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.37.2.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.37.3.</span> <span class="nav-text">strlen</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.37.4.</span> <span class="nav-text">strcat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.37.5.</span> <span class="nav-text">strcmp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.37.6.</span> <span class="nav-text">memmove</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.38.</span> <span class="nav-text">⭐C++实现堆排序(原地算法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.39.</span> <span class="nav-text">手写单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.40.</span> <span class="nav-text">三个线程交替打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.41.</span> <span class="nav-text">海量数据问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.41.1.</span> <span class="nav-text">十亿整数（随机生成，可重复）中前K最大的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.41.2.</span> <span class="nav-text">十亿整数（随机生成，可重复）中出现频率最高的一千个</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.42.</span> <span class="nav-text">布隆过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.42.1.</span> <span class="nav-text">什么情况下需要布隆过滤器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.42.2.</span> <span class="nav-text">布隆过滤器的原理。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.42.3.</span> <span class="nav-text">位图(bitmap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.42.4.</span> <span class="nav-text">布隆过滤器大小计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.42.5.</span> <span class="nav-text">布隆过滤器可能出现误判，怎么保证无误差？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.43.</span> <span class="nav-text">静态链接与动态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.44.</span> <span class="nav-text">C++抽象类和接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.45.</span> <span class="nav-text">C++ traits 萃取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.46.</span> <span class="nav-text">区别以下指针类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.47.</span> <span class="nav-text">变量声明和定义的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.48.</span> <span class="nav-text">如何用代码判断大小端存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.48.1.</span> <span class="nav-text">强制类型转换判断法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.48.2.</span> <span class="nav-text">Union判断法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.48.3.</span> <span class="nav-text">strlen和sizeof区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.48.4.</span> <span class="nav-text">数组名和指向数组首元素的指针的区别</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.1.</span> <span class="nav-text">STL六大部件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.</span> <span class="nav-text">Hash Map冲突如何解决？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">哈希冲突解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.3.</span> <span class="nav-text">Hash_map扩容发生什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.</span> <span class="nav-text">Unordered_map和map底层实现有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.1.</span> <span class="nav-text">map与unordered_map的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.2.</span> <span class="nav-text">为什么用红黑树？红黑树查询效率为什么快？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.5.</span> <span class="nav-text">为何map和set的插入删除效率比用其他序列容器高？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.5.1.</span> <span class="nav-text">为什么每次insert之后，以前保存的iterator不会失效</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.</span> <span class="nav-text">vector相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.1.</span> <span class="nav-text">vector空间的动态增长</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.2.</span> <span class="nav-text">vector底层数据结构，vector底层是如何删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.3.</span> <span class="nav-text">push_back()时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.4.</span> <span class="nav-text">push_back与emplace_back的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.7.</span> <span class="nav-text">STL里的内存池实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.7.1.</span> <span class="nav-text">内存的分配和回收</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
