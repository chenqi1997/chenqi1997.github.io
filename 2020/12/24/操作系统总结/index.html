<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,操作系统,">










<meta name="description" content="操作系统 Linux的内存不足时会发生什么？ 操作系统的四大特性 死锁/活锁/饥饿 死锁 死锁预防方式： 银行家算法   活锁 解决方法   饥饿 解决方法     ⭐进程和线程的区别和联系 多进程和多线程的区别？ 多进程和多线程的选择 线程实现 临界区(进程同步) 临界区实现：忙等互斥   原子操作 CAS原子操作(compare and swap)   进程间如何通信？ 应用场景 管道 无">
<meta name="keywords" content="基础知识,操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统总结">
<meta property="og:url" content="http://chenqi1997.github.io/2020/12/24/操作系统总结/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="操作系统 Linux的内存不足时会发生什么？ 操作系统的四大特性 死锁/活锁/饥饿 死锁 死锁预防方式： 银行家算法   活锁 解决方法   饥饿 解决方法     ⭐进程和线程的区别和联系 多进程和多线程的区别？ 多进程和多线程的选择 线程实现 临界区(进程同步) 临界区实现：忙等互斥   原子操作 CAS原子操作(compare and swap)   进程间如何通信？ 应用场景 管道 无">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613376373328.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/364303/201608/364303-20160815231938828-201985819.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1611912291736.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1611911258138.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1611923980113.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg">
<meta property="og:image" content="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg">
<meta property="og:image" content="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215306696">
<meta property="og:image" content="https://img-blog.csdn.net/20161031215332079">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613377518357.png">
<meta property="og:image" content="http://chenqi1997.github.io/2020/12/24/images/wutaimoxing.png">
<meta property="og:image" content="http://chenqi1997.github.io/2020/12/24/images/qitaimoxing.png">
<meta property="og:image" content="http://chenqi1997.github.io/2020/12/24/images/xianchengzhuangtai.png">
<meta property="og:image" content="https://blog-10039692.file.myqcloud.com/1508828310237_5629_1508828349049.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2012/426620/2012072020252592.jpg">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613564872855.png">
<meta property="og:image" content="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140849">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200138896">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200139219">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200139703">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140021">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140375">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190915131156673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190915142010343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMj1rxibhibqZx2wKJiaFvWic5iaqcOzoicHQVQ07GHIveN1Sb0ZV2tEQLic5nw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMSj8caicicn1aLlm47p4w3OKgk7dHGXUjRkGibPMfF4VAcdptA5wibPpg1w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkpVTcOZj4JJSyYlSMyiaC66pP2q1QiafglrtO0tmZHCkBB0RvCsfVOTIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkTX5icicl09hKPabMh2LHcfiapeTumDtOUB3fydDdsIGuNKI0uUWia4k5oA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk87ABj8vKWeQANrKVHpm7xNZRTbgFPOicpy74mD65ia3rGgMaIo6G1ntQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkZoTKofqkOibHicWGJPwsCjZGRpG077zmMMnRibkVqcVocZz1PxeIuLLMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613550514882.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613724196305.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613553592209.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613557269389.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613552517448.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613552606242.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191110103218405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODQxMTMw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200112153313860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTE0NjE4My8yMDE3MTEvMTE0NjE4My0yMDE3MTEwODEyNDgzMTE2OS0xMDE2NTA3MjY0LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613558372501.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkr9Pf9QeM2EhturaF3WFbL7AFYHJvKexk3As6s2vg1NiaUh5AplRmqyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613563964377.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170407165752062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzYxNjk0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj9hpbcplj30gn0ai75b.jpg">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613448111292.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj9hrh4e9j30hf0er0ul.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj9hl7i3oj30or0e8mzv.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-e73214ed85cb2efb741c29ef16e219ed_720w.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190517100335193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZJTExNT1JFYWQ=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190118103657278.png">
<meta property="og:image" content="https://img-blog.csdn.net/20171123134230506">
<meta property="og:image" content="https://img-blog.csdn.net/20171123110419140">
<meta property="og:image" content="https://img-blog.csdn.net/20171123144706226">
<meta property="og:image" content="https://img-blog.csdn.net/20171123144810407">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEribOicpWLdXXwnN18ia5Ew0ee0r7o1NFm4ztG5fR6HPsn5lxAx5sic3K7rWokRr0upbmADY8tRmDzBn4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEribOicpWLdXXwnN18ia5Ew0ee0Q3PS1O2sibKawndLsCMkoBMIrZTByiaAusR4zJfYznic71N45lwziantDw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:updated_time" content="2021-02-20T07:17:16.897Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统总结">
<meta name="twitter:description" content="操作系统 Linux的内存不足时会发生什么？ 操作系统的四大特性 死锁/活锁/饥饿 死锁 死锁预防方式： 银行家算法   活锁 解决方法   饥饿 解决方法     ⭐进程和线程的区别和联系 多进程和多线程的区别？ 多进程和多线程的选择 线程实现 临界区(进程同步) 临界区实现：忙等互斥   原子操作 CAS原子操作(compare and swap)   进程间如何通信？ 应用场景 管道 无">
<meta name="twitter:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613376373328.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/12/24/操作系统总结/">





  <title>操作系统总结 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/12/24/操作系统总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-24T17:46:00+08:00">
                2020-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</a></li>
<li><a href="#操作系统的四大特性">操作系统的四大特性</a></li>
<li><a href="#死锁活锁饥饿">死锁/活锁/饥饿</a><ul>
<li><a href="#死锁">死锁</a><ul>
<li><a href="#死锁预防方式">死锁预防方式：</a></li>
<li><a href="#银行家算法">银行家算法</a></li>
</ul>
</li>
<li><a href="#活锁">活锁</a><ul>
<li><a href="#解决方法">解决方法</a></li>
</ul>
</li>
<li><a href="#饥饿">饥饿</a><ul>
<li><a href="#解决方法-1">解决方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#进程和线程的区别和联系">⭐进程和线程的区别和联系</a></li>
<li><a href="#多进程和多线程的区别">多进程和多线程的区别？</a></li>
<li><a href="#多进程和多线程的选择">多进程和多线程的选择</a></li>
<li><a href="#线程实现">线程实现</a></li>
<li><a href="#临界区进程同步">临界区(进程同步)</a><ul>
<li><a href="#临界区实现忙等互斥">临界区实现：忙等互斥</a></li>
</ul>
</li>
<li><a href="#原子操作">原子操作</a><ul>
<li><a href="#cas原子操作compare-and-swap">CAS原子操作(compare and swap)</a></li>
</ul>
</li>
<li><a href="#进程间如何通信">进程间如何通信？</a><ul>
<li><a href="#应用场景">应用场景</a></li>
<li><a href="#管道">管道</a><ul>
<li><a href="#无名管道pipe">无名管道(pipe)</a></li>
<li><a href="#有名管道fifo">有名管道(FIFO)</a></li>
</ul>
</li>
<li><a href="#信号signal">信号(signal)</a></li>
<li><a href="#消息队列message-queue">消息队列(message queue)</a></li>
<li><a href="#共享内存shared-memory">共享内存(shared memory)</a></li>
<li><a href="#信号量semophore">信号量(semophore )</a><ul>
<li><a href="#信号量工作原理">信号量工作原理</a></li>
<li><a href="#semget函数">semget函数</a></li>
<li><a href="#semop函数">semop函数</a></li>
<li><a href="#semctl函数">semctl函数</a></li>
<li><a href="#c11实现信号量">C++11实现信号量</a></li>
</ul>
</li>
<li><a href="#套接字socket">套接字(socket)</a></li>
</ul>
</li>
<li><a href="#进程的状态">进程的状态</a><ul>
<li><a href="#三态模型">三态模型</a></li>
<li><a href="#五态模型">五态模型</a></li>
<li><a href="#七态模型">七态模型</a></li>
<li><a href="#进程状态控制">进程状态控制</a></li>
<li><a href="#线程状态">线程状态</a></li>
</ul>
</li>
<li><a href="#进程切换">进程切换</a></li>
<li><a href="#linux的进程控制块pcb">linux的进程控制块(PCB)</a></li>
<li><a href="#linux-rcu机制内核同步机制">Linux RCU机制(内核同步机制)</a><ul>
<li><a href="#增加链表项">增加链表项</a></li>
<li><a href="#访问链表项">访问链表项</a></li>
<li><a href="#更新链表项">更新链表项</a></li>
</ul>
</li>
<li><a href="#孤儿进程僵尸进程">孤儿进程/僵尸进程</a><ul>
<li><a href="#问题及危害">问题及危害</a></li>
<li><a href="#waitwaitpid函数">wait/waitpid函数</a></li>
<li><a href="#孤儿进程解决办法">孤儿进程解决办法</a></li>
<li><a href="#僵尸进程解决办法">僵尸进程解决办法</a></li>
</ul>
</li>
<li><a href="#写时复制cow">写时复制(COW)</a><ul>
<li><a href="#exec族函数">exec族函数</a></li>
<li><a href="#进程中的环境变量说明">进程中的环境变量说明</a></li>
<li><a href="#如果一个进程2gb-fork-之后这两个进程占用多少内存">如果一个进程2GB， fork 之后这两个进程占用多少内存？</a></li>
</ul>
</li>
<li><a href="#进程线程的上下文">进程/线程的上下文</a><ul>
<li><a href="#进程的上下文可以分为哪几个部分">进程的上下文可以分为哪几个部分？</a></li>
<li><a href="#为什么切换线程比切换进程开销小">为什么切换线程比切换进程开销小</a></li>
</ul>
</li>
<li><a href="#多线程间通信和同步">多线程间通信和同步</a></li>
<li><a href="#进程的切换时机">进程的切换时机</a><ul>
<li><a href="#切换时需要保存哪些数据">切换时需要保存哪些数据？</a></li>
</ul>
</li>
<li><a href="#协程">⭐协程</a><ul>
<li><a href="#libco库">libco库</a></li>
</ul>
</li>
<li><a href="#五种io模型">五种IO模型</a><ul>
<li><a href="#阻塞iobio">阻塞IO(BIO)</a></li>
<li><a href="#非阻塞ionio">非阻塞IO(NIO)</a></li>
<li><a href="#io多路复用">IO多路复用</a></li>
<li><a href="#信号驱动的io模型sigio">信号驱动的IO模型(SIGIO)</a></li>
<li><a href="#异步io模型aio非阻塞">异步IO模型(AIO)(非阻塞)</a></li>
</ul>
</li>
<li><a href="#两种io事件处理模式">两种IO事件处理模式</a><ul>
<li><a href="#reactor模式同步的">Reactor模式(同步的)</a></li>
<li><a href="#proactor模式-异步">Proactor模式 (异步)</a></li>
</ul>
</li>
<li><a href="#io多路复用selectpollepoll同步阻塞">⭐IO多路复用：select/poll/epoll(同步/阻塞)</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a><ul>
<li><a href="#epoll-函数">epoll 函数</a></li>
<li><a href="#epoll的底层实现"><strong>epoll的底层实现</strong></a></li>
<li><a href="#边缘触发et水平触发lt">边缘触发ET&amp;水平触发LT</a></li>
<li><a href="#使用epoll是否需要将socket设置为nonblocking">使用epoll是否需要将socket设置为nonblocking?</a></li>
<li><a href="#epoll的优点">epoll的优点</a></li>
<li><a href="#lt和et的读写问题">LT和ET的读写问题</a></li>
<li><a href="#et模式的线程饥饿问题">ET模式的线程饥饿问题</a></li>
<li><a href="#epolloneshot设置">EPOLLONESHOT设置</a></li>
<li><a href="#两种模式的选择">两种模式的选择</a></li>
<li><a href="#epoll的惊群问题epollexclusive">epoll的惊群问题(EPOLLEXCLUSIVE)</a></li>
<li><a href="#边缘触发的io应该怎么写">边缘触发的IO应该怎么写？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#虚拟内存">虚拟内存</a><ul>
<li><a href="#虚拟内存作为缓存的工具">虚拟内存作为缓存的工具</a></li>
<li><a href="#内存分段">内存分段</a></li>
<li><a href="#内存分页">内存分页</a></li>
<li><a href="#页表">页表</a></li>
<li><a href="#多级页表">多级页表</a><ul>
<li><a href="#k级页表层次结构">K级页表层次结构</a></li>
<li><a href="#多级页表的优势"><strong>多级页表的优势</strong></a></li>
<li><a href="#多级页表的劣势"><strong>多级页表的劣势</strong></a></li>
</ul>
</li>
<li><a href="#tlbtranslation-lookaside-buffer-页表缓存快表转换检测缓冲区相关存储器实现">TLB(<em>Translation Lookaside Buffer</em>) 页表缓存/快表/转换检测缓冲区(相关存储器实现)</a></li>
<li><a href="#反向页表">反向页表</a><ul>
<li><a href="#传统页表的缺点">传统页表的缺点</a></li>
</ul>
</li>
<li><a href="#段页式内存管理">段页式内存管理</a></li>
<li><a href="#linux虚拟内存">Linux虚拟内存</a><ul>
<li><a href="#用户空间的内存分布">用户空间的内存分布</a></li>
</ul>
</li>
<li><a href="#mmap内存映射">mmap内存映射</a><ul>
<li><a href="#共享对象">共享对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#缺页中断page_fault缺页异常">缺页中断(page_fault)/缺页异常</a></li>
<li><a href="#页面置换算法">页面置换算法</a></li>
<li><a href="#cpu调度算法进程调度算法">CPU调度算法/进程调度算法</a><ul>
<li><a href="#先到先服务算法fcfs-first-come-first-served">先到先服务算法(FCFS, First-Come First-Served)</a></li>
<li><a href="#最短作业优先sjf-shortest-job-first">最短作业优先(SJF, Shortest Job First)</a></li>
<li><a href="#优先级算法">优先级算法</a></li>
<li><a href="#高响应比优先调度算法hrrn">高响应比优先调度算法(HRRN)</a></li>
<li><a href="#最短剩余时间优先-srtf-shortest-remaining-time-first">最短剩余时间优先 (SRTF, Shortest Remaining Time First)</a></li>
<li><a href="#rrround-robin调度器">RR(Round Robin)调度器</a></li>
<li><a href="#多级反馈队列mfq">多级反馈队列(MFQ)：</a></li>
</ul>
</li>
<li><a href="#用户态与内核态">用户态与内核态</a><ul>
<li><a href="#三种情况会导致用户态到内核态的切换">三种情况会导致用户态到内核态的切换</a></li>
</ul>
</li>
<li><a href="#linux文件系统">Linux文件系统</a><ul>
<li><a href="#系统调用">系统调用</a></li>
<li><a href="#虚拟文件系统">虚拟文件系统</a></li>
<li><a href="#vfs主要模块">VFS主要模块</a></li>
<li><a href="#io-缓冲区buffer">I/O 缓冲区(buffer)</a><ul>
<li><a href="#概念"><strong>概念</strong></a></li>
<li><a href="#buffer-和-cache"><strong>Buffer 和 Cache</strong></a></li>
<li><a href="#buffer-cache和-page-cache"><strong>Buffer Cache和 Page Cache</strong></a></li>
</ul>
</li>
<li><a href="#文件读写基本流程">文件读写基本流程</a><ul>
<li><a href="#读文件"><strong>读文件</strong></a></li>
<li><a href="#写文件"><strong>写文件</strong></a></li>
</ul>
</li>
<li><a href="#linux-io-读写方式">Linux I/O 读写方式</a><ul>
<li><a href="#io-中断">I/O 中断</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#linux下如何定位内存泄露valgrind">Linux下如何定位内存泄露？<strong>valgrind</strong></a></li>
<li><a href="#cache的结构与工作原理">Cache的结构与工作原理</a><ul>
<li><a href="#cache-line">Cache Line</a></li>
<li><a href="#写入策略">写入策略</a></li>
<li><a href="#cache一致性问题"><strong>Cache一致性</strong>问题</a><ul>
<li><a href="#mesi缓存一致性协议">MESI缓存一致性协议</a></li>
</ul>
</li>
<li><a href="#l1-cachel2-cachel3-cache">L1 Cache/L2 Cache/L3 Cache</a></li>
</ul>
</li>
<li><a href="#如何确定线程池的线程数量">如何确定线程池的线程数量?</a></li>
<li><a href="#大小端模式">大小端模式</a><ul>
<li><a href="#判断方式">判断方式</a></li>
</ul>
</li>
<li><a href="#linux-kill操作">Linux kill操作</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h2><span id="操作系统">操作系统</span></h2><h3><span id="linux的内存不足时会发生什么">Linux的内存不足时会发生什么？</span></h3><p>物理内存用完就会使用交换空间（<code>swap</code>），会导致应用运行变慢。因为需要频繁在交换空间和内存之间换入换出数据。</p>
<hr>
<h3><span id="操作系统的四大特性">操作系统的四大特性</span></h3><ul>
<li><strong>并发</strong>：程序并发执行</li>
<li><strong>共享</strong>：共享资源</li>
<li><strong>虚拟</strong>：虚拟地址，为物理硬件提供逻辑接口来降低使用难度</li>
<li><strong>异步</strong>：进程走走停停，上下文切换</li>
</ul>
<hr>
<h3><span id="死锁活锁饥饿">死锁/活锁/饥饿</span></h3><h4><span id="死锁">死锁</span></h4><p>一组互相竞争资源的线程因互相等待，导致<strong>永久阻塞</strong>的现象。说白了就是：两个线程互相持有对方所需的资源，互不释放且互相等待。</p>
<p>常见的死锁：</p>
<ul>
<li>线程申请的锁资源被自己的线程锁住并且还没被释放，导致永远挂起</li>
<li>多线程竞争资源陷入循环等待 eg.T1拥有锁L1，T2拥有锁L2。此时T1申请L2，T2申请L1</li>
<li>进程推进顺序不当 eg.T1，T2分别产出D1，D2，并接受D2，D1，如果顺序反过来就会永远挂起。</li>
</ul>
<p><strong>死锁产生的条件</strong>：产生死锁<strong>必须同时满足以下四个条件</strong>，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件</strong>：进程申请的资源在一段时间内只能被一个进程使用</li>
<li><strong>请求与等待条件</strong>：进程已经拥有了一个资源，但是又申请新的资源，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。—-&gt;在进程运行之前就把需要申请的资源一次性申请到位，满足运行，不满足等待。</li>
<li><strong>不可剥夺条件</strong>：在一个进程没有用完，主动释放资源的时候，不能被抢夺</li>
<li><strong>循环等待条件</strong>：多个进程之间存在资源循环链</li>
</ul>
<h5><span id="死锁预防方式">死锁预防方式：</span></h5><ul>
<li>打破互斥条件：<strong>改造独占性资源为虚拟资源</strong>，大部分资源已无法改造。</li>
<li>打破不可抢占条件：<strong>当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源</strong>。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即<strong>进程运行前申请全部资源</strong>，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现<strong>资源有序分配策略</strong>，对所有设备实现分类编号，所有进程只能采用按<strong>序号递增</strong>的形式申请资源。</li>
</ul>
<h5><span id="银行家算法">银行家算法</span></h5><ol>
<li>安全性算法：假设释放一个进程，然后再找下一个能在剩余可用资源中被释放的进程。以此类推，如果都能被释放，系统处于安全状态</li>
<li>资源请求算法：三步判断是否分配资源</li>
</ol>
<ul>
<li>request&lt;=need[i]</li>
<li>request&lt;=available</li>
<li>available-=request; allocation[i]+=request; need[i]-=request 运行安全性算法</li>
</ul>
<hr>
<h4><span id="活锁">活锁</span></h4><p><strong>活锁：</strong>是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。活锁不会被阻塞，而是不停检测一个永远不可能为真的条件。除去进程本身持有的资源外，活锁状态的进程会持续耗费宝贵的<a href="https://www.baidu.com/s?wd=CPU%E6%97%B6%E9%97%B4&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">CPU时间</a>。</p>
<h5><span id="解决方法">解决方法</span></h5><p><strong>线程谦让时，尝试等待一个随机的时间就可以了</strong>。“<code>等待一个随机时间</code>”的方案虽然很简单，却非常有效，<code>Raft</code> 这样知名的分布式一致性算法中也用到了它。</p>
<p>例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。</p>
<hr>
<h4><span id="饥饿">饥饿</span></h4><p><strong>饥饿：</strong>是指如果线程 <code>T1</code>占用了资源 <code>R</code> ，线程 <code>T2</code> 又请求锁 <code>R</code> ，于是 <code>T2</code> 等待。<code>T3</code> 也请求资源 <code>R</code> ，当 <code>T1</code> 释放了 <code>R</code> 上的封锁后，系统首先批准了 <code>T3</code> 的请求，<code>T2</code> 仍然等待。然后 <code>T4</code> 又请求封锁 <code>R</code> ，当 <code>T3</code> 释放了 <code>R</code> 上的封锁之后，系统又批准了 <code>T4</code> 的请求……，<code>T2</code> 可能永远等待。也就是<strong>低优先级的线程资源一直被高优先级抢占</strong></p>
<h5><span id="解决方法">解决方法</span></h5><p>下面提供了<code>三种方案</code></p>
<ol>
<li>保证资源充足</li>
<li>公平地分配资源</li>
<li>避免持有锁的线程长时间执行</li>
</ol>
<hr>
<h3><span id="进程和线程的区别和联系">⭐进程和线程的区别和联系</span></h3><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613376373328.png" alt="1613376373328"></p>
<p>我们可以说“进程”是包含“线程”的，“线程”是“进程”的一个子集。进程是资源分配的最小单位，线程是程序执行的最小单位。一个程序至少有一个进程,一个进程至少有一个线程。线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。</p>
<p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系<strong>统进行资源分配和调度的基本单位，是操作系统结构的基础</strong>。 在当代面向线程设计的计算机结构中，<strong>进程是线程的容器</strong>。程序是指令、数据及其组织形式的描述，进程是程序的实体。每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。</p>
<p><strong>线程（thread）</strong> 是<strong>操作系统能够进行运算调度的最小单位</strong>。<strong>它被包含在进程之中，是进程中的实际运作单位</strong>。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。不同的线程共享进程的地址空间，全局变量（数据和堆）。在一个进程中，各个线程共享堆区，而进程中的线程各自维持自己的栈。</p>
<p><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160815231938828-201985819.png" alt="img"></p>
<p><strong>进程是由线程+内存+文件/网络句柄构成的</strong>，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。</p>
<p><strong>线程是由栈+PC(程序计数器)+TLS(线程本地存储)组成的。</strong>操作系统真正运行的是一个个的线程，而我们的进程只是它的一个容器。<strong>PC程序计数器是当前执行指令的地址</strong>，而这个指令是放在内存中。每个线程都有一串自己的指针，去指向自己当前所在内存的指针。计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的，这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。<strong>TLS</strong>用来存储线程所独有的数据。</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1611912291736.png" alt="1611912291736"></p>
<ul>
<li>进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</li>
<li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li>
<li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li>
<li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li>
<li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li>
</ul>
<p>与每个进程相关的是<strong>地址空间(address Space)</strong>，这是从某个最小值的存储位置。<strong>地址空间是从某个最小值的存储位置(通常是0)到某个最大值的存储位置的列表，在这个地址空间中，进程可以进行读写操作。</strong>地址空间中存放有可执行程序、程序所需要的数和它的栈，同时与每个进程相关的还有资源集，通常包括寄存器(程序计数器PC和堆栈指针stack pointer)、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。</p>
<p>在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容意外，均存放在操作系统的一张表中，称为<strong>进程表(process table)</strong>，进程表是<strong>数组</strong>或者<strong>链表</strong>结构，当前存在的每个进程都要占据其中的一项。</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1611911258138.png" alt="1611911258138"></p>
<hr>
<h3><span id="多进程和多线程的区别">多进程和多线程的区别？</span></h3><p>多进程一般使用 <code>fork()</code> / <code>vfork()</code></p>
<p>多线程一般使用 <code>pthread_create()</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,   <span class="comment">//新创建的线程ID指向的内存单元。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,  <span class="comment">//线程属性，默认为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), <span class="comment">//新创建的线程从start_rtn函数的地址开始运行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *<span class="keyword">restrict</span> arg <span class="comment">//默认为NULL。若上述函数需要参数，将参数放入结构中并将地址作为arg传入。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>多进程</strong></th>
<th><strong>多线程</strong></th>
<th><strong>总结</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用<strong>IPC</strong>；数据是分开的，<strong>同步简单</strong></td>
<td>因为共享进程数据，<strong>数据共享简单</strong>，但也是因为这个原因导致<strong>同步复杂</strong></td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td><strong>一个线程挂掉将导致整个进程挂掉</strong></td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<h3><span id="多进程和多线程的选择">多进程和多线程的选择</span></h3><table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<hr>
<h3><span id="线程实现">线程实现</span></h3><p>线程主要有三种实现方式：</p>
<ul>
<li><p><strong>在用户空间中实现线程</strong></p>
<ul>
<li><p>整个线程包放在用户空间中，内核对线程一无所知。</p>
</li>
<li><p>优点：保存线程的状态和调度程序都是本地过程，所以启动他们比进行内核调用效率更高，因而不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新。</p>
</li>
<li><p>缺点：</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1611923980113.png" alt="1611923980113"></p>
</li>
</ul>
</li>
<li><p><strong>在内核空间中实现线程</strong></p>
</li>
<li><p><strong>在用户和内核空间中混合实现线程</strong></p>
</li>
</ul>
<hr>
<h3><span id="临界区进程同步">临界区(进程同步)</span></h3><p>操作系统中，同一时刻内同一段代码可能会有多个<strong>进程</strong>在执行，而像 <code>文件读写</code> 、<code>硬件调用</code> 等操作都是排他性的，因此操作系统更应该做好临界区的设置。</p>
<p>临界区( <code>critical-section</code> )是解决进程协作的一个方法。将<strong>多个进程可能修改同一个共享变量的代码段</strong>设为临界区，当有进程进入临界区后，其他进程会被禁止进入，直到前一个进程离开临界区，其他进程才可以进入。即<strong>同一时刻只允许一个进程位于临界区</strong>内。伪代码形式可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//进入区</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="comment">//退出区</span></span><br><span class="line">	<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<p><strong>临界区的实现需要满足以下三个条件：</strong></p>
<ol>
<li><strong>互斥</strong>，即同一时刻只能有一个进程位于临界区内；</li>
<li><strong>前进</strong>，当多个进程同时等待进入临界区的时候，会有一个进程被选择进入</li>
<li><strong>有限等待</strong>，在进入区等待的进程必须在有限时间后进入临界区。</li>
</ol>
<p><strong>实现方式：</strong>对于操作系统的临界区实现，要分为<strong>抢占内核</strong>和<strong>非抢占内核</strong>来讨论。显然，非抢占内核不存在竞争的问题，因为在临界区内的进程不会被打断，除非进程主动退出。对抢占内核来说，就需要硬件或者软件（算法）上的支持来实现临界区。</p>
<p>软件支持的一个例子是 <code>Peterson</code> 算法。<code>Peterson</code> 算法的精髓在于用两个变量（或数组）来记录当前是否有进程位于临界区以及哪个进程位于临界区，这样通过在进入区检测并设置标记、退出区恢复标记可以实现临界区排他的特性。</p>
<p>硬件支持的方法是 <code>锁</code> ，从底层硬件的层面来看则是实现 <code>原子操作</code> 。进程在进入临界区前检测并申请锁，离开后释放锁。原子操作保证锁的正常运行。<br>Linux下的原子操作的数据结构是 <code>atomic_t</code> ，其定义放在 <code>&lt;linux/types.h&gt;</code> 下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125;<span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>对于单处理器单核系统来说，只要保证操作指令序列不被打断即可实现原子操作。对于简单的原子操作，<code>cpu</code> 实现上会提供单条指令，比如 <code>INC</code> 和 <code>XCHG</code> 。对于复杂的原子操作，需要包含多条指令。执行过程中，出现上下文切换行为，比如任务切换，中断处理等。这里的行为会影响原子操作的原子性。因此需要自旋锁 <code>spinlock</code> 来保证操作指令序列不会在执行的中途受干扰。</p>
<p>但是如果对于多处理器或者多核的系统，原子操作的实现除了需要 <code>spinlock</code> 来保证外，还需要保证不会受到同处理器上其他核，或者其他处理器的影响。当其他核上执行的指令访问的内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。</p>
<p>在 <code>x86架构</code> 中，提供了指令前缀 <code>LOCK</code> 。<code>LOCK</code> 保证了指令不会受其他处理器或 <code>cpu</code> 核的影响。在 <code>PentiumPro</code> 之前，<code>LOCK</code> 的实现，是通过锁住 <code>bus</code> （总线），从而阻止其他 <code>cpu</code> 核的内存访问。可想而知，这种实现是非常低效的。从 <code>PentiumPro</code> 开始，<code>LOCK</code> 只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<p><img src="https://images0.cnblogs.com/blog/405877/201404/091831558405701.jpg" alt="img"></p>
<p>现在，大多数的 <code>x86</code> 处理器都支持了 <code>CAS</code> 的硬件实现，保证了多处理器多核系统下的原子操作的正确性。<code>CAS</code> 的实现同样无需锁住总线，只会阻塞其他 <code>cpu</code> 核对相关内存的缓存块的访问。</p>
<h4><span id="临界区实现忙等互斥">临界区实现：忙等互斥</span></h4><ul>
<li><strong>屏蔽中断</strong>：对于操作系统比较有用，但是对于用户线程来说不太通用。</li>
<li><strong>锁变量</strong>：<code>set</code> 和 <code>check</code> 不是原子操作，会导致竞争条件发生。</li>
<li><strong>严格轮询法</strong>：利用自旋锁忙等待，位于临界区外的进程会阻塞其他进程。</li>
<li><strong>Peterson解法</strong></li>
<li><strong>TSL硬件指令</strong>：测试并加锁( <code>test and set lock</code> )</li>
</ul>
<hr>
<h3><span id="原子操作">原子操作</span></h3><p>原子操作指的是不可再分的指令操作，即在执行原子操作时不可能被打断，要么原子操作没有执行，要么已经执行完毕。原子操作的实现必须需要硬件的支持，操作系统仅仅是在硬件指令的基础之上进行一次封装。对于没有实现原子操作的硬件，则需要操作系统从软件算法层面进行支持。</p>
<h4><span id="cas原子操作compare-and-swap">CAS原子操作(compare and swap)</span></h4><p>如果一个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是原子的(atomic)。</p>
<p><strong>为什么要有CAS：</strong>因为通过锁实现原子操作时，其他线程必须等待已经获得锁的线程运行完以后才能获得资源，这样就会占用系统的大量资源。<code>CAS</code> <strong>可以通过硬件层面的阻塞实现原子操作的安全</strong>。</p>
<p><code>CAS</code> 原子操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">    ATOMIC();</span><br><span class="line">    <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">    <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">    	*reg = newval;</span><br><span class="line">    END_ATOMIC();</span><br><span class="line">    <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了还有如下几个原子操作：</p>
<ul>
<li><strong>Fetch And Add：</strong>一般用来对变量做 <code>+1</code> 的原子操作。</li>
<li><strong>Test-and-set：</strong>写值到某个内存位置并传回其旧值。汇编指令 <code>BST</code> 。</li>
<li><strong>Test and Test-and-set</strong>：用来实现多核环境下相互排斥锁。</li>
</ul>
<p>C++11中的 <code>STL</code> 中的 <code>atomic</code> 类的函数能够跨平台使用。（完整的C++11的原子操作可參看 <a href="http://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">Atomic Operation Library</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br><span class="line">template&lt; class T &gt;</span><br><span class="line">bool atomic_compare_exchange_weak( volatile std::atomic&lt;T&gt;* obj, T* expected, T desired );</span><br></pre></td></tr></table></figure>
<p>具体使用的时候可以如下实现无锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mutex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unlock = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">test_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!(__sync_bool_compare_and_swap (&amp;mutex,lock, <span class="number">1</span>) )) usleep(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">//当CAS成功后跳出while循环,此时mutex已经变成了1,也就是上锁了</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        __sync_bool_compare_and_swap (&amp;mutex, unlock, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="进程间如何通信">进程间如何通信？</span></h3><p><img src="https://www.linuxprobe.com/wp-content/uploads/2018/04/timg-4.jpg" alt="6种Linux进程间的通信方式6种Linux进程间的通信方式"></p>
<h4><span id="应用场景">应用场景</span></h4><ol>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ol>
<p>本地的进程间通信（ <code>IPC</code> ）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<h4><span id="管道">管道</span></h4><p><strong>管道的概念</strong></p>
<ul>
<li>管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。</li>
<li>一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。</li>
<li><strong>数据被一个进程读出后，将被从管道中删除</strong>，其它读进程将不能再读到这些数据。</li>
<li>管道提供了简单的流控制机制，<strong>进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞</strong></li>
<li>管道包括<strong>无名管道</strong>和<strong>有名管道</strong>两种，前者<strong>用于父进程和子进程间的通信，后者可用于运行于同一系统中的任意两个进程间的通信</strong>。</li>
</ul>
<h5><span id="无名管道pipe">无名管道(pipe)</span></h5><p>无名管道是一种<strong>半双工</strong>的通信方式，数据只能<strong>单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系一般指的是父子关系。无明管道一般用于<strong>两个不同进程之间的通信</strong>。当一个进程创建了一个管道，并调用 <code>fork</code> 创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。</p>
<p><img src="https://www.linuxidc.com/upload/2016_10/161030192767972.jpg" alt="这里写图片描述"></p>
<p>无名管道创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符(<strong>fd</strong>)：</p>
<ul>
<li><code>filedis[0]</code> 用于读管道。</li>
<li><code>filedis[1]</code> 用于写管道。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161031215306696" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20161031215332079" alt="img"></p>
<ul>
<li>管道通讯是<strong>单向</strong>的，有固定的<strong>读端和写端</strong>。</li>
<li>数据被进程从管道读出后，在管道中该数据就不存在了。</li>
<li>当进程去<strong>读取空管道</strong>的时候，进程会阻塞。</li>
<li>当进程<strong>往满管道写入数据</strong>时，进程会阻塞。</li>
<li>管道容量为 <strong>64KB</strong>(缓存区有限)</li>
<li><strong>必须在系统调用fork( )前调用pipe( )，否则子进程将不会继承文件描述符</strong></li>
</ul>
<hr>
<h5><span id="有名管道fifo">有名管道(FIFO)</span></h5><p>有名管道和无名管道基本相同，但也有不同点：无名管道只能由父子进程使用；但是通过有名管道，<strong>不相关的进程也能交换数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_tmode)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>pathname：FIFO文件名</p>
</blockquote>
<blockquote>
<p>mode：属性（见文件操作章节）</p>
</blockquote>
<p><strong>一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO。</strong></p>
<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
<hr>
<h4><span id="信号signal">信号(signal)</span></h4><ul>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
<hr>
<h4><span id="消息队列message-queue">消息队列(message queue)</span></h4><ul>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>
<li>消息队列<strong>克服了信号传递信息少</strong>、<strong>管道只能承载无格式字节流以及缓冲区大小受限</strong>等缺点。</li>
<li>消息队列 ( <code>message queue</code> )与 <code>PIPE</code> 相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符( <code>message_type</code> )。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照<strong>先进先出</strong>的顺序取出，也可以<strong>只取出符合某个识别符的消息</strong>(有多个这样的消息时，同样按照先进先出的顺序取出)。</li>
<li>消息队列与 <code>PIPE</code> 的另一个不同在于它并不使用文件 <code>API</code> 。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</li>
</ul>
<hr>
<h4><span id="共享内存shared-memory">共享内存(shared memory)</span></h4><ul>
<li>共享内存就是<strong>映射一段能被其他进程所访问的内存</strong>，这段共享内存<strong>由一个进程创建，但多个进程都可以访问</strong>。共享内存是⭐<strong>最快</strong>⭐的 <code>IPC(interprocess communication)</code> 方式，它是<strong>针对其他进程间通信方式运行效率低而专门设计</strong>的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li>
<li>可以用设备驱动模型中的 <code>mmap</code> 函数实现。<ul>
<li>共享内存与多线程共享 <code>global data</code> 和 <code>heap</code> 类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用 <code>semaphore</code> 同步，也可以在共享内存中建立 <code>mutex</code> 或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，<strong>不涉及内核的拷贝</strong>，所以它是效率最高的 <code>IPC</code> 方式。</li>
</ul>
</li>
<li><strong>优点</strong>：无须复制，快捷，信息量大</li>
<li><strong>缺点</strong>：<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题(映射到<strong>文件映射段</strong>)</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
<hr>
<h4><span id="信号量semophore">信号量(semophore )</span></h4><ul>
<li>信号量是一个计数器，可以用来<strong>控制多个线程对共享资源的访问</strong>，它不是用于交换大批数据，而是用于多线程之间的同步。它常作为一种<strong>锁机制</strong>，防止某进程在访问资源时其它进程也访问该资源。因此，<strong>主要作为进程间以及同一个进程内不同线程之间的同步手段</strong>。</li>
<li>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法。比如在任一时刻只能有一个执行线程访问代码的<strong>临界区</strong>。临界区是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说<strong>信号量是用来调协进程对共享资源的访问的</strong>。</li>
<li>信号量是一个特殊的变量，程序对其访问都是<strong>原子操作</strong>，且只允许对它进行等待(<code>P(sv)</code>) 和发送(<code>V(sv)</code>)信息操作。最简单的信号量是只能取 <code>0</code> 和 <code>1</code> 的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。</li>
<li>缺点是<strong>信号量有限</strong>。</li>
</ul>
<h5><span id="信号量工作原理">信号量工作原理</span></h5><p><strong>一个计数器，可以用来控制多个线程对共享资源的访问</strong></p>
<ul>
<li><strong>优点：可以同步进程</strong></li>
<li><strong>缺点：信号量有限</strong></li>
</ul>
<p>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：</p>
<ul>
<li><p><strong>P(S)</strong> 相当于 <code>wait</code></p>
<ul>
<li><p>将信号量 <code>S</code> 的值减 <code>1</code> ，即 <code>S = S - 1</code> ；</p>
</li>
<li><p>如果 <code>S &lt;= 0</code> ，则该进程继续执行；否则该进程置为等待状态，排入等待队列(<strong>此时相当于得到信号量，进入临界区，并且阻止其他进程进入临界区</strong>)。</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P(S)&#123;</span><br><span class="line">    <span class="comment">//S为信号量</span></span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>（S &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//调用进程被阻塞</span></span><br><span class="line">        <span class="comment">//进入S的等待队列</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>V(S)</strong> 相当于 <code>notify</code></p>
<ul>
<li><p>将信号量 <code>S</code> 的值加 <code>1</code> ，即 <code>S = S + 1</code> ；</p>
</li>
<li><p>如果 <code>S &gt; 0</code> ，则该进程继续执行；否则释放队列中第一个等待信号量的进程(<strong>相当于此时释放了信号量出来，可以把等待队列的第一个进程拿出来</strong>)。</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">V(S) &#123;</span><br><span class="line">    <span class="comment">//S为信号量</span></span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(S &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//从S的等待队列中唤醒一个进程</span></span><br><span class="line">        <span class="comment">//使其进入就绪状态</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>举个例子，就是两个进程共享信号量 <code>sv</code> ，一旦其中一个进程执行了 <code>P(sv)</code> 操作，它将得到信号量，并可以进入临界区，使 <code>sv</code> 减1。而第二个进程将被阻止进入临界区，因为当它试图执行 <code>P(sv)</code> 时，<code>sv</code> 为 <code>0</code> ，它会被挂起以等待第一个进程离开临界区域并执行 <code>V(sv)</code> 释放信号量，这时第二个进程就可以恢复执行。</p>
<p>其实从意义上来说，<code>semaphore</code> 就是一个计数锁，它允许被 <code>N</code> 个进程获得。当有更多的进程尝试获得 <code>semaphore</code> 的时候，就必须等待有前面的进程释放锁。当 <code>N</code> 等于 <code>1</code> 的时候，<code>semaphore</code> 与 <code>mutex</code> 实现的功能就完全相同。许多编程语言也使用 <code>semaphore</code> 处理多线程同步的问题。一个 <code>semaphore</code> 会一直存在在内核中，直到某个进程删除它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __<span class="function">must_check <span class="title">down_interruptible</span><span class="params">(struct semaphore *sem)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __<span class="function">must_check <span class="title">down_killable</span><span class="params">(struct semaphore *sem)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __<span class="function">must_check <span class="title">down_trylock</span><span class="params">(struct semaphore *sem)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __<span class="function">must_check <span class="title">down_timeout</span><span class="params">(struct semaphore *sem, <span class="keyword">long</span> jiffies)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<h5><span id="semget函数">semget函数</span></h5><p>它的作用是创建一个新信号量或取得一个已有信号量，semget函数成功返回一个相应信号标识符（非零），失败返回-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h5><span id="semop函数">semop函数</span></h5><p>它的作用是改变信号量的值：如果其值为负数，而其绝对值又大于信号的现值，操作将会阻塞，直到信号值大于或等于sem_op内含值的绝对值，通常用于获取资源的使用权（P操作）。如果其值为正数，该值会加到现有的信号内含值中，通常用于释放所控资源的使用权（V操作）；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf *sem_opa, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">short</span> sem_num;<span class="comment">//除非使用一组信号量，否则它为0  </span></span><br><span class="line">    <span class="keyword">short</span> sem_op;<span class="comment">//信号量在一次操作中需要改变的数据，通常是两个数，</span></span><br><span class="line">				    <span class="comment">//一个是-1，即P（等待）操作，  </span></span><br><span class="line">                    <span class="comment">//一个是+1，即V（释放信号）操作。  </span></span><br><span class="line">    <span class="keyword">short</span> sem_flg;<span class="comment">//通常为SEM_UNDO,使操作系统跟踪信号，  </span></span><br><span class="line">                    <span class="comment">//并在进程没有释放该信号量而终止时，操作系统释放信号量  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5><span id="semctl函数">semctl函数</span></h5><p>该函数用来直接控制信号量信息，command命令主要是两种：</p>
<ul>
<li>SETVAL：用来把信号量初始化为一个已知的值。</li>
<li>IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h5><span id="c11实现信号量">C++11实现信号量</span></h5><p>c++11中有 mutex (互斥量)，有 condition_variable (条件变量)，并没有 semaphore (信号量)。信号量，操作系统中一般都有提，linux下有实现。原生C++并没有提供，可以使用 mutex+condition_variable 实现一个信号量</p>
<ul>
<li>P操作 (wait操作，又可以称为acquire操作，即获取一个资源)：count 减1；如果 count &lt;0 ,表示资源不足，那么挂起执行线程；</li>
<li>V操作 (signal操作，又可以称为release操作，即释放一个资源)：count 加1；如果 count &lt;=0，那么唤醒一个执行线程；</li>
</ul>
<p>现在可以有多把锁，数量 count 最初为 n (可以设定)；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Semaphore(<span class="keyword">int</span> value = <span class="number">1</span>) :count(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lck(mtk);</span><br><span class="line">        <span class="keyword">if</span> (--count &lt; <span class="number">0</span>)<span class="comment">//资源不足挂起线程</span></span><br><span class="line">            cv.wait(lck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lck(mtk);</span><br><span class="line">        <span class="keyword">if</span> (++count &lt;= <span class="number">0</span>)<span class="comment">//有线程挂起，唤醒一个</span></span><br><span class="line">            cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    mutex mtk;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Semaphore.Acquire();</span><br><span class="line"><span class="comment">//todo</span></span><br><span class="line">Semaphore.Release();</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="套接字socket">套接字(socket)</span></h4><ul>
<li>套接字也是一种进程间通信机制，与其他通信机制不同的是，它<strong>可用于不同机器间的进程通信</strong>。</li>
<li><strong>优点：</strong><ol>
<li>传输数据为<strong>字节级</strong>，传输数据<strong>可自定义</strong>，数据量小效率高</li>
<li>传输数据<strong>时间短</strong>，<strong>性能高</strong></li>
<li>适合于客户端和服务器端之间信息<strong>实时交互</strong></li>
<li>可以<strong>加密</strong>，<strong>数据安全性强</strong></li>
</ol>
</li>
<li><strong>缺点：</strong>需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<hr>
<h3><span id="进程的状态">进程的状态</span></h3><h4><span id="三态模型">三态模型</span></h4><ul>
<li><strong>运行(running)态</strong>：进程占有处理器正在运行，<strong>实际占用了CPU时间片运行</strong>。</li>
<li><strong>就绪(ready)态</strong>：进程具备运行条件，等待系统分配处理器以便运行。<strong>此时也可以运行，只不过没有获得CPU时间分片。</strong></li>
<li><strong>阻塞(block)态</strong>：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成。</li>
</ul>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613377518357.png" alt="1613377518357"></p>
<h4><span id="五态模型">五态模型</span></h4><ul>
<li><strong>创建状态</strong>：进程在创建时需要申请一个空白 <code>PCB(进程控制块)</code> ，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li><strong>就绪状态</strong>：进程已经准备好，<strong>已分配到所需资源，只要分配到CPU就能够立即运行</strong>，另外如果<strong>进程运行时间片使用完也会进入就绪状态</strong>。</li>
<li><strong>执行状态</strong>：进程处于就绪状态<strong>被调度后，进程进入执行状态</strong></li>
<li><strong>阻塞状态</strong>：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。<strong>在满足请求时进入就绪状态等待系统调用</strong></li>
<li><strong>终止状态</strong>：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</li>
</ul>
<p><img src="../images/wutaimoxing.png" alt=""></p>
<h4><span id="七态模型">七态模型</span></h4><p>由于在多道程序系统中，<strong>用户进程数往往多于处理机的数量</strong>，这会造成用户进程<strong>抢夺处理机</strong>，系统进程同样需要使用处理机资源。因此系统需要按照一定<strong>调度算法</strong>把珍贵的处理机资源分配给到<strong>就绪队列中的进程</strong>去执行。这会造成进程在外存或内存之间频繁地换入换出，所以就衍生出<strong>挂起态</strong>。</p>
<p>七状态模型分别为：创建态、就绪态、运行态、阻塞态、终止态、<strong>就绪挂起态</strong>、<strong>阻塞挂起态</strong>。</p>
<p><img src="../images/qitaimoxing.png" alt=""></p>
<hr>
<h4><span id="进程状态控制">进程状态控制</span></h4><p>进程控制的主要任务是：创建和撤销进程以及进行进程间的状态转换。这包括：</p>
<ul>
<li>创建一个进程</li>
<li>撤销一个进程</li>
<li>改变进程状态</li>
<li>实现进程间的通信</li>
</ul>
<p>这些<strong>由操作系统内核通过执行各种原语</strong>完成，<strong>原语是由若干条机器指令构成的可完成特定功能的程序段，它是一个原子操作过程，作为一个整体而不可分割，要么全都完成，要么全都不做</strong>。<strong>原语主要是通过屏蔽各种中断和固化技术保证其原子性的</strong></p>
<p>分类：</p>
<ul>
<li>进程控制原语<ul>
<li>进程创建原语：创建PCB+PID-&gt;分配资源-&gt;初始化PCB-&gt;PCB插入就绪队列</li>
<li>进程撤销原语：在PCB集合找PCB-&gt;剥夺CPU，将CPU分配给其他进程-&gt;终止其子进程-&gt;将拥有的资源归还-&gt;删除PCB</li>
<li>进程阻塞原语：在PCB集合找PCB-&gt;保护PCB现场，并修改PCB状态-&gt;停止该进程运行-&gt;插入该阻塞事件的等待队列</li>
<li>进程唤醒原语：在等待队列中查找PCB-&gt;将PCB从等待队列移除并修改状态-&gt;将PCB插入就绪队列</li>
<li>进程挂起原语</li>
<li>进程激活原语</li>
</ul>
</li>
<li>进程通信原语</li>
<li>进程管理原语</li>
<li>其他方面的原语</li>
</ul>
<hr>
<h4><span id="线程状态">线程状态</span></h4><p><img src="../images/xianchengzhuangtai.png" alt=""></p>
<hr>
<h3><span id="进程切换">进程切换</span></h3><p>进程的切换，实质上就是被中断运行进程与待运行进程的上下文切换。从主观上来理解。只分为两步：</p>
<ol>
<li><p><strong>切换新的页表，然后使用新的虚拟地址空间</strong></p>
</li>
<li><p><strong>切换内核栈，加入新的内容(PCB控制块，资源相关)，硬件上下文切换</strong></p>
</li>
</ol>
<p>第二步的切换内核栈，就是使用新的栈来存放进程运行时资源了。然后新进程有新的PCB控制块。第二步也是线程切换的步骤，<strong>因为线程共享进程的虚拟地址空间，所以切换的时候没有第一步的过程</strong></p>
<p>对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。</p>
<ol>
<li><p>(中断/异常等触发)正向模式切换并压入PSW／PC 。 （Program Status Word 程序状态字。program counter 程序计数器。指向下一条要执行的指令）</p>
</li>
<li><p>保存被中断进程的现场信息。</p>
</li>
<li>处理具体中断、异常。</li>
<li>把被中断进程的系统堆栈指针SP值保存到PCB。（Stack Pointer 栈指针。Process Control Block 进程控制块。）</li>
<li>调整被中断进程的PCB信息，如进程状态）。</li>
<li>把被中断进程的PCB加入相关队列。</li>
<li>选择下一个占用CPU运行的进程。</li>
<li>修改被选中进程的PCB信息，如进程状态。</li>
<li>设置被选中进程的地址空间，恢复存储管理信息。</li>
<li>恢复被选中进程的SP值到处理器寄存器SP。</li>
<li>恢复被选中进程的现场信息进入处理器。</li>
<li>(中断返回指令触发)逆向模式转换并弹出PSW／PC。</li>
</ol>
<hr>
<h3><span id="linux的进程控制块pcb">linux的进程控制块(PCB)</span></h3><blockquote>
<p>ps aux 查看所有的进程信息</p>
<p>ps aux | grep name 查看名字为name的进程</p>
</blockquote>
<p>进程控制块(PCB)是系统为了管理进程设置的一个专门的数据结构，用它来记录<strong>进程的外部特征</strong>，描述<strong>进程的运动变化过程</strong>。系统利用PCB来控制和管理进程，所以<strong>PCB是系统感知进程存在的唯一标志</strong>。进程与PCB是一一对应的。在不同的操作系统中对进程的控制和管理机制不同，PCB中的信息多少不一样。</p>
<p>通常PCB应包含如下一些信息：</p>
<ol>
<li>进程标识符 <strong>name</strong>：每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字(PID)。</li>
<li>进程当前状态 <strong>status</strong>：说明进程当前所处的状态。为了管理的方便，系统设计时会<strong>将相同的状态的进程组成一个队列</strong>，如<strong>就绪进程队列</strong>，等待进程则要<strong>根据等待的事件组成多个等待队列</strong>，如等待打印机队列、等待磁盘I/O完成队列等等。</li>
<li><p>进程相应的<strong>程序和数据地址</strong>，以便把PCB与其程序和数据联系起来。</p>
</li>
<li><p><strong>进程资源清单</strong>。列出所拥有的除CPU外的资源记录，如拥有的I/O设备，打开的文件列表等。</p>
</li>
<li><p>进程优先级 <strong>priority</strong>：进程的优先级反映进程的紧迫程度，通常由用户指定和系统设置。</p>
</li>
<li><p>CPU现场保护区 <strong>cpustatus</strong>：当进程因某种原因不能继续占用CPU时（如等待打印机），释放CPU，这时就要<strong>将CPU的各种状态信息保护起来</strong>，为将来再次得到处理机恢复CPU的各种状态，继续运行。</p>
</li>
<li><p><strong>进程同步与通信机制</strong>：用于实现进程间互斥、同步和通信所需的信号量等。</p>
</li>
<li><strong>进程所在队列PCB的链接字</strong>：根据进程所处的现行状态，进程相的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。</li>
<li>与进程有关的<strong>其他信息</strong>：如进程记账信息，进程占用CPU的时间等。</li>
</ol>
<p>在linux中每一个进程都由<strong>task_struct</strong> 数据结构来定义， <strong>task_struct</strong>就是我们通常所说的<strong>PCB</strong>。<strong>task_struct</strong>存在 <code>/include/ linux/sched.h</code> 中，其中包括管理进程所需的各种信息。早期的Linux版本最多可同时运行进程的个数由 <code>NR_TASK</code> (缺省值为 <code>512</code> )规定，<code>NR_TASK</code> 即为PCB结果数组的长度。<strong>近期版本中的PCB组成一个环形链表结构，系统中所有的进程连成一个双向循环链表</strong>，其根是<strong>init_task</strong>，在创建一个新进程时，系统在内存中申请一个空的 <code>task_struct</code> 区，即空闲PCB块，并填入所需信息。同时将指向该结构的指针填入到 <code>task[]</code> 数组中。当前处于运行状态进程的PCB用指针数组 <code>current_set[]</code> 来指出。这是因为Linux支持多处理机系统，系统内可能存在多个同时运行的进程，故<strong>current_set</strong>定义成指针数组。<br>Linux系统的PCB包括很多参数，每个PCB约占<strong>1KB</strong>多的内存空间。用于表示PCB的结构<strong>task_struct</strong>简要描述如下</p>
<p>我看到的linux内核的版本是下面这个blog中的：</p>
<p><a href="https://blog.csdn.net/gatieme/article/details/51383272" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/51383272</a></p>
<hr>
<h3><span id="linux-rcu机制内核同步机制">Linux RCU机制(内核同步机制)</span></h3><p><a href="https://www.cnblogs.com/qcloud1001/p/7755331.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcloud1001/p/7755331.html</a></p>
<p><strong>RCU(Read-Copy Update)</strong>，是 Linux 中比较重要的一种同步机制。顾名思义就是“读，拷贝更新”，再直白点是“随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”。这是 Linux 内核实现的一种针对<strong>读多写少</strong>的共享数据的同步机制。RCU是Linux内核一个非常关键的<strong>锁原语</strong>，其提供了一种<code>lockless</code> 机制，适合于这种场景：</p>
<ul>
<li>高频读低频写</li>
<li>对数据没有强一致性要求</li>
</ul>
<p>不同于其他的同步机制，它允许多个读者同时访问共享数据，而且读者的性能不会受影响（“随意读”），读者与写者之间也不需要同步机制（但需要“复制后再写”），但如果存在多个写者时，在写者把更新后的“副本”覆盖到原数据时，写者与写者之间需要利用其他同步机制保证同步。</p>
<p><strong>RCU</strong> 的一个典型的应用场景是链表，在 Linux kernel 中还专门提供了一个头文件（include/linux/rculist.h），提供了利用 RCU 机制对链表进行增删查改操作的接口。</p>
<h4><span id="增加链表项">增加链表项</span></h4><p>Linux kernel 中利用 RCU 往链表增加项的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_next_rcu(list)     (*((struct list_head __rcu **)(&amp;(list)-&gt;next)))</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add_rcu(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                struct list_head *prev, struct list_head *next) &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">        rcu_assign_pointer(list_next_rcu(prev), <span class="keyword">new</span>);</span><br><span class="line">        next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="访问链表项">访问链表项</span></h4><p>Linux kernel 中访问 RCU 链表项常见的代码模式是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();</span><br><span class="line">list_for_each_entry_rcu(pos, head, member) &#123;</span><br><span class="line">    <span class="comment">// do something with `pos`</span></span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br></pre></td></tr></table></figure>
<p>这里要讲到的 <code>rcu_read_lock()</code> 和 <code>rcu_read_unlock()</code>，是 RCU 随意读 的关键，它们的效果是声明了一个读端的临界区（read-side critical sections）。多个读端临界区不互斥，即多个读者可同时处于读端临界区中，但一块内存数据一旦能够在读端临界区内被获取到指针引用，这块内存块数据的释放必须等到读端临界区结束，等待读端临界区结束的 Linux kernel API 是 <code>synchronize_rcu()</code> 。读端临界区的检查是全局的，系统中有任何的代码处于读端临界区，<code>synchronize_rcu()</code> 都会阻塞，知道所有读端临界区结束才会返回。为了直观理解这个问题，举以下的代码实例：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* `p` 指向一块受 RCU 保护的共享数据 */</span></span><br><span class="line"><span class="comment">/* reader */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">p1 = rcu_dereference(p);</span><br><span class="line"><span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    printk(<span class="string">"%d\n"</span>, p1-&gt;field);</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="comment">/* free the memory */</span></span><br><span class="line">p2 = p;</span><br><span class="line"><span class="keyword">if</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    synchronize_rcu();</span><br><span class="line">    kfree(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用以下图示来表示多个读者与内存释放线程的时序关系：</p>
<p><img src="https://blog-10039692.file.myqcloud.com/1508828310237_5629_1508828349049.png" alt="img"></p>
<p>上图中，每个读者的方块表示获得 p 的引用（第5行代码）到读端临界区结束的时间周期；t1 表示 p = NULL 的时间；t2 表示 synchronize_rcu() 调用开始的时间；t3 表示 synchronize_rcu() 返回的时间。我们先看 Reader1,2,3，虽然这 3 个读者的结束时间不一样，但都在 t1 前获得了 p 地址的引用。t2 时调用 synchronize_rcu()，这时 Reader1 的读端临界区已结束，但 Reader2,3 还处于读端临界区，因此必须等到 Reader2,3 的读端临界区都结束，也就是 t3，t3 之后，就可以执行 kfree(p2) 释放内存。synchronize_rcu() 阻塞的这一段时间，有个名字，叫做 Grace period。而 Reader4,5,6，无论与 Grace period 的时间关系如何，由于获取引用的时间在 t1 之后，都无法获得 p 指针的引用，因此不会进入 p1 != NULL 的分支。</p>
<h4><span id="更新链表项">更新链表项</span></h4><p>前文提到，RCU 的更新机制是 “Copy Update”，RCU 链表项的更新也是这种机制，典型代码模式是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = search_the_entry_to_update();</span><br><span class="line">q = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">*q = *p;</span><br><span class="line">q-&gt;field = new_value;</span><br><span class="line">list_replace_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line">synchronize_rcu();</span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure>
<p>其中第 3,4 行就是复制一份副本，并在副本上完成更新，然后调用 <code>list_replace_rcu()</code> 用新节点替换掉旧节点，最后释放旧节点内存。<code>list_replace_rcu()</code> 源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_replace_rcu</span><span class="params">(struct list_head *old,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct list_head *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = old-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = old-&gt;prev;</span><br><span class="line">    rcu_assign_pointer(list_next_rcu(<span class="keyword">new</span>-&gt;prev), <span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    old-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="孤儿进程僵尸进程">孤儿进程/僵尸进程</span></h3><ul>
<li><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<strong>init</strong>进程(进程号为1)所收养，并由<strong>init</strong>进程对它们完成状态收集工作。</li>
<li><strong>僵尸进程</strong>：一个进程使用<strong>fork</strong>创建子进程，如果子进程退出，而父进程并没有调用 <code>wait</code> 或 <code>waitpid</code> 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li>
</ul>
<h4><span id="问题及危害">问题及危害</span></h4><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
<h4><span id="waitwaitpid函数">wait/waitpid函数</span></h4><p><code>wait</code> 、<code>waitpid</code> 函数由父进程调用来读取子进程的返回信息，使子进程完全终止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br></pre></td></tr></table></figure>
<p><code>wait</code> 函数会在父进程中阻塞，等待子进程结束，如果子进程结束，则返回子进程的 <code>PID</code> 。如果没有子进程则立刻返回 <code>-1</code> 。父进程调用 <code>wait</code> 函数可以回收子进程终止信息。该函数有三个功能：</p>
<ol>
<li>阻塞等待子进程退出</li>
<li>回收子进程残留资源</li>
<li>获取子进程结束状态(退出原因)。</li>
</ol>
<p><code>wait</code> 一旦被调用，就会一直<strong>阻塞</strong>在这里，直到有一个子进程退出出现为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p><code>waitpid</code> 函数等待子进程结束（options设置为WNOHANG时为非阻塞），如果子进程结束，则返回子进程的 <code>PID</code> 。如果没有子进程则立刻返回 <code>-1</code> ，如果是非阻塞的并且子进程还没有结束，则返回 <code>0</code> 。</p>
<p>由于这两个函数会阻塞等待（非阻塞时也需要轮询执行），所以常规使用方式为：当子进程退出时会给父进程发送 <code>SIGCHID</code> 信号，因此父进程捕获 <code>SIGCHID</code> 信号，并在信号处理函数中调用 <code>waitpid</code> 函数来结束一个子进程。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>   pid;</span><br><span class="line">    <span class="keyword">int</span>     stat;</span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child %d terminated\n"</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">signal(SIGCHLD, sig_chld);</span><br></pre></td></tr></table></figure>
<p>如果有多个子进程，则任意一个子进程结束时，wait函数就会返回，所以此时<strong>可以循环判断wait返回-1时（另外返回-1时，errno 等于EINTR时表示中断，所以此时需要继续循环等待），才表示所有子进程都退出了</strong>。</p>
<h4><span id="孤儿进程解决办法">孤儿进程解决办法</span></h4><p>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了<strong>init</strong>进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。<strong>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程</strong>。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
<p>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<h4><span id="僵尸进程解决办法">僵尸进程解决办法</span></h4><ol>
<li><p><strong>通过信号机制：</strong></p>
<p>子进程退出时向父进程发送<strong>SIGCHILD</strong>信号，父进程处理<strong>SIGCHILD</strong>信号。在信号处理函数中调用 <code>wait</code> 进行处理僵尸进程。</p>
</li>
<li><p><strong>fork两次：</strong></p>
<p>《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为<strong>init</strong>进程，通过<strong>init</strong>进程可以处理僵尸进程。</p>
</li>
</ol>
<hr>
<h3><span id="写时复制cow">写时复制(COW)</span></h3><p>在Linux程序中，<code>fork()</code> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <code>exec</code> 系统调用，出于效率考虑，linux中引入了<strong>写时复制</strong>技术，也就是<strong>只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</strong><code>fork()</code> 函数实质上是按着写时拷贝的方式实现文件的映射，并不是共享，写时拷贝操作使得内存的需求量大大的减少了。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012072020252592.jpg" alt="img"></p>
<p>传统的 <code>fork()</code> 系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的 <code>fork()</code> 使用写时拷贝(<code>copy-on-write</code>)页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。<strong>内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个物理地址空间</strong>。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。</p>
<p>在<strong>fork()</strong>时，为了内核为新进程创建各种数据结构，并分配给它一个唯一的 <code>PID</code> ，为了给这个新进程创建虚拟内存，它创建了当前进程的<strong>mm_struct</strong>、<strong>区域结构</strong>和<strong>页表的原样副本</strong>。它将<strong>两个进程中的每个页面都标记为只读</strong>，并将两个进程中的每个区域结构都标记为私有的<strong>写时复制</strong>。</p>
<p><strong>那么子进程的物理空间没有代码，怎么去取指令执行 <code>exec</code> 系统调用呢？</strong></p>
<p>执行 <code>exec</code> 系统调用，一般都是这样，用 <code>fork()</code> 函数新建立一个进程，然后让进程去执行 <code>exec</code> 调用。在 <code>fork</code> 之后 <code>exec</code> 之前两个进程用的是<strong>相同的物理空间（内存区）</strong>，子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为 <code>exec</code> ，内核会给<strong>子进程的数据段、堆栈段分配相应的物理空间</strong>（至此两者有各自的进程空间，互不影响），而<strong>代码段继续共享父进程的物理空间</strong>（两者的代码完全相同）。而如果是因为 <code>exec</code> ，由于两者执行的代码不同，<strong>子进程的代码段也会分配单独的物理空间</strong>。</p>
<p>一个进程一旦调用 <code>exec</code> 类函数，它本身就 <code>死亡</code> 了，系统<strong>把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段</strong>，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。（不过 <code>exec</code> 类函数中有的还允许继承环境变量之类的信息。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"a.out"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码会在当前进程加载并运行包含在可执行目标文件 <code>a.out</code> 中的程序，用 <code>a.out</code> 程序有效地替代了当前程序，主要有以下几个步骤：</p>
<ul>
<li><strong>删除已存在的用户区域</strong></li>
<li><strong>映射私有区域</strong><ul>
<li>为新程序的代码、数据、<code>bss</code> 和栈区创建新的区域结构</li>
<li>所有的这些新的区域都是私有的、写时复制的。</li>
<li>代码和数据区域映射到 <code>.text</code> 和 <code>.data</code>，<code>bss</code> 区域是请求二进制零的，映射到匿名文件</li>
</ul>
</li>
<li><strong>映射共享区域</strong><ul>
<li>如果 <code>a.out</code> 与共享对象链接，如标准C库 <code>libc.so</code> ，那么这些对象都会动态连接到这个程序</li>
<li>然后再映射到用户虚拟地址空间中的共享区域内。</li>
</ul>
</li>
<li><strong>设置程序计数器(PC)</strong><ul>
<li>设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</li>
</ul>
</li>
</ul>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613564872855.png" alt="1613564872855"></p>
<h4><span id="exec族函数">exec族函数</span></h4><p><code>exec</code> 函数族的作用是根据指定的文件名找到可执行文件，并用他来取代系统调用的内容，也就是说在调用进程内部执行一个可执行文件（二进制或脚本），改变进程的内存映像并运行一个新的程序。</p>
<p>这6个函数中真正的系统调用只有 <code>execve</code> ，其他5个都是库函数，它们最终都会调用 <code>execve</code> 这个系统调用</p>
<table>
<thead>
<tr>
<th>前4位</th>
<th>统一为：exec</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>第5位</td>
<td>l：参数传递为逐个列举方式</td>
<td>execl、execle、execlp</td>
</tr>
<tr>
<td></td>
<td>v：参数传递为构造指针数组方式</td>
<td>execv、execve、execvp</td>
</tr>
<tr>
<td>第6位</td>
<td>e：可传递新进程环境变量</td>
<td>execle、execve</td>
</tr>
<tr>
<td></td>
<td>p：可执行文件查找方式为文件名</td>
<td>execlp、execvp</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg,...,<span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="comment">//以p结尾的两个函数可以只给出文件名，系统就会自动从环境变量“$PATH”所指出的路径中进行查找。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],<span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>exec</code> 函数执行成功后不返回，因为调用进程的实体，包括代码段、数据段、栈堆等都被替换，只保留进程ID等表面信息为变。成功函数不会返回，只有调用失败才会返回 <code>-1</code> ，从原程序的调用点接着往下走。（exec相对于其他系统调用来说易受伤，要加判断，如 <code>errno</code> 置为 <code>ENOENT</code> 表示找不到文件或路径）</p>
<p><strong>主要有以下两种情况：</strong></p>
<ol>
<li>某进程认为自己无用了，还可以发挥一点余热，调用一个 <code>exec</code> 让自己换个灵魂重生。</li>
<li>某个进程想执行另外的程序，可以 <code>fork(vfork)</code> 出一个新进程，然后调用 <code>exec</code> 。(普遍)</li>
</ol>
<p><strong>fork和Vfork的区别：</strong></p>
<ul>
<li><code>fork</code> 会将调用进程的所有内容原封不动的拷贝到子进程，拷贝耗时较多。</li>
<li><code>vfork</code> 后不会立即拷贝，内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间，当然了，这种做法就顺水推舟的共享了父进程的物理空间；而是到真正用时才拷贝(写时拷贝)，保证子进程先运行，<code>exec</code> 或 <code>exit</code> 前在父进程地址空间运行，<code>exec</code> 后才会有自己的进程空间。</li>
</ul>
<p>对于 <code>exec</code> 来说，<code>fork</code> 后拷贝的父进程内容会被马上替换，造成浪费。而如果 <code>vfork</code> 后马上 <code>exec</code> 就不会出现这种情况。</p>
<p>经典的 <code>fork()</code> 使用场景如下：如果是子进程的话 <code>fork()</code> 结果为 <code>0</code> ，父进程 <code>fork()</code> 返回的是子进程的<strong>PID</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="comment">/* 一直循环下去 */</span></span><br><span class="line"><span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">    <span class="comment">/* 在屏幕上显示提示符 */</span></span><br><span class="line">    type_prompt();</span><br><span class="line">    <span class="comment">/* 从中断读取输入 */</span></span><br><span class="line">    read_command(command,parameters)</span><br><span class="line">    <span class="comment">/* fork 子进程 */</span></span><br><span class="line">    <span class="keyword">if</span>(fork() != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* 父代码 */</span></span><br><span class="line">        <span class="comment">/* 等待子进程执行完毕 */</span></span><br><span class="line">        waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* 执行命令 */</span></span><br><span class="line">        <span class="comment">/* 子代码*/</span></span><br><span class="line">        execve(command,parameters,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="进程中的环境变量说明">进程中的环境变量说明</span></h4><p>在Linux中，<strong>Shell进程是所有执行码的父进程</strong>。当一个执行码执行时，Shell进程会 <code>fork</code> 子进程然后调用 <code>exec</code> 函数去执行执行码。Shell进程堆栈中存放着该用户下的所有环境变量，使用 <code>execl</code> 、<code>execv</code> 、<code>execlp</code> 、<code>execvp</code> 函数使执行码重生时，Shell进程会<strong>将所有环境变量复制给生成的新进程</strong>；而使用 <code>execle</code> 、<code>execve</code> 时新进程不继承任何Shell进程的环境变量，而由 <code>envp[]</code> 数组自行设置环境变量。</p>
<h4><span id="如果一个进程2gb-fork-之后这两个进程占用多少内存">如果一个进程2GB， fork 之后这两个进程占用多少内存？</span></h4><p>还是 <code>2GB</code> ，或者是比 <code>2GB</code> 略大一点点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">      fork();</span><br><span class="line">      <span class="comment">//注意：下面的printf有“n”</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"ppid=%d, pid=%d, i=%d n"</span>, getppid(), getpid(), i);</span><br><span class="line">   &#125;</span><br><span class="line">   sleep(<span class="number">10</span>); <span class="comment">//让进程停留十秒，这样我们可以用pstree查看一下进程树</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ppid=8858, pid=8518, i=0</span><br><span class="line">ppid=8858, pid=8518, i=1</span><br><span class="line">ppid=8518, pid=8519, i=0</span><br><span class="line">ppid=8518, pid=8519, i=1</span><br><span class="line">ppid=8518, pid=8520, i=1</span><br><span class="line">ppid=8519, pid=8521, i=1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pstree -p | grep fork</span></span><br><span class="line">|-bash(8858)-+-fork(8518)-+-fork(8519)---fork(8521)</span><br><span class="line">|            |            `-fork(8520)</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="进程线程的上下文">进程/线程的上下文</span></h3><h4><span id="进程的上下文可以分为哪几个部分">进程的上下文可以分为哪几个部分？</span></h4><ul>
<li><strong>用户级上下文</strong>：正文、数据、用户堆栈以及共享存储区；</li>
<li><strong>寄存器上下文</strong>：通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
<li><strong>系统级上下文</strong>：进程控制块(task_struct)、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
</ul>
<h4><span id="为什么切换线程比切换进程开销小">为什么切换线程比切换进程开销小</span></h4><p>一个程序进行起来后，会使用很多资源，比如使用寄存器，内存，文件等。每当切换进程时，必须要考虑保存当前进程的状态。状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开的文件描述符的集合，这个状态叫做上下文。可见，想要切换进程，保存的状态有很多。</p>
<p>线程是运行在进程上下文中的逻辑流，线程有自己的上下文，包括唯一的<strong>整数线程ID， 栈、栈指针、程序计数器、通用目的寄存器和条件码</strong>等等，线程的上下文是进程的自己，因此在线程切换的时候需要保存和恢复的上下文比线程要少很多，开销也就更小。</p>
<hr>
<h3><span id="多线程间通信和同步">多线程间通信和同步</span></h3><ul>
<li>锁机制：包括互斥锁/量（<code>mutex</code>）、读写锁（ <code>reader-writer lock</code> ）、自旋锁（ <code>spin lock</code> ）、条件变量（ <code>condition variable</code> ）<ul>
<li>互斥锁/量（<code>mutex</code>）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（<code>reader-writer lock</code>）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（<code>spin lock</code>）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（<code>condition</code> ）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。<strong>条件变量始终与互斥锁一起使用</strong>。</li>
</ul>
</li>
<li>信号量机制( <code>Semaphore</code> )<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制( <code>Signal</code> )：类似进程间的信号处理</li>
<li>屏障（ <code>barrier</code> ）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于<strong>线程同步</strong>，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<hr>
<h3><span id="进程的切换时机">进程的切换时机</span></h3><h4><span id="切换时需要保存哪些数据">切换时需要保存哪些数据？</span></h4><hr>
<h3><span id="协程">⭐协程</span></h3><p><strong>什么是协程</strong></p>
<p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。在C++20中出现了<strong>coroutine</strong>的库。协程的作用是在<strong>同一个线程中通过保存代码执行段状态，进行代码段的分次执行，以及多个代码段的交织执行</strong>。每个代码段可以成为一个协程。协程的好处是<strong>避免了线程之间的频换切换</strong>、<strong>以及线程安全的优化</strong>（对于同一个变量的访问无需做同步控制）。</p>
<p><strong>协程是非抢占式的，线程是抢占式的。</strong></p>
<p>平时正常的程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。而协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg" alt="img"></p>
<p>协程不是被操作系统内核所管理的，而是<strong>完全由程序所控制</strong>，也就是在<strong>用户态</strong>执行。这样带来的好处是<strong>性能大幅度的提升</strong>，因为不会像线程切换那样消耗资源。</p>
<p>协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p>一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以有多个这样的特殊函数在运行，但是有一点必须明确的是：</p>
<blockquote>
<p><strong>一个线程的多个协程的运行是串行的</strong>。</p>
</blockquote>
<p>如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。<strong>当一个协程运行时，其它协程必须挂起</strong>。</p>
<p>C/C++ 语言本身是不能天然支持协程的。现有的 C++ 协程库均基于两种方案：<strong>利用汇编代码控制协程上下文的切换，以及利用操作系统提供的 API 来实现协程上下文切换</strong>。</p>
<p>在C++里，一个函数如果其函数体实现中包含 <code>co_await</code> 、<code>co_yield</code> 、<code>co_return</code> 中任何一个关键字，那么这个函数就是一个coroutine。其中：</p>
<ol>
<li><code>co_await</code>：挂起当前的coroutine。</li>
<li><code>co_return</code>：从当前coroutine返回一个结果。</li>
<li><code>co_yield</code>：返回一个结果并且挂起当前的coroutine。</li>
</ol>
<h4><span id="libco库">libco库</span></h4><ul>
<li><p><code>co_create_env()</code> 创建协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stStackMem_t</span> &#123;</span></span><br><span class="line">    stCoRoutine_t* occupy_co;  <span class="comment">// 使用该栈的协程</span></span><br><span class="line">    <span class="keyword">int</span> stack_size;            <span class="comment">// 栈大小</span></span><br><span class="line">    <span class="keyword">char</span>* stack_bp;            <span class="comment">// 栈底指针，栈从高地址向低地址增长</span></span><br><span class="line">    <span class="keyword">char</span>* stack_buffer;        <span class="comment">// 栈底</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_resume()</code> 激活协程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">( stCoRoutine_t *co )</span> </span>&#123;</span><br><span class="line">    stCoRoutineEnv_t *env = co-&gt;env;</span><br><span class="line">    <span class="comment">// 获取当前正在运行的协程的结构</span></span><br><span class="line">    stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    <span class="keyword">if</span>( !co-&gt;cStart ) &#123;</span><br><span class="line">        <span class="comment">// 为将要运行的 co 布置上下文环境</span></span><br><span class="line">        coctx_make( &amp;co-&gt;ctx,(<span class="keyword">coctx_pfn_t</span>)CoRoutineFunc,co,<span class="number">0</span> );</span><br><span class="line">        co-&gt;cStart = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;pCallStack[ env-&gt;iCallStackSize++ ] = co;  <span class="comment">// 设置co为运行的线程</span></span><br><span class="line">    co_swap( lpCurrRoutine, co );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>co_swap()</code> 实现上下文切换，<code>co_swap</code> 具体完成三项工作：</p>
<ol>
<li>记录当前协程 <code>curr</code> 的运行栈的栈顶指针，通过 <code>char c; curr_stack_sp=&amp;c</code> 实现，当下次切换回 <code>curr</code>时，可以从该栈顶指针指向的位置继续，执行完 <code>curr</code> 后可以顺利释放该栈。</li>
<li>处理共享栈相关的操作，并且调用函数 <code>coctx_swap</code> 来完成上下文环境的切换。注意执行完 <code>coctx_swap</code>之后，执行流程将跳到新的 coroutine 也就是 pending_co 中运行，后续的代码需要等下次切换回 <code>curr</code> 时才会执行。</li>
<li>当下次切换回 <code>curr</code> 时，处理共享栈相关的操作。</li>
</ol>
</li>
<li><p>对应于 <code>co_resume</code> 函数，协程主动让出执行权则调用 <code>co_yield</code> 函数。<code>co_yield</code> 函数调用了 <code>co_yield_env</code>，将当前协程与当前线程中记录的其他协程进行切换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_env</span><span class="params">( stCoRoutineEnv_t *env )</span> </span>&#123;</span><br><span class="line">    stCoRoutine_t *last = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">2</span> ];</span><br><span class="line">    stCoRoutine_t *curr = env-&gt;pCallStack[ env-&gt;iCallStackSize - <span class="number">1</span> ];</span><br><span class="line">    env-&gt;iCallStackSize--;</span><br><span class="line">    co_swap( curr, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3><span id="五种io模型">五种IO模型</span></h3><p><strong>阻塞IO(BIO)、非阻塞IO(NIO)、IO多路复用、信号驱动IO以及异步IO(AIO)</strong></p>
<p>首先一个 <code>IO</code> 操作其实分成了两个步骤：</p>
<ol>
<li><strong>等待数据：</strong>用户进程向内核发起 <code>IO</code> 请求，等待内核数据准备</li>
<li><strong>数据拷贝：</strong>实际的 <code>IO</code> 操作,将数据从内核拷贝到进程缓存区中 </li>
</ol>
<p>阻塞IO和非阻塞IO的区别在于第一步，当这次<strong>CPU COPY</strong>不能立即成功时，采取怎样的策略。阻塞IO就是一直等，比如等缓冲区非空、缓冲区非满等等状态达成。而非阻塞IO就是不等了，这次不行就下次再来。</p>
<p>同步IO和异步IO的区别就在于第二个步骤是否阻塞。如果实际的IO读写阻塞请求进程，那么就是同步IO，因此后面可以看到<strong>阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO</strong>；如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。</p>
<p>访问数据的方式：同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。</p>
<p>而非阻塞IO就是不等了，这次不行就下次再来。</p>
<p><img src="https://img-blog.csdn.net/20161028200140849" alt="img"></p>
<hr>
<h4><span id="阻塞iobio">阻塞IO(BIO)</span></h4><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p>
<p><img src="https://img-blog.csdn.net/20161028200138896" alt="img"></p>
<p>特点：</p>
<ol>
<li><strong>进程阻塞挂起不消耗CPU资源，及时响应每个操作</strong>；</li>
<li>实现难度低、开发应用较容易；</li>
<li>适用并发量小的网络应用开发；</li>
<li><strong>不适用并发量大的应用</strong>：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</li>
</ol>
<hr>
<h4><span id="非阻塞ionio">非阻塞IO(NIO)</span></h4><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p>
<p><img src="https://img-blog.csdn.net/20161028200139219" alt="img"></p>
<p>典型应用：<strong>socket</strong>是非阻塞的方式（设置为NONBLOCK）</p>
<p><strong>阻塞IO模型是一个阻塞IO调用，而非阻塞IO模型是多个非阻塞IO调用+一个阻塞IO调用，因为多个IO检查会立即返回错误，不会阻塞进程。</strong></p>
<p>特点：</p>
<ol>
<li><strong>进程轮询（重复）调用，消耗CPU的资源</strong>；</li>
<li>实现难度低、开发应用相对阻塞IO模式较难；</li>
<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>
</ol>
<hr>
<h4><span id="io多路复用">IO多路复用</span></h4><p>多个的进程的IO可以注册到一个复用器(<code>select</code>)上，然后用一个进程调用该 <code>select</code> ， <code>select</code> 会监听所有注册进来的IO；如果 <code>select</code> 监听的IO在内核缓冲区都没有可读数据，<code>select</code> 调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，<code>select</code> 调用就会返回；而后 <code>select</code> 调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。可以看到，<strong>多个进程注册IO后，只有另一个select调用进程被阻塞。</strong></p>
<p><img src="https://img-blog.csdn.net/20161028200139703" alt="img"></p>
<p><strong>典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;</strong></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>专一进程解决多个进程IO的阻塞问题，性能好</strong>；<strong>Reactor模式;</strong></li>
<li>实现、开发应用难度较大；</li>
<li><strong>适用高并发服务应用开发：一个进程（线程）响应多个请求</strong>；</li>
</ol>
<hr>
<h4><span id="信号驱动的io模型sigio">信号驱动的IO模型(SIGIO)</span></h4><p>当进程发起一个IO操作，会向内核注册一个<strong>信号处理函数</strong>，然后进程<strong>返回不阻塞</strong>；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p>
<p><img src="https://img-blog.csdn.net/20161028200140021" alt="img"></p>
<p><strong>特点：回调机制，</strong>实现、开发应用难度大；</p>
<hr>
<h4><span id="异步io模型aio非阻塞">异步IO模型(AIO)(非阻塞)</span></h4><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。<strong>如果IO操作成功则进程直接获取到数据</strong>。</p>
<p><img src="https://img-blog.csdn.net/20161028200140375" alt="img"></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>不阻塞，数据一步到位</strong>；<strong>Proactor模式</strong>；</li>
<li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>
<li>实现、开发应用难度大；</li>
<li>非常适合高性能高并发应用；</li>
</ol>
<hr>
<h3><span id="两种io事件处理模式">两种IO事件处理模式</span></h3><h4><span id="reactor模式同步的">Reactor模式(同步的)</span></h4><p>读取操作：</p>
<ol>
<li>应用程序注册读就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件的发生</li>
<li>当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器</li>
<li>事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190915131156673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>用<strong>Reactor</strong>模式的一个实现方案是：</p>
<ol>
<li>在<strong>Reactor</strong>中注册好感兴趣的事件(IO事件 信号 定时器)</li>
<li>用一个主线程(IO处理单元)负责监听文件描述符上的是否有事件发生除此之外它不做别的实质性的工作 ,采用<strong>io复用</strong>的形式 比如用select epoll  poll这些.</li>
<li>当发生了对应事件  主线程就通知工作进程 (通过请求队列)</li>
<li>在工作线程(逻辑单元)中读写数据  接受新的连接 处理客户请求等等 </li>
</ol>
<hr>
<h4><span id="proactor模式-异步">Proactor模式 (异步)</span></h4><p><img src="https://img-blog.csdnimg.cn/20190915142010343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的：</p>
<ul>
<li><strong>Reactor模式</strong>中需要应用程序自己读取或者写入数据，真正执行IO操作的(也就是从内核区读取io数据到缓存区的这一步)是事件处理器自身，也就是说在io操作的第二阶段应用程序是阻塞的，所以我们说<strong>Reactor模式是同步的</strong> </li>
<li><strong>Proactor模式</strong>中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备。</li>
</ul>
<hr>
<h3><span id="io多路复用selectpollepoll同步阻塞">⭐IO多路复用：select/poll/epoll(同步/阻塞)</span></h3><p>在计算机领域常说的 <code>I/O</code> 包括磁盘 <code>I/O</code> 和网络 <code>I/O</code> ，我们所说的 <code>I/O</code> 复用主要是指网络 <code>I/O</code> ，在 <code>Linux</code> 中一切皆文件，因此网络 <code>I/O</code> 也经常用文件描述符 <code>FD</code> 来表示。</p>
<p>所谓 <code>I/O</code> 多路复用指的是这样一个过程：</p>
<ol>
<li>我们拿到了一堆文件描述符 <code>fd</code> (不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)</li>
<li>通过调用<strong>某个函数</strong>告诉内核：“<strong>这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回</strong>”</li>
<li>当调用的这个函数返回后我们就能知道哪些文件描述符可以进行 <code>I/O</code> 操作了。</li>
</ol>
<p>也就是说<strong>通过I/O多路复用我们可以同时处理多路I/O</strong>，协调多个可释放资源的 <code>FD</code> <strong>交替共享任务处理线程</strong>完成<strong>通信任务</strong>，实现多个 <code>FD</code> 对应<strong>1</strong>个任务处理线程。。</p>
<p><code>select</code> ， <code>poll</code> ，<code>epoll</code> 都是 <code>IO</code> 多路复用的机制。<code>I/O</code> 多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步 <code>I/O</code> 则无需自己负责进行读写，异步 <code>I/O</code> 的实现会负责把数据从内核拷贝到用户空间。</p>
<p><code>I/O</code> 多路复用是指内核一旦发现进程指定的一个或者多个 <code>I/O</code> 条件准备读取，它就通知该进程。<code>I/O</code>多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述字时（一般是<strong>交互式输入</strong>和<strong>网络套接口</strong>），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
</ol>
<p><strong>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</strong></p>
<p><strong>select的几大缺点：</strong></p>
<ol>
<li><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></li>
<li><strong>同时每次调用select都需要在内核遍历O(n)地遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></li>
<li><strong>select支持的文件描述符数量太小了，32位默认是1024，64位是2048</strong></li>
<li><p><strong>每次完成监控需要再次重新传入并且分事件传入 操作冗余</strong></p>
<p><code>poll</code> 的实现和 <code>select</code> 非常相似，只是描述 <code>fd</code> 集合的方式不同，<code>poll</code> 使用 <code>pollfd</code> 结构而不是 <code>select</code> 的<code>fd_set</code> 结构，其他的都差不多。</p>
</li>
<li><p><strong>select 时间复杂度O(n)</strong></p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
</li>
<li><p><strong>poll 时间复杂度O(n)</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，但是同样有一个缺点：</p>
<p>1、大量的 <code>fd</code> 的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   </p>
<p>2、<code>poll</code> 还有一个特点是<strong>水平触发</strong>，如果报告 <code>fd</code> 后，没有被处理，那么下次 <code>poll</code> 时会再次报告该 <code>fd</code> 。</p>
</li>
<li><p><strong>epoll 时间复杂度O(1)</strong></p>
<p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，<code>epoll</code> 会把哪个流发生了怎样的I/O事件通知我们。所以我们说 <code>epoll</code> 实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
</li>
</ol>
<hr>
<h4><span id="select">select</span></h4><p><img src="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png" alt="img"></p>
<p><code>select</code> 使用一个宏定义函数按照 <code>bitmap</code> 原理填充 <code>fd</code> ，默认大小是 <code>1024</code> 个，因此对于 <code>fd</code> 的数值大于 <code>1024</code> 都可能出现问题。</p>
<p><img src="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png" alt="img"></p>
<p> <code>select</code> 函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：就绪描述符的数目，超时返回 <code>0</code> ，出错返回 <code>-1</code> 。</p>
<p>函数参数介绍如下：</p>
<ol>
<li>第一个参数 <code>maxfdp1</code> 指定待测试的描述字个数，它的值是待测试的最大描述字加 <code>1</code> （因此把该参数命名为<code>maxfdp1</code> ），描述字 <code>0、1、2...maxfdp1 - 1</code> 均将被测试。因为文件描述符是从 <code>0</code> 开始的。</li>
<li>中间的三个参数 <code>readset</code> 、<code>writeset</code> 和 <code>exceptset</code> 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code> 可以理解为一个集合，这个集合中存放的是<strong>文件描述符FD</strong>，可通过以下四个宏进行设置：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 检查集合中指定的文件描述符是否可以读写</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>timeval *timeout</code> 告知内核等待所指定描述字中的任何一个就绪可花多少时间。其 <code>timeval</code> 结构用于指定这段时间的秒数和微秒数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个参数有三种可能：</p>
<p>（1）永远等待下去：仅在有一个描述字准备好 <code>I/O</code> 时才返回。为此，把该参数设置为空指针 <code>NULL</code> 。</p>
<p>（2）等待一段固定时间：在有一个描述字准备好 <code>I/O</code> 时返回，但是不超过由该参数所指向的 <code>timeval</code> 结构中指定的秒数和微秒数。</p>
<p>（3）根本不等待：检查描述字后立即返回，这称为<strong>轮询</strong>。为此，该参数必须指向一个 <code>timeval</code> 结构，而且其中的定时器值必须为 <code>0</code> 。</p>
<hr>
<h4><span id="poll">poll</span></h4><p><strong>“选举出来，立刻返回”</strong></p>
<p><code>poll</code> 的机制与 <code>select</code> 类似，与 <code>select</code> 在本质上没有多大差别，管理多个描述符也是进行<strong>轮询</strong>，根据描述符的状态进行处理，但是 <code>poll</code> <strong>没有最大文件描述符数量的限制</strong>。<code>poll</code> 和 <code>select</code> 同样存在一个缺点就是，<strong>包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</strong></p>
<p>函数格式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pollfd</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;         	  <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents;        <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>每一个 <code>pollfd</code> 结构体指定了一个<strong>被监视的文件描述符</strong>，可以传递多个结构体，指示 <code>poll()</code> 监视多个文件描述符。每个结构体的 <code>events</code> 域是监视该文件描述符的事件掩码，由用户来设置这个域。<code>revents</code> 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。<code>events</code> 域中请求的任何事件都可能在 <code>revents</code> 域中返回。合法的事件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 　　　　　　　　有数据可读。</span><br><span class="line">POLLRDNORM 　　　　  有普通数据可读。</span><br><span class="line">POLLRDBAND　　　　　 有优先数据可读。</span><br><span class="line">POLLPRI　　　　　　　　 有紧迫数据可读。</span><br><span class="line">POLLOUT　　　　　　      写数据不会导致阻塞。</span><br><span class="line">POLLWRNORM　　　　　  写普通数据不会导致阻塞。</span><br><span class="line">POLLWRBAND　　　　　   写优先数据不会导致阻塞。</span><br><span class="line">POLLMSGSIGPOLL 　　　　消息可用。</span><br></pre></td></tr></table></figure>
<p>此外，<code>revents</code> 域中还可能返回下列事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POLLER　　   指定的文件描述符发生错误。</span><br><span class="line">POLLHUP　　 指定的文件描述符挂起事件。</span><br><span class="line">POLLNVAL　　指定的文件描述符非法。</span><br></pre></td></tr></table></figure>
<p><code>timeout</code> 参数指定等待的毫秒数，无论 <code>I/O</code> 是否准备好，<code>poll</code> 都会返回。<code>timeout</code> 指定为负数值表示无限超时，使 <code>poll()</code> 一直挂起直到一个指定事件发生；<code>timeout</code> 为 <code>0</code> 指示 <code>poll</code> 调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，<code>poll()</code> 就像它的名字那样，一旦选举出来，立即返回。</p>
<p><strong>返回值和错误代码</strong><br>成功时，<code>poll()</code> 返回结构体中 <code>revents</code> 域不为 <code>0</code> 的文件描述符个数；如果在超时前没有任何事件发生，<code>poll()</code> 返回 <code>0</code> ；失败时，<code>poll()</code> 返回 <code>-1</code> ，并设置 <code>errno</code> 为下列值之一。</p>
<hr>
<h4><span id="epoll">epoll</span></h4><p><code>epoll</code> 是在 <code>2.6</code> 内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> <strong>使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的 <code>copy</code> 只需一次。</p>
<p><code>epoll</code> 使用 <code>事件</code> 的就绪通知方式，通过 <code>epoll_ctl</code> 注册 <code>fd</code> ，一旦该 <code>fd</code> 就绪，内核就会采用类似 <code>callback</code> 的回调机制来激活该 <code>fd</code> ，<code>epoll_wait</code> 便可以收到通知。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户数据载体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">   <span class="keyword">void</span>    *ptr;</span><br><span class="line">   <span class="keyword">int</span>      fd;</span><br><span class="line">   <span class="keyword">uint32_t</span> u32;</span><br><span class="line">   <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"><span class="comment">//fd装载入内核的载体</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="keyword">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="keyword">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h5><span id="epoll-函数">epoll 函数</span></h5><p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>int epoll_create(int size);</strong><br>在内核区创建一个 <code>epoll</code> 相关的一些列结构，并且将一个句柄 <code>fd</code> 返回给用户态，后续的操作都是基于此 <code>fd</code> 的，<code>size</code> 用来告诉内核这个监听的数目一共有多大，类似于 <code>STL</code> 的 <code>vector</code> 动态数组，如果 <code>size</code> 不合适会涉及复制扩容，不过貌似 <code>4.1.2</code> 内核之后 <code>size</code> 已经没有太大用途了；这个参数不同于 <code>select()</code> 中的第一个参数，<code>select</code> 给出的是最大监听的 <code>fd+1</code> 的值。需要注意的是，当创建好 <code>epoll</code> 句柄后，它就是会占用一个 <code>fd</code> 值，在 <code>linux</code> 下如果查看 <code>/proc/</code> 进程 <code>id/fd/</code> ，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
</li>
<li><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p>
<p><code>epoll</code> 的事件注册函数， <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里 <code>epoll</code> 是先注册要监听的事件类型。第一个参数是 <code>epoll_create()</code> 的返回值，第二个参数 <strong>epoll_event</strong> 是用户态和内核态交互的结构，定义了用户态关心的事件类型和触发时数据的载体 <code>epoll_data</code> ；</p>
<ul>
<li><strong>EPOLL_CTL_ADD</strong>：注册新的 <code>fd</code> 到 <code>epfd</code> 中；</li>
<li><strong>EPOLL_CTL_MOD</strong>：修改已经注册的 <code>fd</code> 的监听事件；</li>
<li><strong>EPOLL_CTL_DEL</strong>：从 <code>epfd</code> 中删除一个 <code>fd</code> ；<br>第三个参数是需要监听的 <code>fd</code> ，第四个参数是告诉内核需要监听什么事，<strong>epoll_event是用户态需监控fd的代言人，后续用户程序对fd的操作都是基于此结构的</strong>，<code>struct epoll_event</code> 结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>events</code> 可以是以下几个宏的集合：</p>
<ul>
<li><strong>EPOLLIN</strong> ：表示对应的文件描述符可以读（包括对端 <code>SOCKET</code> 正常关闭）</li>
<li><strong>EPOLLOUT</strong>：表示对应的文件描述符可以写</li>
<li><strong>EPOLLPRI</strong>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li><strong>EPOLLERR</strong>：表示对应的文件描述符发生错误</li>
<li><strong>EPOLLHUP</strong>：表示对应的文件描述符被挂断</li>
<li><strong>EPOLLET</strong>： 将 <code>EPOLL</code> 设为边缘触发(<strong>Edge Triggered</strong>)模式，这是相对于水平触发(<strong>Level Triggered</strong>)来说的</li>
<li><strong>EPOLLONESHOT</strong>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 <code>socket</code> 的话，需要再次把这个 <code>socket</code> 加入到 <code>EPOLL</code> 队列里。</li>
</ul>
</li>
<li><p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<p>是阻塞等待内核返回的可读写事件，<code>epfd</code> 还是 <code>epoll_create</code> 的返回值，<code>events</code> 是个结构体数组指针存储 <code>epoll_event</code> ，也就是将内核返回的待处理 <code>epoll_event</code> 结构都存储下来，<code>maxevents</code> 告诉内核本次返回的最大 <code>fd</code> 数量，这个和 <code>events</code> 指向的数组是相关的；</p>
</li>
</ul>
<hr>
<h5><span id="epoll的底层实现"><strong>epoll的底层实现</strong></span></h5><p><code>epoll</code> 底层实现最重要的两个数据结构：<code>epitem</code> 和 <code>eventpoll</code> 。</p>
<p>可以简单的认为<strong>epitem</strong>是和每个用户态监控 <code>I/O</code> 的 <code>fd</code> 对应的，<code>eventpoll</code> 是用户态创建的管理所有被监控 <code>fd</code> 的结构，详细的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  _LINUX_RBTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _LINUX_RBTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rcupdate.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"><span class="comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">rdllink</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>  *<span class="title">next</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  </span><br><span class="line">  <span class="keyword">int</span>  nwait;                 </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">pwqlist</span>;</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>  *<span class="title">ep</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">fllink</span>;</span>   </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>  <span class="title">event</span>;</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">  <span class="keyword">spin_lock_t</span>       lock; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>      <span class="title">mtx</span>;</span>  </span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>     wq; </span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>   poll_wait; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllist</span>;</span>   <span class="comment">//就绪事件链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>      <span class="title">rbr</span>;</span>      <span class="comment">//红黑树根节点 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>      *<span class="title">ovflist</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>epoll的高效就在于</strong>，当我们调用 <code>epoll_ctl</code> 往 <code>epoll_event</code> 里塞入百万个句柄时，<code>epoll_wait</code> 仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。这是由于我们在调用 <code>epoll_create</code> 时，内核除了帮我们在 <code>epoll</code> 文件系统里建了个 <code>file</code> 结点，在<strong>内核cache</strong>里建了个<strong>红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件</strong>，当 <code>epoll_wait</code> 调用时，仅仅观察这个 <code>list</code> 链表里有没有数据即可。有数据就返回，没有数据就 <code>sleep</code> ，等到 <code>timeout</code> 时间到后即使链表没数据也返回。所以，<code>epoll_wait</code> 非常高效。</p>
<p>当我们执行 <code>epoll_ctl</code> 时，除了把 <code>socket</code> 放到 <code>epoll</code> 文件系统里 <code>file</code> 对象对应的红黑树上之外，还会给<strong>内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里</strong>。</p>
<p><strong>底层调用过程</strong></p>
<ol>
<li><p><code>epoll_create</code> 会创建一个类型为 <code>struct eventpoll</code> 的对象，并返回一个与之对应文件描述符。之后<strong>应用程序在用户态使用 <code>epoll</code> 的时候都将依靠这个文件描述符，而在 <code>epoll</code> 内部也是通过该文件描述符进一步获取到 <code>eventpoll</code> 类型对象，再进行对应的操作，完成了用户态和内核态的贯穿。</strong></p>
</li>
<li><p><code>epoll_ctl</code> 底层主要调用 <code>epoll_insert</code> 实现操作:</p>
<ul>
<li>创建并初始化一个<code>struct epitem</code> 类型的对象，完成该对象和被监控事件以及 <code>epoll</code> 对象 <code>eventpoll</code> 的关联;</li>
<li>将 <code>struct epitem</code> 类型的对象加入到 <code>epoll</code> 对象 <code>eventpoll</code> 的红黑树中管理起来;</li>
<li>将 <code>struct epitem</code> 类型的对象加入到被监控事件对应的目标文件的等待列表中，并注册事件就绪时会调用的回调函数，在 <code>epoll</code> 中该回调函数就是 <code>ep_poll_callback()</code> ;</li>
<li><code>ovflist</code> 主要是<strong>暂态处理</strong>，比如调用 <code>ep_poll_callback()</code> 回调函数的时候发现 <code>eventpoll</code> 的 <code>ovflist</code> 成员不等于 <code>EP_UNACTIVE_PTR</code> ，说明正在扫描 <code>rdllist</code> 链表，这时将就绪事件对应的<code>epitem</code> 加入到 <code>ovflist</code> 链表暂存起来，等 <code>rdllist</code> 链表扫描完再将 <code>ovflist</code> 链表中的元素移动到<code>rdllist</code> 链表中；</li>
</ul>
</li>
</ol>
<p>如图展示了红黑树、双链表、epitem之间的关系：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMj1rxibhibqZx2wKJiaFvWic5iaqcOzoicHQVQ07GHIveN1Sb0ZV2tEQLic5nw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ol start="3">
<li><p><strong>epoll_wait的数据拷贝</strong></p>
<p>关于 <code>epoll_wait</code> 使用共享内存的方式来加速用户态和内核态的数据交互，避免内存拷贝的观点，并没有得到2.6内核版本代码的证实，关于拷贝的实现是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">revents = ep_item_poll(epi, &amp;pt);<span class="comment">//获取就绪事件</span></span><br><span class="line"><span class="keyword">if</span> (revents) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">  __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">    list_add(&amp;epi-&gt;rdllink, head);<span class="comment">//处理失败则重新加入链表</span></span><br><span class="line">    ep_pm_stay_awake(epi);</span><br><span class="line">    <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">  &#125;</span><br><span class="line">  eventcnt++;</span><br><span class="line">  uevent++;</span><br><span class="line">  <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">    epi-&gt;event.events &amp;= EP_PRIVATE_BITS;<span class="comment">//EPOLLONESHOT标记的处理</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<span class="comment">//LT模式处理</span></span><br><span class="line">    ep_pm_stay_awake(epi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h5><span id="边缘触发etamp水平触发lt">边缘触发ET&amp;水平触发LT</span></h5><p><code>epoll</code> 对文件描述符的操作有两种模式：<code>LT（level trigger）</code> 和 <code>ET（edge trigger）</code> 。<code>LT</code> 模式是默认模式，<code>LT</code> 模式与 <code>ET</code> 模式的区别如下：</p>
<ul>
<li><strong>LT模式</strong><ul>
<li><strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。</strong></li>
<li><strong>下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></li>
<li><strong>LT支持阻塞和非阻塞套接字，LT模式更加安全</strong></li>
</ul>
</li>
<li><strong>ET模式</strong><ul>
<li><strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。</strong></li>
<li><strong>如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件.</strong></li>
<li><strong>read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者遇到EAGAIN错误。</strong></li>
<li><strong>只支持非阻塞套接字，其效率要高于LT模式。</strong></li>
</ul>
</li>
</ul>
<p><code>ET</code> 模式在很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 <code>LT</code> 模式高。<code>epoll</code> 工作在 <code>ET</code> 模式的时候，必须使用<strong>非阻塞IO</strong>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p><code>LT</code> 和 <code>ET</code> 模式下都可以通过 <code>epoll_wait</code> 方法来获取事件，<code>LT</code> 模式下将事件拷贝给用户程序之后，如果没有被处理或者未处理完，那么在下次调用时还会反馈给用户程序，可以认为数据不会丢失会反复提醒；</p>
<p><code>ET</code> 模式下如果没有被处理或者未处理完，那么下次将不再通知到用户程序，因此<strong>避免了反复被提醒</strong>，却<strong>加强了对用户程序读写的要求</strong>；</p>
<h5><span id="使用epoll是否需要将socket设置为nonblocking">使用epoll是否需要将socket设置为nonblocking?</span></h5><p>取决于你使用的触发方式， 如果你使用水平触发(Level-triggered) 那么此时的 <code>epoll</code> 相当于高级的 <code>select</code> ， 你的论述是对的， 是不需要一定将 <code>socket</code> 设置为非阻塞的; 然而， 当你使用边缘触发(Edge-triggered) 那么此时从业务的完整性考虑， 是建议将 <code>socket</code> 设置为 <code>nonbocking</code> 模式， 并且在读写触发 <code>EAGAIN</code> 之后再进行<code>epoll_wait</code> 。</p>
<h5><span id="epoll的优点">epoll的优点</span></h5><ol>
<li>没有最大并发连接的限制，能打开的 <code>FD</code> 的上限远大于 <code>1024</code>（ <code>1G</code> 的内存上能监听约10万个端口）</li>
<li>效率提升，不是轮询的方式，不会随着 <code>FD</code> 数目的增加效率下降。只有活跃可用的 <code>FD</code> 才会调用 <code>callback</code> 函数。即 <code>Epoll</code> 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>Epoll</code> 的效率就会远远高于 <code>select</code> 和 <code>poll</code> 。</li>
</ol>
<h5><span id="lt和et的读写问题">LT和ET的读写问题</span></h5><ol>
<li><strong>LT</strong><ul>
<li><strong>read</strong><ul>
<li><code>LT</code> 对于 <code>read</code> 操作比较简单，有 <code>read</code> 事件就读，读多读少都没有问题。</li>
</ul>
</li>
<li><strong>write</strong><ul>
<li>但是 <code>write</code> 就不那么容易了，一般来说<strong>socket在空闲状态时发送缓冲区一定是不满的</strong>，假如 <code>fd</code> 一直在监控中，那么会一直通知写事件，不胜其烦。</li>
<li>所以必须<strong>保证没有数据要发送的时候，要把 <code>fd</code> 的 <code>写</code> 事件监控从 <code>epoll</code> 列表中删除</strong>，<strong>需要的时候再加入回去，如此反复</strong>。</li>
<li>对应 <code>write</code> 的过度提醒，需要使用者随用随加，否则将一直被提醒可写事件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>ET</strong><ul>
<li><strong>read</strong><ul>
<li><code>fd</code> 可读则返回可读事件，若开发者没有把所有数据读取完毕，<code>epoll</code> 不会再次通知 <code>read</code> 事件。</li>
<li>也就是说如果没有全部读取所有数据，那么导致 <code>epoll</code> 不会再通知该 <code>socket</code> 的 <code>read</code> 事件，事实上一直读完很容易做到。</li>
</ul>
</li>
<li><strong>write</strong><ul>
<li><strong>若发送缓冲区未满，epoll通知write事件，直到开发者填满发送缓冲区，epoll才会在下次发送缓冲区由满变成未满时通知write事件。</strong></li>
</ul>
</li>
<li><code>ET</code> 模式下<strong>只有socket的状态发生变化</strong>时才会通知，也就是<strong>读取缓冲区由无数据到有数据时通知read事件</strong>，<strong>发送缓冲区由满变成未满通知write事件</strong>。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>一道面试题</strong></p>
<blockquote>
<p>使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？</p>
<p>网络流传的腾讯面试题</p>
</blockquote>
<p>这道题目对 <code>LT</code> 和 <code>ET</code> 考察比较深入，验证了前文说的 <code>LT</code> 模式 <code>write</code> 问题。</p>
<p><strong>普通做法</strong>：  </p>
<ul>
<li>当<strong>需要向socket写数据时，将该socket加入到epoll等待可写事件</strong>。接收到 <code>socket</code> 可写事件后，调用 <code>write()</code> 或 <code>send()</code> 发送数据；</li>
<li><strong>当数据全部写完后， 将socket描述符移出epoll列表，这种做法需要反复添加和删除。</strong></li>
</ul>
<p><strong>改进做法</strong>:</p>
<ul>
<li>向 <code>socket</code> 写数据时直接调用 <code>send()</code> 发送，当 <code>send()</code> 返回错误码 <code>EAGAIN</code> (写空了)，才将 <code>socket</code> 加入到 <code>epoll</code> (类似 <code>ET</code> 模式)。等待可写事件后再发送数据，全部数据发送完毕，再移出 <code>epoll</code> 模型。</li>
<li>改进的做法相当于认为 <code>socket</code> 在<strong>大部分时候是可写的</strong>，<strong>不能写了再让epoll帮忙监控</strong>。</li>
</ul>
<p>上面两种做法是对 <code>LT</code> 模式下 <code>write</code> 事件频繁通知的修复，本质上 <code>ET</code> 模式就可以直接搞定，并不需要用户层程序的补丁操作。</p>
<hr>
<h5><span id="et模式的线程饥饿问题">ET模式的线程饥饿问题</span></h5><p>如果某个 <code>socket</code> 源源不断地收到非常多的数据，在试图读取完所有数据的过程中，有可能会造成其他的 <code>socket</code> 得不到处理，从而造成<strong>饥饿</strong>问题。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>为每个<strong>已经准备好的描述符</strong>维护一个队列，这样程序就可以知道哪些描述符已经准备好了但是并没有被读取完</li>
<li>程序定时或定量的读取，如果读完则移除，直到队列为空，这样就保证了每个 <code>fd</code> 都被读到并且不会丢失数据，流程如图。(类似调度算法中的 <code>Robin Round</code> ？)</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMSj8caicicn1aLlm47p4w3OKgk7dHGXUjRkGibPMfF4VAcdptA5wibPpg1w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<hr>
<h5><span id="epolloneshot设置">EPOLLONESHOT设置</span></h5><p><code>A</code> 线程读完某 <code>socket</code> 上的数据后开始处理这些数据，此时该 <code>socket</code> 上又有新数据可读，B线程被唤醒读新的数据，造成 <code>2</code> 个线程<strong>同时操作一个socket</strong>的局面 ，<strong>EPOLLONESHOT</strong>保证<strong>一个socket连接在任一时刻只被一个线程处理</strong>。 </p>
<hr>
<h5><span id="两种模式的选择">两种模式的选择</span></h5><p>通过前面的对比可以看到<strong>LT模式比较安全并且代码编写也更清晰</strong>，但是<strong>ET模式属于高速模式</strong>，在处理大高并发场景使用得当效果更好，具体选择什么根据自己实际需要和团队代码能力来选择，如果并发很高且团队水平较高可以选择 <code>ET</code> 模式，否则建议 <code>LT</code> 模式。</p>
<hr>
<h5><span id="epoll的惊群问题epollexclusive">epoll的惊群问题(EPOLLEXCLUSIVE)</span></h5><p>在 <code>2.6.18</code> 内核中 <code>accept</code> 的惊群问题已经被解决了，但是在 <code>epoll</code> 中仍然存在<strong>惊群问题</strong>：表现起来就是<strong>当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。</strong></p>
<p>在 <code>epoll</code> 官方没有正式修复这个问题之前，Nginx作为知名使用者采用<strong>全局锁来限制每次可监听fd的进程数量</strong>，<strong>每次只有1个可监听的进程</strong>，后来在Linux 3.9内核中增加了SO_REUSEPORT选项实现了内核级的负载均衡，Nginx1.9.1版本支持了reuseport这个新特性，从而解决惊群问题。</p>
<p><strong>EPOLLEXCLUSIVE</strong> 是在2016年 <code>Linux 4.5</code> 内核新添加的一个 <code>epoll</code>  的标识，Ngnix 在 1.11.3 之后添加了 <code>NGX_EXCLUSIVE_EVENT</code> 选项对该特性进行支持。<strong><code>EPOLLEXCLUSIVE</code> 标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。</strong></p>
<h5><span id="边缘触发的io应该怎么写">边缘触发的IO应该怎么写？</span></h5><hr>
<h3><span id="虚拟内存">虚拟内存</span></h3><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p>
<p>虚拟内存的重要意义是它<strong>定义了一个连续的虚拟地址空间</strong>，<strong>让每个进程有一种自己在独享主存的错觉</strong>，并且<strong>把内存扩展到硬盘空间上</strong>。</p>
<p>操作系统可以把进程所使用的地址「<strong>隔离</strong>」开来，即让操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提<strong>每个进程都不能访问物理地址</strong>，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</p>
<p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>
<ul>
<li>程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li>
<li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li>
</ul>
<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的<strong>内存管理单元(MMU)</strong>的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkpVTcOZj4JJSyYlSMyiaC66pP2q1QiafglrtO0tmZHCkBB0RvCsfVOTIA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4><span id="虚拟内存作为缓存的工具">虚拟内存作为缓存的工具</span></h4><p>虚拟内存系统将虚拟内存分割为称为<strong>虚拟页(VP)</strong>的大小固定的块，每个<strong>VP</strong>的大小为 $P=2^p$ 字节，类似地，物理内存被分割为<strong>物理页(Physical Page, PP)</strong>，大小也为 <code>P</code> 字节，物理页也被称为<strong>页帧</strong>。</p>
<p>任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li><strong>未分配的</strong>：VM系统还未分配/创建的页，没有任何数据和他们相关联，因此不占用任何磁盘空间。</li>
<li><strong>缓存的</strong>：已缓存在物理内存中的已分配页。(使用内存作为缓存)</li>
<li><strong>未缓存的</strong>：未缓存在物理内存中的已分配页。</li>
</ul>
<p>操作系统是如何管理虚拟地址与物理地址之间的关系的？</p>
<p>主要是通过<strong>内存分段</strong>和<strong>内存分页</strong>来实现的。</p>
<hr>
<h4><span id="内存分段">内存分段</span></h4><p>程序是由若干个逻辑分段组成的，如可由<strong>代码分段、数据分段、栈段、堆段</strong>组成。<strong>不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</strong></p>
<p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。(类似虚函数表的映射，段表相当于虚函数表)</p>
<ul>
<li><strong>段选择因子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkTX5icicl09hKPabMh2LHcfiapeTumDtOUB3fydDdsIGuNKI0uUWia4k5oA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 <strong>4 个段(分别对应堆、栈、数据区、代码区)</strong>，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk87ABj8vKWeQANrKVHpm7xNZRTbgFPOicpy74mD65ia3rGgMaIo6G1ntQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><strong>分段的优点：能够产生连续的内存空间。</strong></p>
<p><strong>分段的缺点：</strong></p>
<ol>
<li><p><strong>内存碎片</strong>：空闲的内存是零散的碎片</p>
<ol>
<li><p><strong>外部内存碎片</strong>：也就是产生了多个<strong>不连续的小物理内存</strong>，导致新的程序无法被装载</p>
<p>解决方法：<strong>内存交换</strong></p>
<p>在 Linux 系统里，也就是我们常看到的 <code>Swap</code> 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
</li>
<li><p><strong>内部内存碎片</strong>：程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</p>
</li>
</ol>
</li>
<li><p><strong>内存交换的效率低</strong></p>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p>
<p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了<strong>内存分页</strong>。</p>
</li>
</ol>
<hr>
<h4><span id="内存分页">内存分页</span></h4><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个<strong>连续并且尺寸固定的内存空间</strong>，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <strong>4KB</strong>。每一页起始于 <code>4096</code> 的倍数位置，结束于 <code>4095</code> 的位置。</p>
<p><strong>虚拟地址与物理地址</strong>之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkZoTKofqkOibHicWGJPwsCjZGRpG077zmMMnRibkVqcVocZz1PxeIuLLMg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元</strong> （<strong>MMU</strong>） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>(跟缺页中断不一样)，<strong>缺页异常调用内核中的缺页异常处理程序</strong>：</p>
<ol>
<li><strong>进入系统内核空间分配物理内存</strong></li>
<li><strong>更新进程页表</strong></li>
<li><strong>返回用户空间，恢复进程的运行。</strong></li>
</ol>
<p>页表就是一个<strong>页表条目(Page Table Entry)</strong>的数组，<strong>虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE</strong>，<strong>PTE</strong>是由一个有效位(valid bit)和一个 <code>n</code> 位地址字段组成的，有效位表明了该虚拟页当前是否被缓存在DRAM主存中。这也对应了前面说的虚拟页面分为三部分：</p>
<ol>
<li><strong>有效位为0，地址字段为null：</strong>这个虚拟页还未被分配(缺页异常)</li>
<li><strong>有效位为0，地址字段不为null</strong>：该虚拟页已经被分配了，但是未被缓存(缺页异常)</li>
<li><strong>有效位为1</strong>：该虚拟页被分配也在主存中缓存了。</li>
</ol>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613550514882.png" alt="1613550514882"></p>
<p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<strong>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</strong></p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的 <code>LRU</code> 等<strong>页面置换算法</strong>计算出的的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，<strong>不再需要一次性都把程序加载到物理内存中</strong>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成<strong>页号和偏移量</strong>；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<h4><span id="页表">页表</span></h4><p>特点如下：</p>
<ul>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存</li>
<li>不是所有的页都有对应的帧(<strong>缺页异常page fault</strong>)</li>
</ul>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613724196305.png" alt="1613724196305"></p>
<p>每个运行的程序都有一个对应的页表：</p>
<ul>
<li>属于程序运行状态，会随着程序运行动态变化。</li>
<li>每个程序是根据CPU中的<strong>PTBR(页表基址寄存器)</strong>来找到这个程序对应的页表。</li>
</ul>
<blockquote>
<p>简单的分页有什么缺陷吗？</p>
</blockquote>
<p>有空间上的缺陷。因为操作系统是可以同时运行非常多的进程的，这就意味着页表会非常的庞大。比如一个页的大小是 <code>4KB</code>，虚拟地址空间有 <code>4GB</code>，那就需要 <code>100w</code> 个页，每个页表需要 <code>4Byte</code> 来存储，那么就需要 <code>4MB</code> 用来存储页表，<code>100</code> 个进程就是 <code>400MB</code> 。为了能够随机访问，那么就需要<strong>连续4M的内存空间</strong>来存放所有的页表项。随着虚拟地址空间的增大，<strong>存放页表所需要的连续空间也会增大</strong>，在操作系统内存紧张或者内存碎片较多时，这无疑会带来额外的开销。但是如果使用多级页表，我们可以使用一页来存放页目录项，页表项存放在内存中的其他位置，不用保证页目录项和页表项连续。</p>
<hr>
<h4><span id="多级页表">多级页表</span></h4><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613553592209.png" alt="1613553592209"></p>
<p>要解决上面的问题，就需要采用的是一种叫作<strong>多级页表</strong>（Multi-Level Page Table）的解决方案。</p>
<p>首先我们要明确一点，我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以<strong>页表一定要覆盖全部虚拟地址空间</strong></p>
<p>但是在一级页表之中，为了映射到所有的地址，需要 <code>100w</code> 个页表项来覆盖全部虚拟地址空间，而二级页表只需要 <code>1024</code> 个页表项就可以覆盖( <code>此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建</code> )。</p>
<p>如果使用了二级分页，一级页表就可以覆盖整个 <code>4GB</code> 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= <code>0.804M</code>，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p>
<ul>
<li>一级页表中的每个<strong>PTE</strong>负责映射虚拟地址空间中一个 <code>4MB</code> 的片(chunk)，这里每一片都是由 <code>1024</code> 个连续的页面组成的，<code>PTE0</code> 映射第一片，<code>PTE1</code> 映射第二片…如果片 <code>i</code> 中每个页面都未被分配，那么一级的 $PTE_i$ 就为空；如果在片 <code>i</code> 中至少有一个页是分配了的，那么一级 $PTE_i$指向一个二级页表的基址。</li>
<li>二级页表中的每个<strong>PTE</strong>都负责映射一个<strong>4KB</strong>的虚拟内存页面。</li>
</ul>
<h5><span id="k级页表层次结构">K级页表层次结构</span></h5><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613557269389.png" alt="1613557269389"></p>
<ul>
<li>虚拟地址被划分成为 <code>k</code> 个 <code>VPN</code> 和 <code>1</code> 个 <code>VPO</code> ，每个 <code>VPNi</code> 都是一个到第 <code>i</code> 级页表的索引，其中第 <code>j</code> 级页表中的每个 <code>PTE</code> 都指向第 <code>j+1</code> 级的某个页表的基址。</li>
<li>第 <code>k</code> 级页表中的每个 <code>PTE</code> 包含某个物理页面的 <code>PPN</code> ，或者一个磁盘块的地址，为了构造物理地址，在能够确定 <code>PPN</code> 之前，<code>MMU</code> 必须访问 <code>k</code> 个 <code>PTE</code> 。</li>
<li>对于只有一级的页表结构，<code>PPO</code> 和 <code>VPO</code> 是相同的。这里面的 <code>VPO</code> 是一个 <code>p</code> 位的虚拟页偏移量，对应 <code>PPO</code> 的 <code>p</code> 位物理页偏移量，偏移量表示了根据 <code>VPN/PPN</code> 的页号找到了对应的大小为 <strong>$2^p$</strong> 的页之后，应该选取页中的第几行。</li>
</ul>
<h5><span id="多级页表的优势"><strong>多级页表的优势</strong></span></h5><ul>
<li>离散存储<ul>
<li>多级页表实际上是增加了<strong>索引</strong>，有了索引就可以定位到具体的项。</li>
<li>可以使用一页来存放页目录项，页表项存放在内存中的其他位置，不用保证页目录项和页表项连续。</li>
</ul>
</li>
<li>节省内存<ul>
<li>多级页表通过<strong>只为进程实际使用的那些虚拟地址内存区请求页表</strong>来减少内存使用量</li>
</ul>
</li>
</ul>
<h5><span id="多级页表的劣势"><strong>多级页表的劣势</strong></span></h5><ul>
<li>增加寻址次数，延长访存时间。</li>
</ul>
<p><strong>64位系统用到的是四级目录</strong></p>
<ul>
<li>全局页目录项 <strong>PGD</strong>（<em>Page Global Directory</em>）；</li>
<li>上层页目录项 <strong>PUD</strong>（<em>Page Upper Directory</em>）；</li>
<li>中间页目录项 <strong>PMD</strong>（<em>Page Middle Directory</em>）；</li>
<li>页表项 <strong>PTE</strong>（<em>Page Table Entry</em>）；</li>
</ul>
<hr>
<h4><span id="tlbtranslation-lookaside-buffer-页表缓存快表转换检测缓冲区相关存储器实现">TLB(<em>Translation Lookaside Buffer</em>) 页表缓存/快表/转换检测缓冲区(相关存储器实现)</span></h4><p><a href="https://zhuanlan.zhihu.com/p/108425561?utm_source=wechat_timeline" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108425561?utm_source=wechat_timeline</a></p>
<table>
<thead>
<tr>
<th><strong>符号名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PTE</strong></td>
<td><strong>页表条目(Page Table Entry)</strong></td>
</tr>
<tr>
<td><strong>VPO</strong></td>
<td><strong>虚拟页面偏移量(Byte)</strong></td>
</tr>
<tr>
<td><strong>VPN</strong></td>
<td><strong>虚拟页号</strong></td>
</tr>
<tr>
<td><strong>TLBI</strong></td>
<td><strong>TLB索引</strong></td>
</tr>
<tr>
<td><strong>TLBT</strong></td>
<td><strong>TLB标记</strong></td>
</tr>
<tr>
<td><strong>PPO</strong></td>
<td><strong>物理页面偏移量(Byte)</strong></td>
</tr>
<tr>
<td><strong>PPN</strong></td>
<td><strong>物理页号</strong></td>
</tr>
<tr>
<td><strong>CO</strong></td>
<td><strong>缓冲块内的字节偏移量</strong></td>
</tr>
<tr>
<td><strong>CI</strong></td>
<td><strong>高速缓存索引</strong></td>
</tr>
<tr>
<td><strong>CT</strong></td>
<td><strong>高速缓存标记</strong></td>
</tr>
</tbody>
</table>
<p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。程序是有<strong>局部性</strong>的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p>
<p>我们就可以利用这一特性，<strong>把最常访问的几个页表项存储到访问速度更快的硬件</strong>，于是计算机科学家们，就在 CPU 芯片中，<strong>加入了一个专门存放程序最常访问的页表项的 Cache</strong>，这个 Cache 就是 <strong>TLB（<em>Translation Lookaside Buffer</em>）</strong> ，通常称为<strong>页表缓存</strong>、<strong>转址旁路缓存</strong>、<strong>快表</strong>等。它可以跟MMU(内存管理单元)进行交互，MMU可以先在TLB中查找页表，如果没有命中再去找页表里找。</p>
<ul>
<li><strong>TLB</strong>是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个<strong>PTE</strong>组成的块，<strong>TLB</strong>通常有高度的相联度。</li>
<li><strong>TLB</strong>使用associative memory(关联内存)实现，具备快速访问性能</li>
<li>如果<strong>TLB</strong>命中，物理页号可以很快被获取</li>
<li>如果<strong>TLB</strong>没有命中，对应的表项将被更新到<strong>TLB</strong>中。</li>
<li><strong>TLB</strong>的<strong>key</strong>是逻辑地址中的 <code>p</code> ，也就是虚拟页号<strong>VPN</strong>。  </li>
</ul>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613552517448.png" alt="1613552517448"></p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613552606242.png" alt="1613552606242"></p>
<p>当<strong>TLB</strong>不命中时，<strong>MMU</strong>必须从<strong>L1缓存</strong>中取出对应的<strong>PTE</strong>，新取出的<strong>PTE</strong>存放在<strong>TLB</strong>中，可能会覆盖一个已经存在的<strong>PTE</strong>条目。</p>
<hr>
<h4><span id="反向页表">反向页表</span></h4><ul>
<li>正向页表：以<strong>逻辑页的虚拟页号</strong>作为索引在页表中查找<strong>物理页的页帧号</strong>。</li>
<li>反向页表：以<strong>物理页的页帧号(物理页号)</strong>作为索引在页表中查找<strong>逻辑页的页号</strong>。</li>
</ul>
<h5><span id="传统页表的缺点">传统页表的缺点</span></h5><ol>
<li>对于<strong>大地址空间</strong>，前向映射页表变得繁琐(例如64位系统采用5级页表)。</li>
<li><strong>逻辑地址空间增长速度快于物理地址空间</strong>，所以反向页表，也就是index是物理地址，value是逻辑地址，它的大小会小于传统页表。</li>
</ol>
<p><strong>反向页表的总体思路是：</strong></p>
<ul>
<li>以页帧号为 <code>index</code>，页号地址为 <code>value</code>，<strong>每次访问从前到后遍历页表</strong>，<strong>将 <code>value</code> 和逻辑地址比对</strong>，这样做的原因就是大大节省了内存的开销，全局只需要一张页表(注意这里面页表会有<strong>PID</strong>，因为全局的物理内存是映射到很多个进程的虚拟内存的)。</li>
<li>但是当物理内存特别大的时候，这个表也就很大了，访问一个地址可能需要遍历整个表（<strong>因为是按照物理地址建立的，所以要挨个访问、判断</strong>）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191110103218405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODQxMTMw,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>那么有什么方法是可以缓减访问速度的压力吗，那就是基于 <code>hash</code> 表的访问</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200112153313860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTE0NjE4My8yMDE3MTEvMTE0NjE4My0yMDE3MTEwODEyNDgzMTE2OS0xMDE2NTA3MjY0LnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p><strong>将页号即图中的vpn做一个hash计算（使用硬件加速），结果当然是得到一个页帧号</strong>，也就是反向页表的 <code>index</code>，但是这样可能会存在 <code>hash</code> 冲突，因此在传参的时候需要传入当前进程的 <code>PID</code> 作为标识，以确保找到对应的页帧号。</p>
<p><code>NEXT</code> 中存放的是<strong>由于 <code>hash</code> 冲突导致的相同 <code>hash</code> 值的下一个条目的 <code>index</code> （页帧号）</strong>，这样就不需要一个一个进行比对了。如图，<code>0x1</code> 经过计算得到 <code>0x0</code>，因此去访问反向页表的 <code>index</code> 为 <code>0x0</code> 这个条目，比对之后发现<code>PID</code> 不对，因此访问 <code>NEXT</code> ，找到相同 <code>hash</code> 值的下一个条目……找到之后，<code>index+offset</code> 即为物理访问地址</p>
<hr>
<h4><span id="段页式内存管理">段页式内存管理</span></h4><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>
<ul>
<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制(代码段、数据段、栈段、堆段等等)；</li>
<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>
</ul>
<p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。每一个程序一张段表，每个段又建立一张页表，<strong>段表中的地址是页表的起始地址</strong>，<strong>而页表中的地址则为某页的物理页号</strong>。</p>
<hr>
<h4><span id="linux虚拟内存">Linux虚拟内存</span></h4><p>Linux 系统中的每个段都是从 0 地址开始的整个 <code>4GB</code> 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是<strong>线性地址空间（虚拟地址）</strong>，这种做法相当于屏蔽了处理器中的<strong>逻辑地址</strong>概念，段只被用于访问控制和内存保护。</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613558372501.png" alt="1613558372501"></p>
<p>虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkr9Pf9QeM2EhturaF3WFbL7AFYHJvKexk3As6s2vg1NiaUh5AplRmqyA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ul>
<li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li>
<li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。64位其中16位作为保留位，实际上只有48位能用于内存寻址，即2^48约 <code>256T</code> </li>
</ul>
<p><strong>内核空间与用户空间的区别</strong></p>
<ul>
<li>进程在用户态时，只能访问用户空间内存；</li>
<li>只有进入内核态后，才可以访问内核空间的内存；</li>
</ul>
<p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>
<h5><span id="用户空间的内存分布">用户空间的内存分布</span></h5><p>用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p>
<ul>
<li><strong>程序文件段.text</strong>，包括二进制可执行代码；</li>
<li><strong>已初始化数据段.data</strong>，包括静态常量；</li>
<li><strong>未初始化数据段.bass</strong>，包括未初始化的静态变量；</li>
<li><strong>堆段</strong>，包括动态分配的内存，从<strong>低地址开始向上增长</strong>；</li>
<li><strong>文件映射段</strong>，包括动态库、共享内存等，<strong>从低地址开始向上增长</strong>（跟硬件和内核版本有关）</li>
<li><strong>栈段</strong>，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；栈内的增长是从<strong>高地址向低地址增长的。</strong></li>
</ul>
<hr>
<h4><span id="mmap内存映射">mmap内存映射</span></h4><p><strong>如果虚拟内存系统可以集成到传统的文件系统中，那么就可以提供一种简单而高效的方法来把程序和数据加载到内存中。</strong></p>
<ol>
<li>调用用户空间mmap函数在当前进程的连续虚拟地址上来形成映射空间</li>
<li>调用内核空间mmap函数来实现文件物理地址到虚拟地址上的一一映射</li>
<li>进程发起对这片映射空间的访问，引起缺页异常，来实现文件内容到物理内存的拷贝</li>
</ol>
<p>前两步只是创建映射空间，并没有任何的数据拷贝工作，而在第三步中，通过缓存脏回写的机制，直接跳过了从缓存中拷贝到用户空间的传统读写步骤，缩短了很多时间。</p>
<p>Linux通过将一个<strong>虚拟内存区域</strong>与一个磁盘上的对象(object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)，虚拟内存区域可以映射到两种类型对象中的一种：</p>
<ul>
<li>Linux文件系统中的普通文件：<ul>
<li>一个区域可以映射到一个<strong>普通磁盘文件的连续部分</strong>，例如一个可执行目标文件。</li>
<li>文件区(section)被分为<strong>页大小的片</strong>，<strong>每一片包含一个虚拟页面的初始内容</strong>。</li>
<li>因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用到页面。</li>
</ul>
</li>
<li>匿名文件：<ul>
<li>匿名文件是由内核创建的，包含的全都是二进制0</li>
</ul>
</li>
</ul>
<h5><span id="共享对象">共享对象</span></h5><p>内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。一个对象可以被映射到虚拟内存的一个区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。如果一个进程<strong>将一个共享对象映射到它的虚拟地址空间的一个区域</strong>内，那么这个进程对这块区域的任何<strong>写操作</strong>，对于<strong>同样映射了这部分共享对象的进程也是可见的。</strong> 这些变化也会<strong>反应在磁盘的原始对象中</strong>。</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613563964377.png" alt="1613563964377"></p>
<p>即使对象被映射到了多个共享区域，<strong>物理内存中也只需要存放共享对象的一个副本</strong>。</p>
<p>私有对象则通过<strong>写时复制</strong>来映射到虚拟内存中。</p>
<hr>
<h3><span id="缺页中断page_fault缺页异常">缺页中断(page_fault)/缺页异常</span></h3><p>在请求分页系统中，可以通过查询<strong>页表中的状态位</strong>来确定所要访问的页面是否存在于内存中。<strong>每当所要访问的页面不在内存时，会产生一次缺页中断</strong>，此时操作系统会根据<strong>页表中的外存地址在外存中找到所缺的一页</strong>，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<ol>
<li>保护CPU现场</li>
<li>分析中断原因</li>
<li>转入缺页中断处理程序进行处理</li>
<li>恢复CPU现场，继续执行</li>
</ol>
<p>但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在<strong>区别</strong>：</p>
<ol>
<li>在指令执行期间产生和处理缺页中断信号</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
<li>缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令</li>
</ol>
<hr>
<h3><span id="页面置换算法">页面置换算法</span></h3><p>进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区(<strong>SWAP</strong>)。但此时应该把那个页面换出，则需要根据一定的<strong>页面置换算法</strong>（Page Replacement Algorithm)来确定。</p>
<ul>
<li><strong>最佳置换算法（OPT)</strong></li>
<li><strong>先进先出置换算法（FIFO)</strong></li>
<li><strong>最近未使用页面置换算法（NRU）</strong></li>
<li><strong>最近最久未使用置换算法（LRU）</strong></li>
<li><strong>时钟页面置换算法（Clock）</strong></li>
<li><strong>第二次机会算法：</strong>对FIFO的一个修改，在删除页面之前检查这个页面是否仍在使用，如果页面正在使用，就会进行保留，这个改进大大提高了性能。</li>
</ul>
<hr>
<h3><span id="cpu调度算法进程调度算法">CPU调度算法/进程调度算法</span></h3><p><em>非抢占式调度算法</em></p>
<hr>
<h5><span id="先到先服务算法fcfs-first-come-first-served">先到先服务算法(FCFS, First-Come First-Served)</span></h5><p>这个算法会用到的属性是进程的<strong>到达时间</strong>，也就是启动运行一个进程的时间。<strong>先启动的进程会优先被调度器选中</strong>。</p>
<p><strong>优点：</strong>这个算法有一个很好的性质，就是<strong>任何进程都不会饥饿</strong>，也就是说算法没有会导致任务进程拒绝服务的内在偏向。</p>
<p><strong>缺点：</strong>但由于上面这个性质，响应时间的方差会很大。举个例子，一个长时间任务到达后，后面跟着一个短时间的任务，那么短任务被长作业挡在后面，它的响应时间就会很糟糕，由于护送效应导致低下的CPU利用率。所以这个<strong>算法并没有对短任务给予任何优先考虑</strong>。</p>
<hr>
<h5><span id="最短作业优先sjf-shortest-job-first">最短作业优先(SJF, Shortest Job First)</span></h5><p>既然 <code>先到先服务</code> 对短任务不是很友好，那么这个算法就是为了让短作业获得更好的响应时间。</p>
<p><strong>优点</strong>：调度器会优先选择时间较短的任务，让短任务获得更好的响应时间；</p>
<p><strong>缺点</strong>：有可能会让一个长时任务饥饿。解决这个缺点有一个方案，<strong>当一个作业的年龄到达一个阈值，调度器忽略SJF, 选择FCFS算法。</strong></p>
<hr>
<h5><span id="优先级算法">优先级算法</span></h5><p>出于调度的目的，多数 <code>OS</code> 会给每个进程赋予一个属性——优先级。比如，在 <code>UNIX</code> 系统中，每个用户级进程开始时都有一个固定的默认优先级。<code>Ready Queue</code> 中包含多个子队列，每个队列都对应着一个优先级，每个子队列内部采用 <code>FCFS</code> 算法。</p>
<p><strong>优点</strong>：灵活，可以提供差异化服务</p>
<p><strong>缺点：</strong>会产生饥饿，可以根据进程的等待时间来提高优先级</p>
<hr>
<h5><span id="高响应比优先调度算法hrrn">高响应比优先调度算法(HRRN)</span></h5><p>高响应比优先调度算法主要用于作业调度，该算法是对先来先服务调度算法和短作业优先调度算法的一种综合平衡，<strong>同时考虑每个作业的等待时间和估计的运行时间</strong>。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
<hr>
<p><em>抢占式调度算法</em></p>
<p>抢占式与非抢占式的区别在于：在一个新进程或刚完成 <code>I/O</code> 的进程进入到 <code>ready queue</code> 中时，会重新评估一些属性（比如剩余执行时间），以决定要不要抢占当前正在运行的进程。原则上说，上面讨论到的任何一个非抢占式算法都能改造成抢占式的，比如 <code>FCFS</code> 算法，每次重新进入就绪队列时，调度器可以决定抢占当前正在执行的进程（如果新任务的到达时间比较早），类似的，<code>SJF</code> 和优先级也一样可以。</p>
<h5><span id="最短剩余时间优先-srtf-shortest-remaining-time-first">最短剩余时间优先 (SRTF, Shortest Remaining Time First)</span></h5><p>调度器会估计每个进程的运行时间，当一个进程回到就绪队列，<strong>调度器计算这个任务的剩余处理时间</strong>，根据计算结果，放入 <code>ready queue</code> 中合适的位置。如果<strong>该进程的剩余时间比当前的进程要少，那么调度器就会抢占当前运行的任务，让这个新任务先执行</strong>。跟 <code>FCFS</code> 算法相比，最短剩余时间的平均等待时间一般比较低。</p>
<hr>
<h5><span id="rrround-robin调度器">RR(Round Robin)调度器</span></h5><p>按时间片来轮转调度：<strong>分时环境</strong>特别适合使用 <code>RR</code> 调度器，即<strong>每个进程都应该得到处理器时间的一部分</strong>。假设有n个就绪的进程，调度器把 <code>CPU</code> 资源分成一个一个时间片，然后分配给各个进程。就绪队列里每个进程都会得到处理器的时间片 <code>q</code> 。当时间片用完了，当前调度的进程会被放入就绪队列的尾部，形成一个 <code>ring</code> 。但考虑到在不通进程切换会有开销，所以选择时间片 <code>q</code> 的适合要考虑上下文切换。</p>
<hr>
<h5><span id="多级反馈队列mfq">多级反馈队列(MFQ)：</span></h5><p>进程在不同优先级的队列间迁移，首先调度优先级高的队列中的进程，只有优先级高的队列为空时才去调度优先级低的队列中的进程；对于同一个队列中的进程，按照时间片轮转的方式进行调度，如果N个时间片后依然未能完成，则进入优先级低的队列等待；在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU分配给新到达的作业，即抢占式。</p>
<p><img src="https://img-blog.csdn.net/20170407165752062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzYxNjk0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h3><span id="用户态与内核态">用户态与内核态</span></h3><ul>
<li>内核态与用户态是操作系统的两种运行级别，当程序运行在 <code>R3</code> 级特权级上时，就可以称之为运行在用户态。<strong>因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；</strong></li>
<li>当程序运行在 <code>R0</code> 级特权级上时，就可以称之为运行在内核态。</li>
<li>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。</li>
<li>这两种状态的主要差别是<ul>
<li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其<strong>所处于占有的处理器是可被抢占</strong>的</li>
<li>处于内核态执行时，则<strong>能访问所有的内存空间和对象</strong>，且<strong>所占有的处理器是不允许被抢占的</strong>。</li>
</ul>
</li>
</ul>
<h5><span id="三种情况会导致用户态到内核态的切换">三种情况会导致用户态到内核态的切换</span></h5><ul>
<li><p><strong>系统调用</strong></p>
<ul>
<li><strong>这是用户态进程主动要求切换到内核态的一种方式</strong>，<strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。</strong>比如前例中<strong>fork()</strong>实际上就是执行了一个创建新进程的系统调用。常见的系统调用还有 <code>read, write, open, create, close, readv, writev, fork, wait, exit, execve, clone</code> 等等</li>
<li>而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。用户程序通常调用库函数，由库函数再调用系统调用，因此<strong>有的库函数会使用户程序进入内核态</strong>（只要库函数中某处调用了系统调用），有的则不会。</li>
<li>这是最简单的方式，被称为<strong>忙等待(busy waiting)</strong>，这种方式的<strong>缺点是要一直占据CPU，CPU会一直轮询I/O设备直到I/O操作完成。</strong></li>
</ul>
</li>
<li><p><strong>外围设备的中断</strong></p>
<ul>
<li><strong>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号</strong>，这时<strong>CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。</strong></li>
<li>如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
<li>一旦CPU决定去实施中断后，程序计数器(<strong>PC</strong>)和程序状态寄存器(<strong>PSW</strong>)会被压入到当前堆栈中并且CPU会切换到<strong>内核态</strong>。</li>
<li>设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址，这部分内存称作<strong>中断向量(interrupt vector)</strong>，可以通过<strong>中断控制器</strong>来决定优先处理哪个中断。</li>
</ul>
</li>
<li><p><strong>异常</strong></p>
<p>当 <code>CPU</code> 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
</ul>
<p>实现I/O的三种方法：</p>
<ul>
<li><strong>系统调用</strong></li>
<li><strong>中断</strong></li>
<li><strong>使用特殊的硬件：直接存储器访问(DMA)</strong></li>
</ul>
<hr>
<h3><span id="linux文件系统">Linux文件系统</span></h3><p><a href="https://www.cnblogs.com/rickiyang/p/13265043.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/13265043.html</a></p>
<h4><span id="系统调用">系统调用</span></h4><p>计算机系统的各种硬件资源是有限的，因此为了保证每一个进程都能安全的执行。处理器设有两种模式：<strong>用户模式</strong> 与 <strong>内核模式</strong>。一些容易发生安全问题的操作都被限制在只有内核模式下才可以执行，例如 <strong>I/O 操作</strong>，<strong>修改基址寄存器内容</strong>等。</p>
<p>当我们处在用户态但是却不得不调用内核态下一些操作的时候这时候可以利用Linux提供的一些转换接口唤起操作，而连接用户模式和内核模式的接口称之为 <strong>系统调用</strong>。<strong>TRAP指令</strong>用于把用户态切换为内核态并启用操作系统。</p>
<p><strong>TRAP指令</strong>实际上与<strong>过程调用指令</strong>非常相似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中的返回地址。</p>
<p>应用程序代码运行在用户模式下，当应用程序需要实现内核模式下的指令时，先向操作系统发送调用请求。操作系统收到请求后，执行系统调用接口，使处理器进入内核模式。当处理器处理完系统调用操作后，操作系统会让处理器返回用户模式，继续执行用户代码。</p>
<p>进程的虚拟地址空间可分为两部分，<strong>内核空间</strong> 和 <strong>用户空间</strong>。内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于<strong>虚拟空间中，都是对物理地址的映射</strong>。</p>
<h4><span id="虚拟文件系统">虚拟文件系统</span></h4><p>一个操作系统可以支持多种底层不同的文件系统(比如 NTFS, FAT, ext3, ext4)，为了给内核和用户进程提供统一的文件系统视图，Linux 在用户进程和底层文件系统之间加入了一个抽象层，即<strong>虚拟文件系统( Virtual File System, VFS )</strong>，进程所有的文件操作都通过 <code>VFS</code>，由 <code>VFS</code> 来适配各种底层不同的文件系统，完成实际的文件操作。</p>
<p>通俗的说，<code>VFS</code> 就是定义了一个通用文件系统的接口层和适配层，一方面为用户进程提供了一组统一的访问文件，目录和其他对象的统一方法，另一方面又要和不同的底层文件系统进行适配。如图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj9hpbcplj30gn0ai75b.jpg" alt="1"></p>
<h4><span id="vfs主要模块">VFS主要模块</span></h4><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613448111292.png" alt="1613448111292"></p>
<ol>
<li><strong>超级块(super_block)</strong>：用于保存<strong>一个文件系统的所有元数据</strong>，相当于这个文件系统的信息库，为其他的模块提供信息。因此一个超级块可代表一个文件系统。文件系统的任意元数据修改都要修改超级块。超级块对象是常驻内存并被缓存的。</li>
<li><strong>目录项模块</strong>：管理路径的目录项。比如一个路径 <code>/usr/local/hello.txt</code>，那么目录项有 usr, local, hello.txt。目录项的块，<strong>存储的是这个目录下的所有的文件的 <code>inode</code> 号 和 文件名 等信息</strong>。其内部是<strong>树形结构</strong>，操作系统检索一个文件，都是从根目录开始，按层次解析路径中的所有目录，直到定位到文件。</li>
<li><strong>inode(索引节点)模块</strong>：<strong>管理一个具体的文件，是文件的唯一标识，一个文件对应一个 inode</strong>。通过 <code>inode</code> 可以方便的找到文件在磁盘扇区的位置。同时 <code>inode</code> 模块可链接到 <code>address_space</code> 模块，方便查找自身文件数据是否已经缓存。<strong>inode是记录每个文件分别包含哪些磁盘块的方法。</strong></li>
<li><strong>打开文件列表模块</strong>：包含<strong>所有内核已经打开的文件</strong>。已经打开的文件对象由 <code>open</code> 系统调用在内核中创建，也叫<strong>文件句柄</strong>。打开文件列表模块中包含一个列表，每个列表表项是一个结构体 struct file，结构体中的信息用来表示打开的一个文件的各种状态参数。</li>
<li><strong>file_operations</strong> 模块：这个模块中维护一个数据结构，是一系列函数指针的集合，其中包含所有可以使用的系统调用函数，例如 <code>open</code> 、<code>read</code> 、<code>write</code> 、<code>mmap</code> 等。每个打开文件(打开文件列表模块的一个表项)都可以连接到 <code>file_operations</code> 模块，从而对任何已打开的文件，通过系统调用函数，实现各种操作。</li>
<li><strong>address_space(地址空间)</strong> 模块：它<strong>表示一个文件在页缓存中已经缓存了的物理页</strong>。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么 <strong>address_space</strong> 可以说关联了内存系统和文件系统。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj9hrh4e9j30hf0er0ul.jpg" alt="3"></p>
<hr>
<h4><span id="io-缓冲区buffer">I/O 缓冲区(buffer)</span></h4><h5><span id="概念"><strong>概念</strong></span></h5><p>如高速缓存(cache)产生的原理类似，在 I/O 过程中，<strong>读取磁盘的速度相对内存读取速度要慢的多</strong>。因此为了能够加快处理数据的速度，需要<strong>将读取过的数据缓存在内存里</strong>。而这些缓存在内存里的数据就是高速缓冲区(buffer cache)，下面简称为 <strong>buffer</strong>。</p>
<p>具体来说，<code>buffer</code> 是一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。一方面，通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。另一方面，可以保护硬盘或减少网络传输的次数。</p>
<h5><span id="buffer-和-cache"><strong>Buffer 和 Cache</strong></span></h5><p><code>buffer</code> 和 <code>cache</code> 是两个不同的概念：</p>
<p><code>cache</code> 是<strong>高速缓存</strong>，用于 <strong>CPU 和内存</strong>之间的缓冲；</p>
<p><code>buffer</code> 是 I/O 缓存，用于<strong>内存和硬盘</strong>的缓冲。</p>
<p>简单的说，<strong>cache 是加速读，而 buffer 是缓冲写</strong>，<strong>前者解决读的问题，保存从磁盘上读出的数据，后者是解决写的问题，保存即将要写入到磁盘上的数据。</strong></p>
<h5><span id="buffer-cache和-page-cache"><strong>Buffer Cache和 Page Cache</strong></span></h5><p><code>buffer cache(块缓存)</code> 和 <code>page cache(页缓存)</code> 都是为了处理设备和内存交互时高速访问的问题。</p>
<p><code>buffer cache</code> 可称为块缓冲器，<code>page cache</code> 可称为页缓冲器。</p>
<p>在 <code>Linux</code> 不支持虚拟内存机制之前，还没有页的概念，因此缓冲区以块为单位对设备进行。在 Linux 采用虚拟内存的机制来管理内存后，页是虚拟内存管理的最小单位，开始采用页缓冲的机制来缓冲内存。Linux2.6 之后内核将这两个缓存整合，页和块可以相互映射，同时<strong>页缓存 <code>page cache</code> 面向的是虚拟内存，块 I/O 缓存 <code>Buffer cache</code> 是面向块设备</strong>。需要强调的是页缓存和块缓存对进程来说就是一个存储系统，进程不需要关注底层的设备的读写。</p>
<p><code>buffer cache</code> 和 <code>page cache</code> 两者最大的区别是<strong>缓存的粒度</strong>。<code>buffer cache</code> 面向的是<strong>文件系统的块</strong>，而内核的内存管理组件采用了比文件系统的块更高级别的抽象：页(page)，其处理的性能更高。因此<strong>和内存管理交互的缓存组件，都使用页缓存</strong>。</p>
<p><code>Page Cache</code> 页缓存是<strong>面向文件，面向内存</strong>的。通俗来说，<strong>它位于内存和文件之间缓冲区，文件 I/O 操作实际上只和 page cache 交互，不直接和内存交互</strong>。<code>page cache</code> 可以用在所有以文件为单元的场景下，比如网络文件系统等等。<code>page cache</code> 通过一系列的数据结构，比如 <code>inode</code> , <code>address_space</code> , <code>struct page</code> ，实现将一个文件映射到页的级别：</p>
<ol>
<li><strong>struct page</strong> 结构标志一个<strong>物理内存页</strong>，通过 <code>page + offset</code> 就可以将此页帧定位到一个文件中的具体位置。同时 <code>struct page</code> 还有以下重要参数：<ol>
<li>标志位 <code>flags</code> 来记录该页是否是脏页，是否正在被写回等等；</li>
<li><code>mapping</code> 指向了地址空间 <code>address_space</code>，表示这个页是一个页缓存中的页，和一个文件的地址空间对应；</li>
<li><code>index</code> 记录这个页在文件中的页偏移量；</li>
</ol>
</li>
<li>文件系统的 <strong>inode</strong> 实际维护了这个文件所有的 <code>block</code> 的块号，通过对文件偏移量 <code>offset</code> 取模可以很快定位到这个偏移量所在的文件系统的块号，磁盘的扇区号。同样，通过对文件偏移量 <code>offset</code> 进行取模可以计算出偏移量所在的页的偏移量。</li>
<li><strong>page cache</strong> 缓存组件抽象了地址空间 <code>address_space</code> 这个概念来作为文件系统和页缓存的中间桥梁。地址空间 <code>address_space</code> 通过指针可以方便的获取文件 <code>inode</code> 和 <code>struct page</code> 的信息，所以可以很方便地定位到一个文件的 <code>offset</code> 在各个组件中的位置，即通过：<strong>文件字节偏移量 –&gt; 页偏移量 –&gt; 文件系统块号 block –&gt; 磁盘扇区号</strong>。</li>
<li>页缓存实际上就是采用了一个<strong>基数树结构</strong>将一个文件的内容组织起来存放在物理内存 <code>struct page</code> 中。一个文件 <code>inode</code> 对应一个地址空间 <code>address_space</code> 。而一个 <code>address_space</code> 对应一个页缓存基数树，它们之间的关系如下：</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj9hl7i3oj30or0e8mzv.jpg" alt="2"></p>
<hr>
<h4><span id="文件读写基本流程">文件读写基本流程</span></h4><h5><span id="读文件"><strong>读文件</strong></span></h5><ol>
<li>进程调用库函数向内核发起读文件请求；</li>
<li>内核通过<strong>检查进程的文件描述符定位到虚拟文件系统的已打开文件列表项</strong>；</li>
<li>调用该文件可用的系统调用函数 <code>read()</code>；</li>
<li><code>read()</code> 函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的 <code>inode</code>；</li>
<li>在 <code>inode</code> 中，通过文件内容偏移量计算出要读取的页；</li>
<li>通过 <code>inode</code> 找到文件对应的 <code>address_space</code>；</li>
<li>在 <code>address_space</code> 中访问该文件的页缓存树，查找对应的页缓存结点：<ol>
<li>如果页缓存命中，那么直接返回文件内容；</li>
<li>如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过<code>inode</code> 找到文件该页的磁盘地址，读取相应的页填充该缓存页；</li>
<li>重新进行第 6 步查找页缓存；</li>
</ol>
</li>
<li>文件内容读取成功。</li>
</ol>
<p>总结一下：<code>inode</code> 管磁盘，<code>address_space</code> 接内存，两者互相指针链接。</p>
<p><code>Inode</code> 是文件系统(VFS)下的概念，通过 <strong>一个 inode 对应一个文件</strong> 使得文件管理按照类似索引的这种树形结构进行管理，通过 <code>inode</code> 快速的找到文件在磁盘扇区的位置；但是这种管理机制并不能满足读写的要求，因为我们修改文件的时候是先修改内存里的，所以就有了页缓存机制，作为内存与文件的缓冲区。<br><code>address_space</code> 模块表示一个文件在页缓存中已经缓存了的物理页。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么 <code>address_space</code> 可以说关联了内存系统和文件系统。</p>
<hr>
<h5><span id="写文件"><strong>写文件</strong></span></h5><p>前5步和读文件一致，在 <code>address_space</code> 中查询对应页的页缓存是否存在；</p>
<ol>
<li>如果页缓存命中，直接把文件内容修改更新在页缓存的页中，写文件就结束了。这时候<strong>文件修改位于页缓存，并没有写回到磁盘文件中去</strong>。</li>
<li>如果<strong>页缓存缺失</strong>，那么产生一个<strong>缺页异常</strong>，创建一个页缓存页，同时通过 <code>inode</code> 找到文件该页的磁盘地址，<strong>读取相应的页填充该缓存页</strong>。此时缓存页命中，进行第 6 步。</li>
<li>一个页缓存中的页如果被修改，那么会被标记成脏页，<strong>脏页需要写回到磁盘中的文件块</strong>。有两种方式可以把脏页写回磁盘：<ol>
<li>手动调用 <code>sync()</code> 或者 <code>fsync()</code> 系统调用把脏页写回；</li>
<li><code>pdflush</code> 进程会定时把脏页写回到磁盘。</li>
</ol>
</li>
</ol>
<p>同时注意，<strong>脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</strong></p>
<hr>
<h4><span id="linux-io-读写方式">Linux I/O 读写方式</span></h4><p>Linux 提供了<strong>轮询</strong>、<strong>I/O 中断</strong>以及 <strong>DMA 传输</strong>这 3 种磁盘与主存之间的数据传输机制。其中轮询方式是基于死循环对 I/O 端口进行不断检测。I/O 中断方式是指当数据到达时，磁盘主动向 CPU 发起中断请求，由 CPU 自身负责数据的传输过程。 DMA 传输则在 I/O 中断的基础上引入了 DMA 磁盘控制器，由 DMA 磁盘控制器负责数据的传输，降低了 I/O 中断操作对 CPU 资源的大量消耗。</p>
<h5><span id="io-中断">I/O 中断</span></h5><p>在 DMA 技术出现之前，应用程序与磁盘之间的 I/O 操作都是通过 CPU 的中断完成的。每次用户进程读取磁盘数据时，都需要 CPU 中断，然后发起 I/O 请求等待数据读取和拷贝完成，每次的 I/O 中断都导致 CPU 的上下文切换。</p>
<hr>
<h3><span id="linux下如何定位内存泄露valgrind">Linux下如何定位内存泄露？<strong>valgrind</strong></span></h3><p><code>Valgrind</code> 是一套 <code>Linux</code> 下，开放源代码（GPL V2）的仿真调试工具的集合。<code>Valgrind</code> 由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。Valgrind的体系结构如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e73214ed85cb2efb741c29ef16e219ed_720w.jpg" alt="img"></p>
<hr>
<h3><span id="cache的结构与工作原理">Cache的结构与工作原理</span></h3><p>高速缓冲存储器是存在于主存与 <code>CPU</code> 之间的一级存储器， 由静态存储芯片 <code>SRAM</code> 组成，容量比较小但速度比主存高得多， <strong>接近于CPU的速度</strong>。 <code>Cache</code> 的功能是用来<strong>存放那些近期需要运行的指令与数据，目的是提高CPU对存储器的访问速度</strong>。为此需要解决两个技术问题：一是<strong>主存地址与缓存地址的映象及转换</strong>； 二是<strong>按一定原则对Cache的内容进行替换</strong>。</p>
<p><code>Cache</code> 是介于<strong>CPU与主内存</strong>之间、或者<strong>主内存与磁盘</strong>之间的高速缓冲器，其作用是<strong>解决系统中数据读写速度不匹配的问题</strong>。其中介于CPU与主内存之间的缓冲器又称为 <code>RAM Cache</code> ，而介于主内存与磁盘驱动器之间的缓冲器则称之为 <code>Disk Cache</code> ，这里要讨论的是前者，也就通常简称的 <code>Cache</code> 。</p>
<p><img src="https://img-blog.csdnimg.cn/20190517100335193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZJTExNT1JFYWQ=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>首先，要想理解 <code>cache</code> ，先理解内存。内存的简单表示如下图，内存里面的内容的查找是根据地址来进行的，也就是说内存包含两点：<strong>地址</strong>和<strong>内存的内容（存的数据）</strong>，根据地址来找数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20190118103657278.png" alt="img"></p>
<p> <code>0000-0008</code> 是地址，<code>A-I</code> 是存的数据，<code>cpu</code> 根据地址去寻找数据。图中的一个字母代表一个字节的数据。</p>
<p><img src="https://img-blog.csdn.net/20171123134230506" alt="img"></p>
<p><strong><code>cache</code> 中的数据就是物理内存中的数据的子集</strong>，那么对于物理内存的一个数据，根据<strong>cache中可以放置这个数据位置的多少</strong>，可以分为三种：</p>
<ol>
<li>如果 <code>cache</code> 中只有一个位置可以容纳这个数据，每个主存块映射到 <code>cache</code> 的固定行中，则为<strong>直接映射</strong>的 <code>cache</code> ；</li>
<li>如果 <code>cache</code> 中有多个地方可以放置这个数据，每个主存块映射到 <code>cache</code> 的固定组的任意行中，它就是<strong>组相联</strong>的 <code>cache</code> ；</li>
<li>如果 <code>cache</code> 中的任何地方都可以放置这个数据，每个主存块映射到 <code>cache</code> 的任意行中，那么它就是<strong>全相连</strong>的 <code>cache</code> 。</li>
</ol>
<p><code>cache</code> 的结构其实和内存的结构类似，也包含<strong>地址和内容</strong>，只是 <code>cache</code> 的内容除了存的数据 <code>data</code> 之外，还包含<strong>存的数据的物理内存的地址信息(tag)</strong>，因为<strong>CPU发出的寻址信息都是针对物理内存发出的</strong>，所以 <code>cache</code> 中除了要保存数据信息之外，还要保存数据对应的地址，这样才能在 <code>cache</code> 中根据物理内存的地址信息查找物理内存中对应的数据。为了加快寻找速度，<code>cache</code> 中一般还包含一个有效位 <code>valid</code> ，用来标记这个 <code>cache line</code> 是否保存着有效的数据。一个 <code>tag</code> 和它对应的数据组成的一行称为一个 <code>cache line</code> 。如下图所示，下表中的一行就是一个 <code>cache line</code> 。</p>
<p><img src="https://img-blog.csdn.net/20171123110419140" alt="img"></p>
<p>知道了 <code>cache</code> 的结构之后，如何在 <code>cache</code> 中去寻找对应的数据呢？简单起见，我们先选择<strong>直接映射</strong>的 <code>cache</code> 组成方式进行下文的分析。首先对于一段物理内存 <code>block</code> ，该物理内存上的每个字节的地址划分为以下几段：</p>
<p><img src="https://img-blog.csdn.net/20171123144706226" alt="img"></p>
<p>这样的话物理内存中的数据到 <code>cache</code> 的映射关系如下图所示(当然，这里为了方便省略了内存地址通过<strong>TLB</strong>的虚实转换部分，内存地址的 <code>Tag</code> 部分其实是需要先经过 <code>TLB</code> 的转化才能够去和 <code>cache line</code> 的 <code>tag</code> 部分去进行匹配的)。</p>
<p><img src="https://img-blog.csdn.net/20171123144810407" alt="img"></p>
<p>上图的映射原则就是：<strong>根据物理地址的中间三位(index字段)来定位当前数据应该在cache的哪一行，把物理地址的tag字段和该地址对应的内容放入对应的cache line的tag字段和data字段，并把相应的valid位置1</strong>。那么在之后进行 <code>cache</code> 寻找的时候就可以根据 <code>cache line</code> 的 <code>tag</code> 字段来辨认当前 <code>line</code> 中的数据是数据哪个 <code>block</code> 的。</p>
<p>内存地址的最高两位为 <code>Tag</code> 字段，中间三位为 <code>index</code> 字段，最低两位为 <code>Block Offset</code> 字段；由于 <code>Block Offset</code> 是两位，也就是一个 <code>block</code> 的大小保存了$2^2=4$个字节的数据，也就是一个 <code>cache line</code> 的 <code>data</code> 字段包含 <code>4</code> 个字节的数据；<code>index</code>为3位，说明 <code>cache</code> 共包含$2^3=8$个组（对于直接映射的cache，也称为8个行）；很明显，<code>cache</code> 的一个行中只能存储1块 <code>Block</code> =4字节的数据，但是按照上图的<strong>直接映射</strong>方式，会有$2^{tag位数} = 2^2 = 4$块的数映射到同一个行，此时通过 <code>Tag</code> 字段的比较来辨别是不是我们要取数据的地址(每个 <code>tag</code> 对应一个 <code>block</code> )，如果不是的话，也就是发生了<strong>cache的缺失</strong>。</p>
<p>如上图的 <code>Block 0</code> 和 <code>Block 1</code> 的 <code>index</code> 字段都是 <code>000</code> ，按照上面的理论它们都应该映射到第 <code>000=0</code> 行（这儿的行也就是组），此时进一步定量分析的话，共有 <code>4</code> 个数据块竞争使用 <code>cache</code> 第 <code>0</code> 行的位置，也就是说<strong>cache的命中率为25%</strong>。</p>
<p><strong>总结</strong></p>
<ol>
<li>物理内存的<strong>索引字段(Index)选择cache的行</strong>，<strong>通过对比物理内存和cache line的Tag来判断是否命中(实际上需要通过TLB进行转换)</strong>。</li>
<li>块偏移字段( <code>Block Offset</code> )可以从 <code>cache line</code> 的数据块中选择期望数据。注意在这个过程中 <code>cache</code> 的 <code>index</code> 是不占空间的，它就类似于物理内存的地址，<strong>对于物理内存来说是通过地址去寻找数据，对于cache来说，是通过index来找到对应的cache line</strong>，或者更通俗的讲就是：<strong>cache line的地址对应的就是物理内存的index字段。</strong></li>
<li>此时该 <code>cache</code> 的容量计算如下：每一个 <code>cache line</code> 的数据字段占 <code>4</code> 个字节，共$2^3=8$行，所以数据占据 <code>4×8=32</code> 个字节，一个 <code>cache line</code> 中 <code>tag</code> 字段和 <code>valid</code> 位占 <code>2+1=3bit</code>，整个 <code>cache</code> 的 <strong>tag+valid=3bit×8行=24bit=3Byte</strong>，通常情况下我们都是以 <code>cache</code> 中数据部分占的空间表示 <code>cache</code> 的容量，也就是 <code>32</code> 字节，但是实际上，它还额外多占用了 <code>3</code> 字节的存储空间</li>
</ol>
<p>如果是<strong>组相连的cache</strong>，<strong>每个组(set)里面包含多个行(line)，通过内存地址的index字段来寻址组，确定组之后再根据tag来确定是否命中</strong>；</p>
<p><strong>对于全相连的cache，就不需要index字段了，因为全相连的cache相当于只有一个组的组相连cache</strong>。这时只需要根据要寻址的地址的 <code>tag</code> 来逐一与 <code>cache</code> 中的 <code>tag</code> 字段比较，如果有与之匹配的 <code>cache line</code> ，也就是 <code>cache hit</code> 了，如果遍历整个 <code>cache</code> ，也没有找到匹配的 <code>cache line</code>，那就是 <code>cache miss</code> 了。</p>
<h4><span id="cache-line">Cache Line</span></h4><p><code>Cache Line</code> 可以理解为CPU Cache中的最小缓存单位。<code>Main Memory-Cache</code> 或 <code>Cache-Cache</code> 之间的数据传输不是以字节为最小单位，而是以 <code>Cache Line</code> 为最小单位，称为缓存行。</p>
<p>目前主流的 <code>Cache Line</code> 大小都是<strong>$2^6=64$字节</strong>，假设有一个 <code>64K</code> 字节的 <code>Cache</code> ，那这个 <code>Cache</code> 所能存放的 <code>Cache Line</code> 的个数就是 <code>1K</code> 个。</p>
<h4><span id="写入策略">写入策略</span></h4><p><code>Cache</code> 的写入策略有两种，分别是<strong>WriteThrough（直写模式）</strong>和<strong>WriteBack（回写模式）</strong>。</p>
<ul>
<li><strong>直写模式：</strong>在数据更新时，<strong>将数据同时写入内存和Cache</strong>，该策略操作简单，但是因为每次都要写入内存，<strong>速度较慢</strong>。</li>
<li><strong>回写模式：</strong>在数据更新时，<strong>只将数据写入到Cache中，只有在数据被替换出Cache时，被修改的数据才会被写入到内存中，该策略因为不需要写入到内存中，所以速度较快</strong>。但数据仅写在了 <code>Cache</code> 中，<code>Cache</code> 数据和内存数据不一致，此时如果有其它CPU访问数据，就会读到脏数据，出现bug，所以这里需要用到<strong>Cache的一致性协议来保证CPU读到的是最新的数据。</strong></li>
</ul>
<h4><span id="cache一致性问题"><strong>Cache一致性</strong>问题</span></h4><p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanlong300/p/8986041.html</a></p>
<p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI。多个CPU对某块内存同时读写，就会引起冲突的问题，被称为<strong>Cache一致性问题</strong>。有这样一种情况：</p>
<p>  <strong>a.</strong>   <code>CPU1</code> 读取了一个字节 <code>offset</code> ，该字节和相邻的数据就都会被写入到 <code>CPU1</code> 的 <code>Cache</code> .</p>
<p>  <strong>b.</strong>   此时 <code>CPU2</code> 也读取相同的字节 <code>offset</code> ，这样 <code>CPU1</code> 和 <code>CPU2</code> 的 <code>Cache</code> 就都拥有同样的数据。</p>
<p>  <strong>c.</strong>   <code>CPU1</code> 修改了 <code>offset</code> 这个字节，被修改后，这个字节被写入到 <code>CPU1</code> 的 <code>Cache</code> 中，但是没有被同步到内存中。</p>
<p>  <strong>d.</strong>   <code>CPU2</code> 需要访问 <code>offset</code> 这个字节数据，但是由于最新的数据并没有被同步到内存中，所以 <code>CPU2</code> 访问的数据不是最新的数据。</p>
<h5><span id="mesi缓存一致性协议">MESI缓存一致性协议</span></h5><p>这种问题就被称为 <code>Cache</code> 一致性问题，为了解决这个问题大佬们设计了<strong>MESI协议</strong>：</p>
<blockquote>
<p>当一个CPU1修改了Cache中的某字节数据时，那么其它的所有CPU都会收到通知，它们的<strong>相应Cache就会被置为无效状态</strong>，当其他的CPU需要访问此字节的数据时，发现自己的Cache相关数据已失效，这时CPU1会立刻把数据写到内存中，其它的CPU就会立刻从内存中读取该数据。</p>
</blockquote>
<p><strong>MESI协议</strong>是通过四种状态的控制来解决 <code>Cache</code> 一致性的问题：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
<th>监听任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本 <code>Cache</code> 中。</td>
<td>缓存行必须时刻监听所有<strong>试图从主存中读该缓存行</strong>的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。(可以看作是只有这个Cache完成了Remote read，从主内存中读取了line)</td>
<td>缓存行也必须监听其它缓存<strong>读主存中该缓存行的操作</strong>，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
<td>没有了远端写入和远端读取操作</td>
</tr>
</tbody>
</table>
<p>从上面的意义看来 <code>E</code> 状态是一种投机性的优化：如果一个CPU想修改一个处于 <code>S</code> 状态的缓存行，总线事务需要将所有该缓存行的 <code>copy</code> 变成 <code>invalid</code> 状态，而修改E状态的缓存不需要使用总线事务。</p>
<h4><span id="l1-cachel2-cachel3-cache">L1 Cache/L2 Cache/L3 Cache</span></h4><p>CPU在缓存中找到有用的数据被称为命中，当缓存中没有CPU所需的数据时（这时称为未命中），CPU才访问内存。从理论上讲，在一颗拥有二级缓存的CPU中，读取一级缓存的命中率为80% 。也就是说CPU一级缓存中找到的有用数据占数据总量的80%，剩下的20%从二级缓存中读取。由于不能准确预测将要执行的数据，读取二级缓存的命中率也在80%左右（从二级缓存读到有用的数据占总数据的16% ）。那么还有的数据就不得不从内存调用，但这已经是一个相当小的比例了。目前的较高端的CPU中，还会带有三级缓存，它是为读取二级缓存后未命中的数据设计的—种缓存，在拥有三级缓存的CPU中，只有约5%的数据需要从内存中调用 ，这进一步提高了CPU的效率。</p>
<p>程序局部性分为<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p>
<ul>
<li>时间局部性是指被CPU访问的数据，短期内还要被继续访问，比如循环、递归、方法的反复调用等。</li>
<li>空间局部性是指被CPU访问的数据相邻的数据，CPU短期内还要被继续访问，比如顺序执行的代码、连续创建的两个对象、数组等。因为如果将刚刚访问的数据和相邻的数据都缓存到Cache时，那下次CPU访问时，可以直接从Cache中读取，提高CPU访问数据的速度。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEribOicpWLdXXwnN18ia5Ew0ee0r7o1NFm4ztG5fR6HPsn5lxAx5sic3K7rWokRr0upbmADY8tRmDzBn4g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>CPU产品中，一级缓存的容量基本在 <code>4KB</code> 到 <code>64KB</code> 之间，二级缓存的容量则分为 <code>128KB</code> 、<code>256KB</code> 、<code>512KB</code> 、<code>1MB</code> 、<code>2MB</code> 等。<strong>一级缓存容量各产品之间相差不大，而二级缓存容量则是提高CPU性能的关键。</strong> 二级缓存容量的提升是由CPU制造工艺所决定的，容量增大必然导致CPU内部晶体管数的增加，要在有限的CPU面积上集成更大的缓存，对制造工艺的要求也就越高。</p>
<ul>
<li><code>L1 Cache</code> 总是位于CPU内部，用来将已解码的指令调入CPU的执行引擎，对于那些频繁使用的关键字，多数芯片有第二个 <code>L1 Cache</code> ，典型的 <code>L1 Cache</code> 的大小为 <code>64KB</code> 。<code>L1 Cache</code> 是最离CPU最近的，它容量最小，速度最快，每个CPU都有 <code>L1 Cache</code>，其实每个CPU都有两个 <code>L1 Cache</code> ，一个是 <code>L1D Cache</code> ，用于存取数据，另一个是 <code>L1I Cache</code> ，用于存取指令。</li>
<li><code>L2 Cache</code> 容量较L1大，速度较L1较慢，每个CPU也都有一个 <code>L2 Cache</code> 。<code>L2 Cache</code> 制造成本比 <code>L1 Cache</code> 更低，它的作用就是存储那些CPU需要用到的且 <code>L1 Cache miss</code> 的数据。<code>L2 Cache</code> 用来存放最近使用过的关键字，一般是 <code>MB</code> 为单位。<code>L1 Cache</code> 和 <code>L2 Cache</code> 的<strong>最大不同在于是否有延迟，访问L1 Cache没有任何的延迟，访问L2 cache会有1-2个时钟周期的延迟。</strong></li>
<li><code>L3 Cache</code> 容量较 <code>L2</code> 大，速度较 <code>L2</code> 慢，<code>L3 Cache</code> 不同于 <code>L1 Cache</code> 和 <code>L2 Cache</code> ，它是所有CPU共享的，可以把它理解为速度更快，容量更小的内存。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEribOicpWLdXXwnN18ia5Ew0ee0Q3PS1O2sibKawndLsCMkoBMIrZTByiaAusR4zJfYznic71N45lwziantDw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<hr>
<h3><span id="如何确定线程池的线程数量">如何确定线程池的线程数量?</span></h3><ul>
<li>如果是<strong>CPU密集型应用</strong>，则线程池大小设置为 <code>N+1</code>  （N为CPU总核数）</li>
<li>如果是<strong>IO密集型应用</strong>，则线程池大小设置为 <code>2N+1</code> （N为CPU总核数）</li>
<li><strong>线程等待时间(IO)所占比例越高，需要越多线程</strong>。</li>
<li><strong>线程CPU时间所占比例越高，需要越少线程</strong>。</li>
</ul>
<p>一个系统最快的部分是CPU，所以决定一个系统吞吐量上限的是CPU。增强CPU处理能力，可以提高系统吞吐量上限。但根据短板效应，真实的系统吞吐量并不能单纯根据CPU来计算。那要提高系统吞吐量，就需要从“系统短板”（比如网络延迟、IO）着手：</p>
<ol>
<li>尽量提高短板操作的并行化比率，比如多线程下载技术</li>
<li>增强短板能力，比如用NIO替代IO</li>
</ol>
<hr>
<h3><span id="大小端模式">大小端模式</span></h3><ul>
<li>小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。</li>
<li>大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。</li>
</ul>
<p>将 <code>0x12345678</code> 写入到以 <code>1000h</code> 开始的内存中，这里 <code>0x12346578</code> 中 <code>0x12~0x78</code> 的地址是从高到低</p>
<p>如果，我们的机器是小端存储的话，结果为:</p>
<blockquote>
<p>数据      地址<br>0x78        1000H<br>0x56        1001H<br>0x34        1002H<br>0x12        1003H</p>
</blockquote>
<p>如果我们的机器是大端存储的话,结果为:</p>
<blockquote>
<p>数据      地址<br>0x12        1000H<br>0x34        1001H<br>0x56        1002H<br>0x78        1003H</p>
</blockquote>
<h4><span id="判断方式">判断方式</span></h4><p>在 <code>union</code> 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同</p>
<p>的起始地址。即上述的 <code>union</code> 虽然定义了两个成员，但其实这个 <code>union</code> 只占用了4个字节(32位机器中)，往 <code>a</code> 成员赋值，然后读取 <code>b</code> 就相当于读取 <code>a</code> 成员的低位第一个字节的值。如果机器使用大端模式，则 <code>u.a=1</code> 那 <code>a</code> 的最高字节值为1；如果机器使用小段模式，则 <code>u.a=1</code> ，<code>a</code> 的最低位字节为1。上述可知 <code>b</code> 和 <code>a</code> 有相同的起始位，所以读取 <code>b</code> 如果等于1，则为小端模式，<code>b</code> 为0则为大端模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> p&#123;  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="keyword">char</span> b;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    p p1;  </span><br><span class="line">    p1.a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> p1.a == p1.b;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(judge())&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"小端"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"大端"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="linux-kill操作">Linux kill操作</span></h3><p><strong>杀掉一个进程</strong> <strong>-9 代表什么</strong>（强制kill，告知进程是以信号的方式） <strong>还有什么其他参数</strong> 、 <strong>使用kill命令后，操作系统是如何通知进程的</strong>（这里回答了进程间交互，后来在引导下讲了socket，最后没有得到很好的回答）</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/22/C++基础总结/" rel="next" title="C++基础总结">
                <i class="fa fa-chevron-left"></i> C++基础总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/26/计算机网络总结/" rel="prev" title="计算机网络总结">
                计算机网络总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">344</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">91</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">Linux的内存不足时会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统的四大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.</span> <span class="nav-text">死锁/活锁/饥饿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">死锁预防方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">银行家算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.</span> <span class="nav-text">活锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.</span> <span class="nav-text">饥饿</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.4.</span> <span class="nav-text">⭐进程和线程的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.5.</span> <span class="nav-text">多进程和多线程的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.6.</span> <span class="nav-text">多进程和多线程的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.</span> <span class="nav-text">线程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.</span> <span class="nav-text">临界区(进程同步)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.8.1.</span> <span class="nav-text">临界区实现：忙等互斥</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.9.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.9.1.</span> <span class="nav-text">CAS原子操作(compare and swap)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.</span> <span class="nav-text">进程间如何通信？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.2.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">无名管道(pipe)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">有名管道(FIFO)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.3.</span> <span class="nav-text">信号(signal)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.4.</span> <span class="nav-text">消息队列(message queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.5.</span> <span class="nav-text">共享内存(shared memory)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.6.</span> <span class="nav-text">信号量(semophore )</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.6.1.</span> <span class="nav-text">信号量工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.6.2.</span> <span class="nav-text">semget函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.6.3.</span> <span class="nav-text">semop函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.6.4.</span> <span class="nav-text">semctl函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.6.5.</span> <span class="nav-text">C++11实现信号量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.10.7.</span> <span class="nav-text">套接字(socket)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.</span> <span class="nav-text">进程的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.1.</span> <span class="nav-text">三态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.2.</span> <span class="nav-text">五态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.3.</span> <span class="nav-text">七态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.4.</span> <span class="nav-text">进程状态控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.11.5.</span> <span class="nav-text">线程状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.12.</span> <span class="nav-text">进程切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.13.</span> <span class="nav-text">linux的进程控制块(PCB)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.</span> <span class="nav-text">Linux RCU机制(内核同步机制)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.1.</span> <span class="nav-text">增加链表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.2.</span> <span class="nav-text">访问链表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.14.3.</span> <span class="nav-text">更新链表项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.</span> <span class="nav-text">孤儿进程/僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.1.</span> <span class="nav-text">问题及危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.2.</span> <span class="nav-text">wait/waitpid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.3.</span> <span class="nav-text">孤儿进程解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.15.4.</span> <span class="nav-text">僵尸进程解决办法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.</span> <span class="nav-text">写时复制(COW)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.1.</span> <span class="nav-text">exec族函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.2.</span> <span class="nav-text">进程中的环境变量说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.16.3.</span> <span class="nav-text">如果一个进程2GB， fork 之后这两个进程占用多少内存？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.17.</span> <span class="nav-text">进程/线程的上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.17.1.</span> <span class="nav-text">进程的上下文可以分为哪几个部分？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.17.2.</span> <span class="nav-text">为什么切换线程比切换进程开销小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.18.</span> <span class="nav-text">多线程间通信和同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.</span> <span class="nav-text">进程的切换时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.19.1.</span> <span class="nav-text">切换时需要保存哪些数据？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.</span> <span class="nav-text">⭐协程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.20.1.</span> <span class="nav-text">libco库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.</span> <span class="nav-text">五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.1.</span> <span class="nav-text">阻塞IO(BIO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.2.</span> <span class="nav-text">非阻塞IO(NIO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.3.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.4.</span> <span class="nav-text">信号驱动的IO模型(SIGIO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.21.5.</span> <span class="nav-text">异步IO模型(AIO)(非阻塞)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.22.</span> <span class="nav-text">两种IO事件处理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.22.1.</span> <span class="nav-text">Reactor模式(同步的)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.22.2.</span> <span class="nav-text">Proactor模式 (异步)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.</span> <span class="nav-text">⭐IO多路复用：select/poll/epoll(同步/阻塞)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.1.</span> <span class="nav-text">epoll 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.2.</span> <span class="nav-text">epoll的底层实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.3.</span> <span class="nav-text">边缘触发ET&amp;水平触发LT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.4.</span> <span class="nav-text">使用epoll是否需要将socket设置为nonblocking?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.5.</span> <span class="nav-text">epoll的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.6.</span> <span class="nav-text">LT和ET的读写问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.7.</span> <span class="nav-text">ET模式的线程饥饿问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.8.</span> <span class="nav-text">EPOLLONESHOT设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.9.</span> <span class="nav-text">两种模式的选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.10.</span> <span class="nav-text">epoll的惊群问题(EPOLLEXCLUSIVE)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.23.3.11.</span> <span class="nav-text">边缘触发的IO应该怎么写？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.1.</span> <span class="nav-text">虚拟内存作为缓存的工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.2.</span> <span class="nav-text">内存分段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.3.</span> <span class="nav-text">内存分页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.4.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.5.</span> <span class="nav-text">多级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.5.1.</span> <span class="nav-text">K级页表层次结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.5.2.</span> <span class="nav-text">多级页表的优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.5.3.</span> <span class="nav-text">多级页表的劣势</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.6.</span> <span class="nav-text">TLB(Translation Lookaside Buffer) 页表缓存/快表/转换检测缓冲区(相关存储器实现)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.7.</span> <span class="nav-text">反向页表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.7.1.</span> <span class="nav-text">传统页表的缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.8.</span> <span class="nav-text">段页式内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.9.</span> <span class="nav-text">Linux虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.9.1.</span> <span class="nav-text">用户空间的内存分布</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.10.</span> <span class="nav-text">mmap内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.24.10.1.</span> <span class="nav-text">共享对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.25.</span> <span class="nav-text">缺页中断(page_fault)/缺页异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.26.</span> <span class="nav-text">页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.</span> <span class="nav-text">CPU调度算法/进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.0.1.</span> <span class="nav-text">先到先服务算法(FCFS, First-Come First-Served)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.0.2.</span> <span class="nav-text">最短作业优先(SJF, Shortest Job First)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.0.3.</span> <span class="nav-text">优先级算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.0.4.</span> <span class="nav-text">高响应比优先调度算法(HRRN)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.0.5.</span> <span class="nav-text">最短剩余时间优先 (SRTF, Shortest Remaining Time First)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.0.6.</span> <span class="nav-text">RR(Round Robin)调度器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.27.0.7.</span> <span class="nav-text">多级反馈队列(MFQ)：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.28.</span> <span class="nav-text">用户态与内核态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.28.0.1.</span> <span class="nav-text">三种情况会导致用户态到内核态的切换</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.</span> <span class="nav-text">Linux文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.1.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.2.</span> <span class="nav-text">虚拟文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.3.</span> <span class="nav-text">VFS主要模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.4.</span> <span class="nav-text">I/O 缓冲区(buffer)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.4.2.</span> <span class="nav-text">Buffer 和 Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.4.3.</span> <span class="nav-text">Buffer Cache和 Page Cache</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.5.</span> <span class="nav-text">文件读写基本流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.5.1.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.5.2.</span> <span class="nav-text">写文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.6.</span> <span class="nav-text">Linux I/O 读写方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.29.6.1.</span> <span class="nav-text">I/O 中断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.30.</span> <span class="nav-text">Linux下如何定位内存泄露？valgrind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.</span> <span class="nav-text">Cache的结构与工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.1.</span> <span class="nav-text">Cache Line</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.2.</span> <span class="nav-text">写入策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.3.</span> <span class="nav-text">Cache一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.3.1.</span> <span class="nav-text">MESI缓存一致性协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.31.4.</span> <span class="nav-text">L1 Cache/L2 Cache/L3 Cache</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.32.</span> <span class="nav-text">如何确定线程池的线程数量?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.33.</span> <span class="nav-text">大小端模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.33.1.</span> <span class="nav-text">判断方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.34.</span> <span class="nav-text">Linux kill操作</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
