<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,数据库,">










<meta name="description" content="数据库 Mysql相关 事务的特性(ACID) 如果不考虑隔离性，会发生什么事呢？ 四种隔离级别 什么是快照读、当前读 MySql如何解决幻读问题   数据库三范式 索引是个什么样的数据结构呢? B+树 MyISAM与InnoDB 的区别   什么是聚簇索引?   最左匹配 Redis Redis相比memcached有哪些优势 Redis常用的五种数据类型 string字符串 list列表">
<meta name="keywords" content="基础知识,数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库总结">
<meta property="og:url" content="http://chenqi1997.github.io/2020/12/28/数据库总结/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="数据库 Mysql相关 事务的特性(ACID) 如果不考虑隔离性，会发生什么事呢？ 四种隔离级别 什么是快照读、当前读 MySql如何解决幻读问题   数据库三范式 索引是个什么样的数据结构呢? B+树 MyISAM与InnoDB 的区别   什么是聚簇索引?   最左匹配 Redis Redis相比memcached有哪些优势 Redis常用的五种数据类型 string字符串 list列表">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq1.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq3.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq4.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq5.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq6.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq7.png">
<meta property="og:updated_time" content="2020-12-29T04:10:11.927Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据库总结">
<meta name="twitter:description" content="数据库 Mysql相关 事务的特性(ACID) 如果不考虑隔离性，会发生什么事呢？ 四种隔离级别 什么是快照读、当前读 MySql如何解决幻读问题   数据库三范式 索引是个什么样的数据结构呢? B+树 MyISAM与InnoDB 的区别   什么是聚簇索引?   最左匹配 Redis Redis相比memcached有哪些优势 Redis常用的五种数据类型 string字符串 list列表">
<meta name="twitter:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/12/28/数据库总结/">





  <title>数据库总结 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/12/28/数据库总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据库总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-28T17:46:00+08:00">
                2020-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#mysql相关">Mysql相关</a><ul>
<li><a href="#事务的特性acid">事务的特性(ACID)</a></li>
<li><a href="#如果不考虑隔离性会发生什么事呢">如果不考虑隔离性，会发生什么事呢？</a></li>
<li><a href="#四种隔离级别">四种隔离级别</a><ul>
<li><a href="#什么是快照读-当前读">什么是快照读、当前读</a></li>
<li><a href="#mysql如何解决幻读问题">MySql如何解决幻读问题</a></li>
</ul>
</li>
<li><a href="#数据库三范式">数据库三范式</a></li>
<li><a href="#索引是个什么样的数据结构呢">索引是个什么样的数据结构呢?</a><ul>
<li><a href="#b树">B+树</a></li>
<li><a href="#myisam与innodb-的区别">MyISAM与InnoDB 的区别</a></li>
</ul>
</li>
<li><a href="#什么是聚簇索引">什么是聚簇索引?</a></li>
</ul>
</li>
<li><a href="#最左匹配">最左匹配</a></li>
<li><a href="#redis">Redis</a><ul>
<li><a href="#redis相比memcached有哪些优势">Redis相比memcached有哪些优势</a></li>
<li><a href="#redis常用的五种数据类型">Redis常用的五种数据类型</a><ul>
<li><a href="#string字符串">string字符串</a></li>
<li><a href="#list列表">list列表</a></li>
<li><a href="#set集合">set集合</a></li>
<li><a href="#sorted-setzset有序集合">sorted set(zset)有序集合</a></li>
<li><a href="#hash哈希表">hash哈希表</a></li>
</ul>
</li>
<li><a href="#redis持久化">Redis持久化</a><ul>
<li><a href="#rdbredis-database-半持久化模式">RDB(Redis DataBase) 半持久化模式</a></li>
<li><a href="#aofappend-only-file-全持久化模式">AOF(Append-only file) 全持久化模式</a></li>
<li><a href="#存储结构">存储结构</a></li>
</ul>
</li>
<li><a href="#redis架构模式">Redis架构模式</a><ul>
<li><a href="#1-单机版">1. 单机版</a></li>
<li><a href="#2-主从复制">2. 主从复制</a></li>
<li><a href="#3-哨兵">3. 哨兵</a></li>
<li><a href="#4-集群proxy型">4. 集群(proxy型)</a></li>
<li><a href="#5-集群直连型">5. 集群(直连型)</a></li>
</ul>
</li>
<li><a href="#redis是单线程的但redis为什么这么快">Redis是单线程的，但Redis为什么这么快？</a></li>
<li><a href="#为什么redis用跳表不用红黑树">为什么redis用跳表不用红黑树</a></li>
<li><a href="#为什么redis不用b树">为什么redis不用b+树</a></li>
<li><a href="#redis的用途是什么">Redis的用途是什么？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h2><span id="数据库">数据库</span></h2><h3><span id="mysql相关">Mysql相关</span></h3><h4><span id="事务的特性acid">事务的特性(ACID)</span></h4><ol>
<li><strong>原子性（Atomicity）</strong>：原子性是指一个事务中的操作，<strong>要么全部成功，要么全部失败</strong>，如果失败，就回滚到事务开始前的状态。</li>
<li><strong>一致性（Consistency）</strong>：一致性是指<strong>事务必须使数据库从一个一致性状态变换到另一个一致性状态</strong>，也就是说一个事务执行之前和执行之后都必须处于一致性状态。那转账举栗子，A账户和B账户之间相互转账，无论如何操作，A、B账户的总金额都必须是不变的。</li>
<li><strong>隔离性（Isolation）</strong>：<strong>隔离性是当多个用户并发的访问数据库时，如果操作同一张表，数据库则为每一个用户都开启一个事务，且事务之间互不干扰，也就是说事务之间的并发是隔离的</strong>。再举个栗子，现有两个并发的事务T1和T2，T1要么在T2开始前执行，要么在T2结束后执行，如果T1先执行，那T2就在T1结束后在执行。关于数据的隔离性级别，将在后文讲到。</li>
<li><strong>持久性（Durability）</strong>：持久性就是指如果<strong>事务一旦被提交，数据库中数据的改变就是永久性的，即使断电或者宕机的情况下，也不会丢失提交的事务操作。</strong></li>
</ol>
<hr>
<h4><span id="如果不考虑隔离性会发生什么事呢">如果不考虑隔离性，会发生什么事呢？</span></h4><ol>
<li><p><strong>脏读</strong>(select问题)</p>
<p>脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>；</span><br><span class="line">updata t_table <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'wangwu'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">--此时事务2查询id = 1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>；<span class="comment">--未提交</span></span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;        <span class="comment">--查询到 id = 1， name = 'wangwu'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可重复读</strong>(update问题)</p>
<p>不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。</p>
<p>不可重复读和脏读的区别是，<strong>脏读读取到的是一个未提交的数据</strong>，而<strong>不可重复读读取到的是前一个事务提交的数据</strong>。而不可重复读在一些情况也并不影响数据的正确性，比如需要多次查询的数据也是要以最后一次查询到的数据为主。</p>
<p><strong>解决不可重复读的方法是 锁行</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = list, 事务2在此时提交</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = wangwu</span></span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> t_table <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'wangwu'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>幻读</strong>(insert/delete问题)</p>
<p>幻读是<strong>事务非独立执行</strong>时发生的一种现象。例如事务 <code>T1</code> 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 <code>T2</code> 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 <code>T1</code> 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是<strong>不可重复读查询的都是同一个数据项</strong>，而<strong>幻读针对的是一批数据整体</strong>（比如数据的个数）。</p>
<p><strong>解决幻读的方式是 锁表。</strong></p>
</li>
</ol>
<hr>
<h4><span id="四种隔离级别">四种隔离级别</span></h4><p>四种隔离级别主要解决的是脏读、幻读和不可重复读的问题。</p>
<ol>
<li><p><strong>读未提交(Read uncommitted)</strong></p>
<p>这种事务隔离级别下，<code>select</code> 语句不加锁。此时，可能读取到不一致的数据，即<strong>脏读</strong>。这是并发最高，一致性最差的隔离级别。</p>
</li>
<li><p><strong>读已提交(Read committed)</strong></p>
<p>可避免<strong>脏读</strong>的发生，但是会有<strong>幻读</strong>和<strong>不可重复读</strong>的问题。在互联网大数据量，高并发量的场景下，几乎 <strong>不会使用</strong> 上述两种隔离级别。</p>
<p>这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>不然，普通的查询是不会加锁的，若有事务对数据进行更新 <code>UPDATE</code> 操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p>
<blockquote>
<p>那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
</blockquote>
<p>这就要说到另一个机制<strong>快照(snapshot)</strong>，而这种既能保证一致性又不加锁的读也被称为快照读    （<strong>Snapshot Read</strong>）。假设没有“快照读”，那么<strong>当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞</strong>（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而“快照读”就可以完成高并发的查询，不过，读提交只能避免脏读，并不能避免不可重复读和幻读。</p>
</li>
</ol>
<p>​    <strong>快照读</strong>的意思是，数据有多个版本， 当事务并发执行时， 某一事务读取的数据来自其中一个版本（快照）。</p>
<ol>
<li><p><strong>可重复读(Repeatable read)</strong></p>
<p><code>MySql</code> 默认隔离级别。可避免 <strong>脏读</strong> 、<strong>不可重复读</strong> 的发生。不可重复读对应的是修改，即 <code>UPDATE</code> 操作。但是可能还会有幻读问题。因为幻读问题对应的是插入 <code>INSERT</code> 操作，而不是 <code>UPDATE</code> 操作。</p>
<p>在这个级别下，普通的查询同样是使用的<strong>快照读</strong>，但是，和读提交不同的是，当事务启动时，就不允许进行修改操作(<code>Update</code>) 了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。</p>
</li>
<li><p><strong>串行化(Serializable)</strong></p>
<p>可避免 <strong>脏读、不可重复读、幻读</strong> 的发生。 <code>Serializable</code> 是一致性最好的，性能最差的。这种级别下，事务串行化顺序执行，也就是一个一个排队执行。这种级别下，<code>脏读</code> 、<code>不可重复读</code> 、<code>幻读</code> 都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
</li>
</ol>
<p>上面四种隔离级别最高的是 <strong>Serializable</strong> 级别，最低的是 <strong>Read uncommitted</strong> 级别，当然级别越高，执行效率就越低。像 <strong>Serializable</strong> 这样的级别，就是以 <strong>锁表</strong> 的方式(类似于多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。</p>
<h5><span id="什么是快照读-当前读">什么是快照读、当前读</span></h5><ul>
<li><strong>快照读</strong>, 读取专门的快照 (对于 <code>RC</code> ，快照( <code>ReadView</code> )会在每个语句中创建。对于 <code>RR</code> ，快照是在事务启动时创建的)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的select操作即可(不需要加锁,如: select ... lock in share mode, select ... for update)</span><br></pre></td></tr></table></figure>
<p>针对的也是 <code>select</code> 操作</p>
<ul>
<li><strong>当前读</strong>, 读取最新版本的记录, 没有快照。 在 <code>InnoDB</code> 中，当前读取根本不会创建任何快照。当前读会在搜索的时候加锁</li>
</ul>
<h5><span id="mysql如何解决幻读问题">MySql如何解决幻读问题</span></h5><p>两点需要说明：</p>
<ol>
<li>在可重复读隔离级别下，普通查询是<strong>快照读</strong>，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。</li>
<li>幻读专指新插入的行，读到原本存在行的更新结果不算。因为<strong>当前读的作用就是能读到所有已经提交记录的最新值</strong>。如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。</li>
</ol>
<p><strong>幻读产生的原因</strong></p>
<p>　　行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。 </p>
<p><strong>如何解决幻读？</strong></p>
<ol>
<li><p>在<strong>快照读</strong>读情况下，<code>mysql</code> 通过<strong>mvcc</strong>来避免幻读。</p>
<p><code>SESSION_A</code> 执行一个查询，这个查询可以访问任何表，这个查询的目的是创建一个当前时间点的快照， <code>SESSION_B</code> 再插入一条记录并提交。由于 <code>SESSION_A</code> 第一次的查询开始于 <code>SESSION_B</code> 插入数据前，所以创建了一个以 <code>SELECT</code> 操作的时间为基准点的 <code>read view</code> ，避免了幻读的产生。所以在 <code>SESSION_A</code> 的事务结束前,无法看到 <code>SESSION_B</code> 对表 <code>read_view</code> 做出的任何更改 <code>(insert,delete,update)</code>。</p>
<p>简单的select操作(不包括 select … lock in share mode, select … for update)。</p>
<ul>
<li>Read Committed隔离级别：每次select都生成一个快照读。</li>
<li>Read Repeatable隔离级别：<strong>开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。</strong></li>
</ul>
<p>在RR级别下，<strong>快照读是通过MVVC(多版本控制)和undo log</strong>来实现的，<strong>当前读是通过加record lock(记录锁)和gap lock(间隙锁)</strong>来实现的。</p>
</li>
<li><p>在<strong>当前读</strong>读情况下，<code>mysql</code> 通过<strong>next-key</strong>来避免幻读</p>
<p><strong>Innodb</strong>行锁分为:</p>
<p>| 类型           | 说明                                                         |<br>| ————– | ———————————————————— |<br>| Record Lock:   | 在索引上对单行记录加锁.                                      |<br>| Gap Lock:      | 锁定一个范围的记录,但不包括记录本身.锁加在未使用的空闲空间上,可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间. |<br>| Next-Key Lock: | 行锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。 |</p>
<p>当前读读取的是最新版本, 并且<strong>对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</strong></p>
<p>例如，假设要 <code>update</code> 一条记录，但是另一个事务已经 <code>delete</code> 这条数据并且 <code>commit</code> 了，如果不加锁就会产生冲突。所以 <code>update</code> 的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。</p>
<p>当以当前读模式<code>select * from t5 where id=7 for update;</code>获取 <code>id=7</code> 的数据时,产生了 <code>Next-Key Lock</code> ，锁住了 <code>4-10</code> 范围和 <code>id=7</code> 单个 <code>record</code> ，从而阻塞了 <code>SESSION_B</code> 在这个范围内插入数据，而在除此之外的范围内是可以插入数据的。</p>
<p><strong>尽量使用唯一索引,因为唯一索引会把Next-Key Lock降级为Record Lock</strong></p>
</li>
</ol>
<hr>
<h4><span id="数据库三范式">数据库三范式</span></h4><ol>
<li><p>第一范式(确保每列保持<strong>原子性</strong>)</p>
<p>第一范式是最基本的范式。如果<strong>数据库表中的所有字段值都是不可分解的原子值</strong>，就说明该数据库表满足了第一范式。</p>
</li>
<li><p>第二范式(<strong>确保表中的每列都和主键相关</strong>)</p>
<p>第二范式在第一范式的基础之上更进一层。<strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）</strong>。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。(唯一性 一个表只说明一个事物)</p>
<p>主要是针对<strong>联合主键</strong>而言，比如有两个列都是主键，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式。这种情况需要进行表的拆分。</p>
</li>
<li><p>第三范式(<strong>确保每列都和主键列直接相关,而不是间接相关</strong>)</p>
<p>确保每列都和主键列直接相关,而不是间接相关也就是：<strong>非主键字段不能相互依赖，每列都与主键有直接关系，不存在传递依赖。</strong></p>
</li>
</ol>
<p>主键在一个表里只能存在一个！因为建立主键后，DBMS会默认把建立主键的列建立聚簇索引。但是一个表是允许把几个列一起设为主键的。</p>
<hr>
<h4><span id="索引是个什么样的数据结构呢">索引是个什么样的数据结构呢?</span></h4><p>索引是帮助 <code>MySQL</code> <strong>高效获取数据</strong>的<strong>排好序的数据结构</strong>。</p>
<p>索引主要有以下几种：</p>
<ol>
<li><strong>聚集索引（主键索引）</strong>：在数据库里面，所有行数都会按照主键索引进行排序。</li>
<li><strong>非聚集索引</strong>：就是给普通字段加上索引。</li>
<li><strong>联合索引</strong>：就是好几个字段组成的索引，称为联合索引。(<strong>遵从最左前缀原则</strong>)</li>
</ol>
<p>索引的数据结构和具体存储引擎的实现有关, 在 <code>MySQL</code> 中使用较多的索引有 <code>Hash索引</code> ，<code>B+</code> 树索引等,而我们经常使用的 <code>InnoDB</code> 存储引擎的默认索引实现为：<code>B+</code> 树索引。</p>
<ul>
<li><code>hash索引</code> 底层就是 <code>hash表</code> ，进行查找时，调用一次 <code>hash</code> 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。<code>B+</code> 树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
<li><code>hash索引</code> 进行等值查询更快(一般情况下)，但是却<strong>无法进行范围查询</strong>。因为在 <code>hash索引</code> 中经过 <code>hash函数</code> 建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询；而 <code>B+树</code> 的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</li>
<li><code>hash索引</code> 任何时候都避免不了<strong>回表查询数据</strong>，而 <code>B+树</code> 在符合某些条件(<strong>聚簇索引</strong>，<strong>覆盖索引</strong>等)的时候可以只通过索引完成查询。</li>
<li><code>B+</code> 树单个节点可以存储更多的数据，减少 <code>I/O</code> 的次数。</li>
<li>查找性能更稳定，因为都是要查找到叶子结点。</li>
<li>叶子结点形成了有序链表，便于查询。</li>
</ul>
<p><strong>MyISAM</strong>索引文件和数据文件是分离的(非聚集)</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png" alt="1608640486933"></p>
<p><strong>MyISAM</strong>先查找索引，找到的索引的<strong>value</strong>保存的是数据在磁盘中的地址，所以还要回表查询。</p>
<ul>
<li><strong>InnoDB</strong>索引实现的是聚集的<ul>
<li>表数据文件本身就是按照B+树组织的一个索引结构文件</li>
<li><strong>聚集索引</strong>：叶节点包含了完整的数据记录。(索引跟数据分开像<strong>MyISAM</strong>这样的交非聚集索引，要先查找索引，再回表查询；聚集索引是索引和数据在一起的索引，像<strong>InnoDB</strong>这样的)</li>
<li><strong>InnoDB</strong>必须有主键，并且推荐使用整形的自增主键。如果没有建主键会找一个唯一索引默认建主键；如果找不到的话会加一列隐形的列，来默认维护主键。整形更加方便比较、同时占用空间更小。<strong>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</strong></li>
</ul>
</li>
</ul>
<h5><span id="b树">B+树</span></h5><ul>
<li>非叶子节点不存储 <code>data</code> ，只存储索引(冗余)，可以放更多的索引</li>
<li>叶子节点包含所有的索引字段</li>
<li>叶子节点用指针链接，提高区间访问的性能。</li>
</ul>
<h5><span id="myisam与innodb-的区别">MyISAM与InnoDB 的区别</span></h5><ol>
<li><strong>InnoDB支持事务，MyISAM不支持</strong>，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li><strong>InnoDB支持外键，而MyISAM不支持</strong>。对一个包含外键的InnoDB表转为MYISAM会失败； 外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</li>
<li><strong>InnoDB是聚集索引</strong>，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li>
<li><strong>InnoDB不保存表的具体行数</strong>，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</li>
<li><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></li>
<li>InnoDB表<strong>必须有唯一索引（如主键）</strong>（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</li>
</ol>
<hr>
<h4><span id="什么是聚簇索引">什么是聚簇索引?</span></h4><p>在 <code>B+树</code> 的索引中，叶子节点可能存储了当前的 <code>key</code> 值，也可能存储了当前的 <code>key</code> 值以及整行的数据，这就是<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。在 <code>InnoDB</code> 中，只有<strong>主键索引</strong>是<strong>聚簇索引</strong>，如果没有主键，则挑选一个唯一键建立聚簇索引.如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<hr>
<h3><span id="最左匹配">最左匹配</span></h3><p><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p>
<p><strong>最左匹配原则</strong>都是<strong>针对联合索引</strong>来说的，所以我们有必要了解一下<strong>联合索引</strong>的原理。了解了联合索引，那么为什么会有最左匹配原则这种说法也就理解了。</p>
<p>我们都知道索引的底层是一颗 <code>B+</code> 树，那么联合索引当然还是一颗 <code>B+</code> 树，只不过联合索引的健值数量不是一个，而是多个。构建一颗 <code>B+</code> 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p>
<p><img src="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png" alt="img"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以 <code>b = 2</code> 这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以<strong>最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引</strong>。例如 <code>a = 1</code>  and <code>b = 2</code> a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而 <code>a&gt;1</code> and <code>b=2</code> ，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<p>事务特性</p>
<ul>
<li>持久型数据库怎么实现的</li>
<li>数据库有哪几种日志</li>
<li>分布式下还能满足ACID吗</li>
<li>数据库有哪几种锁</li>
<li>联合索引知道吗</li>
</ul>
<h3><span id="redis">Redis</span></h3><p><strong>Redis(REmote DIctionary Server)是一个基于内存的高性能非关系型key-value数据库，它通常被称为数据结构服务器，因为值(value)可以是字符串(String), 哈希(Map), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。</strong></p>
<p>传统数据库遵循 <code>ACID</code> 规则。而 Nosql(Not Only SQL 的缩写)，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 <strong>CAP</strong> 定理。</p>
<p><strong>CAP定理</strong>(CAP theorem)，又被称作布鲁尔定理(Brewer’s theorem)，是分布式系统中的一个基本定理。<br>它指出任何分布式系统(Distributed System)中，最多具有一致性(Consistence)、可用性(Availability)、分区容错(Partition Tolerance)这三个特性中的两个。也就是说，三个特性无法兼顾，必须有所取舍。</p>
<ul>
<li>舍弃P(选择C/A)：单点的传统关系型数据库 DBMS(MySQL/Oracle)，但如果采用集群就必须考虑P了；</li>
<li>舍弃A(选择C/P)：是分布式系统要保证P，而且保证一致性，如 ZooKeeper / Redis / MongoDB / HBase；</li>
<li>舍弃C(选择A/P)：是分布式系统要保证P，而且保证可用性，如 CoachDB / Cassandra / DynamoDB。</li>
</ul>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于<strong>缓存</strong>，每秒可以处理超过 10 万次读写操作，是已知<strong>性能最快的 Key-Value 数据库</strong>。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p>
<p>同时 <code>Redis</code> 也支持事务，<code>Redis</code> 的所有操作都是原子性的，同时 <code>Redis</code> 还支持对几个操作合并后的原子性执行。</p>
<h4><span id="redis相比memcached有哪些优势">Redis相比memcached有哪些优势</span></h4><ul>
<li><code>memcached</code> 所有的值均是简单的字符串，<code>redis</code> 作为其替代者，支持更为丰富的数据类型</li>
<li><code>redis</code> 的速度比 <code>memcached</code> 快很多</li>
<li><code>redis</code> 可以持久化其数据</li>
</ul>
<h4><span id="redis常用的五种数据类型">Redis常用的五种数据类型</span></h4><p><code>Redis</code> 可以存储键和不同类型的值之间的映射。<strong>键的类型只能为字符串</strong>，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<h5><span id="string字符串">string字符串</span></h5><p><code>string</code> 类型是二进制安全的。意思是 <code>redis</code> 的 <code>string</code> 可以包含任何数据。比如 <code>jpg</code> 图片或者序列化对象 。</p>
<p><code>redis</code> 的 <code>string</code> 是动态数组，也就是说它字符串占的长度，要小于它底层数组的容量。<code>string</code> 扩容的时候会判断字符串的长度，当长度小于 <code>1m</code> 的时候每次扩容都是容量翻倍，当大于 <code>1m</code> 的时候，每次扩容增加一个 <code>1m</code> 的空间，但是有大小限制，<code>redis</code> 中的字符串最大值是 <code>512m</code> </p>
<p><code>redis</code> 中采用这种冗余的预处理机制来扩容主要是为了防止频繁的内存申请，内存的分配是很浪费时间的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个string // 可以同时两次set一个string，就是把它直接颠覆了，</span></span><br><span class="line"><span class="built_in">set</span> googege redis</span><br><span class="line"><span class="comment">// 得到一个string</span></span><br><span class="line">get googege</span><br><span class="line"><span class="comment">// 获取字符串的长度</span></span><br><span class="line"><span class="built_in">strlen</span> googege</span><br><span class="line"><span class="comment">// 对string做切片,getrange string fitst-index end-index</span></span><br><span class="line"><span class="comment">// 并且必须提供后面的两个起始和结束的index，否则报错。</span></span><br><span class="line">getrange googege <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="comment">// 覆盖字符串 setrange string first-index new string.</span></span><br><span class="line">setrange googege <span class="number">1</span> ddddddd</span><br><span class="line"><span class="comment">// 追加字符串 append string xxx</span></span><br><span class="line">append googege ttt</span><br></pre></td></tr></table></figure>
<p>当字符串是整数的时候，也可以将它当成计数器。</p>
<hr>
<h5><span id="list列表">list列表</span></h5><p>list的底层是一个双向链表，所以可以使用这个链表来实现队列或者stack的功能</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p><strong>在 key 对应 list 的头部添加字符串元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush name value</span><br></pre></td></tr></table></figure>
<p><strong>在 key 对应 list 的尾部添加字符串元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush name value</span><br></pre></td></tr></table></figure>
<p><strong>key 对应 list 中删除 count 个和 value 相同的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem name index</span><br></pre></td></tr></table></figure>
<p><strong>返回 key 对应 list 的长度</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen name</span><br></pre></td></tr></table></figure>
<p><strong>获取子链</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush aaa go rust dart2</span><br><span class="line">lindex aaa <span class="number">1</span> <span class="comment">// 获取aaa的第2个元素</span></span><br><span class="line">lrang aaa <span class="number">0</span> <span class="number">2</span> <span class="comment">// 获取子链</span></span><br><span class="line">lrang aaa <span class="number">0</span> <span class="number">-1</span> <span class="comment">// -的意思就是倒着数</span></span><br><span class="line"><span class="comment">// 遍历全部的数据</span></span><br><span class="line">lrang <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 这个时候使用-数不用使用llen了，也是极好的。</span></span><br></pre></td></tr></table></figure>
<p><strong>修改和插入元素</strong></p>
<p>插入数据不是根据的下标的顺序，因为 <code>redis</code> 经常用在分布式的环境中，那么分布式中的下标就没有意义了，所以特别的指定在某个元素后面或者前面插入xx元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush aa go java rust</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">lset aa <span class="number">1</span> t <span class="comment">// 变成了  go t rust</span></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">linsert aa before go tt<span class="comment">// tt go java rust</span></span><br><span class="line">linsert aa after go tt <span class="comment">// go tt java rust</span></span><br></pre></td></tr></table></figure>
<p> <strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpush aa go rust dd</span><br><span class="line">lrem aa <span class="number">1</span> go <span class="comment">// 删除的时候不仅仅要写出来个数还要写出来元素的值</span></span><br></pre></td></tr></table></figure>
<hr>
<h5><span id="set集合">set集合</span></h5><p><strong>增加元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加元素sadd setname value value value value</span></span><br><span class="line">sadd y <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 读取元素 smembers 读取全部元素。 scard 获取set的长度 srandmember获取随机个数的元素，默认是1</span></span><br><span class="line">smembers y</span><br><span class="line">scard y</span><br><span class="line">srandmember y <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素 srem setname 1 2 3 4 删除必须指出来删除谁</span></span><br><span class="line">srem q <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 随机删除一个元素 spop setname</span></span><br><span class="line">spop q</span><br></pre></td></tr></table></figure>
<p><strong>判断元素是否存在</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否存在 sismember setname value</span></span><br><span class="line">sismember q <span class="number">43</span></span><br></pre></td></tr></table></figure>
<hr>
<h5><span id="sorted-setzset有序集合">sorted set(zset)有序集合</span></h5><p><code>zset</code> 实现的是有序集合，内部数据结构是 <strong>map 跳表</strong></p>
<p> <code>hash</code> 是关联元素 <code>key</code> 和权重（key和权重一一对应，其实相当于权重就是它的 <code>value</code> 值），<strong>跳表在于排序value 根据score范围查找元素。</strong></p>
<p><strong>增加删除数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd zsetname 权重 value 权重 value</span></span><br><span class="line">zadd u <span class="number">4.0</span> go </span><br><span class="line"><span class="comment">// 后面跟着的是权重</span></span><br><span class="line">zadd u <span class="number">4.0</span> go <span class="number">1.0</span> java</span><br><span class="line"><span class="comment">// 获取元素个数</span></span><br><span class="line">zcard q</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">//zrem zsetname value</span></span><br><span class="line">zrem u Java</span><br></pre></td></tr></table></figure>
<p><strong>计数器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd zsetname 权重 value</span></span><br><span class="line">zadd q <span class="number">4.0</span> python</span><br><span class="line"><span class="comment">// 获取排名和分数</span></span><br><span class="line">zscore q python</span><br><span class="line"><span class="comment">// zrank获取指定元素的正向排名</span></span><br><span class="line">zrank q python</span><br><span class="line"><span class="comment">// zrerank 反向排名</span></span><br></pre></td></tr></table></figure>
<p><strong>根据排名范围获取元素</strong> </p>
<p>这个原理主要是因为跳表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zrange q <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 获取所有数据</span></span><br><span class="line">zrange q <span class="number">0</span> <span class="number">-1</span> withscores <span class="comment">// 获取数据和他们的权重</span></span><br><span class="line">zrevrange q <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 按照负的顺序去排名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据sore返回获取value</span></span><br><span class="line">zrangebysocre q <span class="number">0</span> <span class="number">5</span><span class="comment">// zrangebyscore zsetname 权重区间</span></span><br><span class="line">zrangebyscore q -inf + inf withscores <span class="comment">// -inf负无穷 +inf 正无穷</span></span><br></pre></td></tr></table></figure>
<p><strong>根据范围移除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangenyrank zsetname scorestart scoreend</span><br></pre></td></tr></table></figure>
<hr>
<h5><span id="hash哈希表">hash哈希表</span></h5><p>跟一般的 <code>hash table</code> 没有区别，使用 <code>哈希函数 + 数组 + 链表</code> 。</p>
<p>哈希函数算出值，然后加入到那个值对应的数组，然后数组中是一个链表，链表表示都是算出来的这个的值的kv结构（这个时候如果链表太长就意味着是hash碰撞了，这也是攻击手段的一种。）</p>
<p><strong>增加查询删除</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hset mapname key value 增加一个</span></span><br><span class="line">hset ui a b</span><br><span class="line"><span class="comment">// hmset mapnae key value key value 增加一堆</span></span><br><span class="line">hmset ui a b c d e f g h</span><br><span class="line"><span class="comment">// 获取一个key hget mapname key</span></span><br><span class="line">hget ui a</span><br><span class="line"><span class="comment">//获取一堆key value hmget mapname key key key</span></span><br><span class="line">hmget ui a c e h</span><br><span class="line"><span class="comment">// 获取全部k-v hgetall mapname</span></span><br><span class="line">hgetall ui</span><br><span class="line"><span class="comment">//获取全部key</span></span><br><span class="line">hkeys mapname</span><br><span class="line"><span class="comment">// 获取全部value</span></span><br><span class="line">hvals mapname</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">hdel mapname key key key</span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line"><span class="comment">// hexists mapname key</span></span><br><span class="line">hexists ui a <span class="comment">// 0表示不存在 1 表示存在</span></span><br></pre></td></tr></table></figure>
<p><strong>计数器hash</strong></p>
<p>每一个k-v都是一个独立的计数器</p>
<p><strong>map的扩容</strong></p>
<p>当<code>hash</code> 碰撞太多的时候（时间复杂度已经从o(1)变成了o(n)）这个时候就该扩容了， 扩容的原则就是直接将数组扩大一倍，并且将各种数据从老的数组中转移到新的数组中；同时为了避免数据迁移带来的巨大损耗，<strong>redis是新旧同时保留，然后在后台使用一个定时的任务，以及hash读写指令，将数据逐步转移到新的数据结构中</strong>，新旧同时保留如何查找数据呢，其实只要在两个数组中都查查就行了。</p>
<hr>
<h4><span id="redis持久化">Redis持久化</span></h4><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p><code>Redis</code> 提供了两种持久化方式：<code>RDB</code> (默认)和 <code>AOF</code></p>
<h5><span id="rdbredis-database-半持久化模式">RDB(Redis DataBase) 半持久化模式</span></h5><p><code>RDB</code> 持久化是指<strong>在指定的时间间隔内将内存中的数据集快照写入磁盘</strong>，实际操作过程是 <code>fork</code> 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。(<strong>半持久化模式</strong>)</p>
<p><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png" alt="img"></p>
<p>功能核心函数<strong>rdbSave</strong>(生成RDB文件)和<strong>rdbLoad</strong>（从文件加载内存）两个函数</p>
<p><img src="https://www.redis.com.cn/images/riq1.png" alt="img"></p>
<hr>
<h5><span id="aofappend-only-file-全持久化模式">AOF(Append-only file) 全持久化模式</span></h5><p>每当执行服务器(定时)任务或者函数时<strong>flushAppendOnlyFile</strong> 函数都会被调用，把每一次数据变化都写入到一个<strong>append only file(aof)</strong>里面。  由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。这个函数执行以下两个工作</p>
<p><strong>aof写入保存：</strong></p>
<ol>
<li><strong>WRITE</strong>：根据条件，将 <code>aof_buf</code> 中的缓存写入到 <code>AOF</code> 文件</li>
<li><strong>SAVE</strong>：根据条件，调用 <code>fsync</code> 或 <code>fdatasync</code> 函数，将 <code>AOF</code> 文件保存到磁盘中。</li>
</ol>
<p>在Redis的配置文件中存在三种<strong>同步方式</strong>，它们分别是：</p>
<ol>
<li>appendfsync always     #每次有数据修改发生时都会写入AOF文件。</li>
<li>appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。</li>
<li>appendfsync no          #从不同步。高效但是数据不会被持久化。</li>
</ol>
<h5><span id="存储结构">存储结构</span></h5><p>持久化存储的内容是 <code>redis</code> 通讯协议( <code>RESP(Redis Serialization Protocol)</code>  )格式的命令文本存储。<code>RESP</code> 是 <code>redis</code> 客户端和服务端之前使用的一种通讯协议；RESP 的特点：<strong>实现简单、快速解析、可读性好</strong></p>
<p>协议如下：</p>
<ul>
<li>客户端以规定格式的形式发送命令给服务器；</li>
<li>服务器在执行最后一条命令后，返回结果。</li>
</ul>
<ol>
<li>简单字符串 <strong>Simple Strings</strong>, 以 “+”加号 开头</li>
</ol>
<p>​      格式：<strong>+</strong> 字符串 \r\n  。字符串不能包含 CR或者 LF(不允许换行)</p>
<p>​      eg: <strong>“+OK\r\n”</strong></p>
<p>​      注意：为了发送二进制安全的字符串，一般推荐使用后面的 <strong>Bulk Strings</strong> 类型</p>
<ol>
<li>错误 <strong>Errors</strong>, 以”<strong>-</strong>“减号 开头</li>
</ol>
<p>　　格式：- 错误前缀 错误信息 \r\n 。错误信息不能包含 CR或者 LF(不允许换行)，Errors与Simple Strings很相似，不同的是Erros会被当作异常来看待</p>
<p>​      eg: <strong>“-Error unknow command ‘foobar’\r\n”</strong></p>
<ol>
<li>整数型 <strong>Integer</strong>， 以 “:” 冒号开头。格式 : 数字 \r\n</li>
</ol>
<p>​      eg: <strong>“:1000\r\n”</strong></p>
<ol>
<li>大字符串类型 <strong>Bulk Strings</strong>, 以 “$”美元符号开头，长度限制512M</li>
</ol>
<p>　　格式：$ 字符串的长度 \r\n 字符串 \r\n  字符串不能包含 CR或者 LF(不允许换行);</p>
<p>​      eg: <strong>“$6\r\nfoobar\r\n”</strong>    其中字符串为 foobar，而6就是foobar的字符长度</p>
<p>​            “$0\r\n\r\n”       空字符串</p>
<p>​            “$-1\r\n”           null</p>
<ol>
<li>数组类型 <strong>Arrays</strong>，以 “*“星号开头。格式：* 数组元素个数 \r\n 其他所有类型 (结尾不需要\r\n)</li>
</ol>
<p>​             注意：只有元素个数后面的\r\n是属于该数组的，结尾的\r\n一般是元素的</p>
<p>​      eg: “*0\r\n”      空数组</p>
<p>​           “*2\r\n2\r\nfoo\r\n2\r\nfoo\r\n3\r\nbar\r\n”      数组包含2个元素，分别是字符串foo和bar</p>
<p>　　　　“*3\r\n:1\r\n:2\r\n:3\r\n”       数组包含3个整数：1、2、3</p>
<p>​           “*5\r\n:1\r\n:2\r\n:3\r\n:4\r\n$6\r\nfoobar\r\n”  包含混合类型的数组</p>
<p>​           “*-1\r\n”         Null数组</p>
<hr>
<h4><span id="redis架构模式">Redis架构模式</span></h4><h5><span id="1-单机版">1. 单机版</span></h5><p><strong>内存容量有限/处理能力有限/无法高可用。</strong></p>
<p><img src="https://www.redis.com.cn/images/riq3.png" alt="img"></p>
<h5><span id="2-主从复制">2. 主从复制</span></h5><p><img src="https://www.redis.com.cn/images/riq4.png" alt="img"></p>
<p><code>Redis</code> 的复制(replication)功能允许用户根据一个 <code>Redis</code> 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而<strong>一直保证主从服务器的数据相同</strong>。</p>
<p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以<strong>避免这种单点故障</strong></p>
<p><strong>复制是高可用Redis的基础</strong>，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及<strong>对于读操作的负载均衡和简单的故障恢复</strong>。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</p>
<p><strong>特点：</strong></p>
<ol>
<li>master/slave 角色</li>
<li>master/slave 数据相同</li>
<li>降低 master <strong>读</strong>压力在转交从库</li>
</ol>
<p><strong>问题：</strong></p>
<ol>
<li>无法保证<strong>高可用</strong></li>
<li>没有解决 <code>master</code> <strong>写的压力</strong></li>
</ol>
<h5><span id="3-哨兵">3. 哨兵</span></h5><p><img src="https://www.redis.com.cn/images/riq5.png" alt="img"></p>
<p><strong>Redis sentinel</strong> 是一个分布式系统中监控 <code>redis</code> 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<ol>
<li><strong>监控(Monitoring)</strong>：<strong>Sentinel</strong> 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒(Notification)</strong>：当被监控的某个 <strong>Redis</strong> 服务器出现问题时， <strong>Sentinel</strong> 可以通过 <strong>API</strong> 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移(Automatic failover)</strong>：当一个主服务器不能正常工作时， <strong>Sentinel</strong> 会开始一次自动故障迁移操作。</li>
</ol>
<p><strong>特点：</strong></p>
<ol>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>主从模式，切换需要时间丢数据</li>
<li>没有解决 <code>master</code> <strong>写的压力</strong></li>
</ol>
<h5><span id="4-集群proxy型">4. 集群(proxy型)</span></h5><p><img src="https://www.redis.com.cn/images/riq6.png" alt="img"></p>
<h5><span id="5-集群直连型">5. 集群(直连型)</span></h5><p><img src="https://www.redis.com.cn/images/riq7.png" alt="img"></p>
<p>从redis 3.0之后版本支持<strong>redis-cluster</strong>集群，<strong>Redis-Cluster</strong>采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>无中心架构</strong>（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li><strong>可扩展性</strong>，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li><strong>高可用性</strong>，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</li>
<li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，<strong>用投票机制完成 Slave到 Master 的角色提升。</strong></li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>资源<strong>隔离性较差</strong>，容易出现相互影响的情况。</li>
<li>数据通过<strong>异步复制，不保证数据的强一致性</strong></li>
</ol>
<hr>
<h4><span id="redis是单线程的但redis为什么这么快">Redis是单线程的，但Redis为什么这么快？</span></h4><p>Redis是基于内存的操作，<code>CPU</code> 不是Redis的瓶颈，Redis的瓶颈最有可能是<strong>机器内存的大小或者网络带宽</strong>。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了，毕竟采用多线程会有很多麻烦。Redis采用单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。</p>
<p>Redis单线程但是很快的原因主要如下：</p>
<ol>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li>
<li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li>
<li>采用单线程，<strong>避免了不必要的上下文切换和竞争条件</strong>，也<strong>不存在多进程或者多线程导致的切换而消耗 CPU</strong>，<strong>不用去考虑各种锁的问题</strong>，<strong>不存在加锁释放锁操作</strong>，<strong>没有因为可能出现死锁而导致的性能消耗</strong>；</li>
<li>使用多路I/O复用模型，非阻塞IO；<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</strong>非阻塞IO 内部实现采用 <code>epoll</code> ，采用了 <code>epoll</code> +自己实现的简单的事件框架。<code>epoll</code> 中的读、写、关闭、连接都转化成了事件，然后利用 <code>epoll</code> 的多路复用特性，绝不在io上浪费一点时间。</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ol>
<hr>
<h4><span id="为什么redis用跳表不用红黑树">为什么redis用跳表不用红黑树</span></h4><ul>
<li>跳表范围查找比红黑树好</li>
<li>更好实现</li>
<li>并发状态下锁住的数据比红黑树少</li>
<li>动态更改的时候跳表要更改的数据少，红黑树则需要树化。更改更大</li>
</ul>
<p>跳表如果消耗内存过大，其实可以调节索引的稠密程度，稍微稀疏一点占用的内存就少了。</p>
<hr>
<h4><span id="为什么redis不用b树">为什么redis不用b+树</span></h4><ul>
<li>主要是reids经常在并发高的条件下使用，b+树的化每次数据更改都需要树化，但是跳表锁定的数据很少，很适合并发分布式状态下使用</li>
<li>B树，B+树：它们特点是一样的，是多路查找树，一般用于数据库系统中，为什么，因为它们分支多层数少呗， 都知道磁盘IO是非常耗时的，而像大量数据存储在磁盘中所以我们要有效的减少磁盘IO次数避免磁盘频繁的查找。 这是多路树的作用在磁盘中减少io但是它不适合在并发分布式下，尤其是动态更改数据强烈的状态下使用</li>
</ul>
<hr>
<h4><span id="redis的用途是什么">Redis的用途是什么？</span></h4><ul>
<li><strong>计数器</strong>： 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</li>
<li><strong>缓存</strong>：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</li>
<li><strong>会话缓存</strong>： 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</li>
<li><strong>全页缓存（FPC）</strong>：除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
<li><strong>查找表</strong>：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</li>
<li><strong>消息队列(发布/订阅功能)</strong>：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</li>
<li><strong>分布式锁实现</strong>：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</li>
<li><strong>其它</strong>：Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet可以实现有序性操作，从而实现排行榜等功能。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/26/计算机网络总结/" rel="next" title="计算机网络总结">
                <i class="fa fa-chevron-left"></i> 计算机网络总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">340</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">Mysql相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.</span> <span class="nav-text">事务的特性(ACID)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.</span> <span class="nav-text">如果不考虑隔离性，会发生什么事呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.</span> <span class="nav-text">四种隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">什么是快照读、当前读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">MySql如何解决幻读问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.</span> <span class="nav-text">数据库三范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.</span> <span class="nav-text">索引是个什么样的数据结构呢?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">MyISAM与InnoDB 的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.</span> <span class="nav-text">什么是聚簇索引?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">最左匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">Redis相比memcached有哪些优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.</span> <span class="nav-text">Redis常用的五种数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">string字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">list列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">set集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">sorted set(zset)有序集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">hash哈希表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">RDB(Redis DataBase) 半持久化模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">AOF(Append-only file) 全持久化模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">存储结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.</span> <span class="nav-text">Redis架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1. 单机版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2. 主从复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3. 哨兵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">4. 集群(proxy型)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">5. 集群(直连型)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.5.</span> <span class="nav-text">Redis是单线程的，但Redis为什么这么快？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.6.</span> <span class="nav-text">为什么redis用跳表不用红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.7.</span> <span class="nav-text">为什么redis不用b+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.3.8.</span> <span class="nav-text">Redis的用途是什么？</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
