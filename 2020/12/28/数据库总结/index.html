<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,数据库,">










<meta name="description" content="数据库 Mysql相关 事务的特性(ACID) 如果不考虑隔离性，会发生什么事呢？ 四种隔离级别 什么是快照读、当前读 MySql如何解决幻读问题   数据库三范式 索引是个什么样的数据结构呢? B+树 MyISAM与InnoDB 的区别   什么是聚簇索引? 最左匹配 Mysql的几种log       [TOC] 数据库Mysql相关事务的特性(ACID) 原子性（Atomicity）：原">
<meta name="keywords" content="基础知识,数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库总结">
<meta property="og:url" content="http://chenqi1997.github.io/2020/12/28/数据库总结/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="数据库 Mysql相关 事务的特性(ACID) 如果不考虑隔离性，会发生什么事呢？ 四种隔离级别 什么是快照读、当前读 MySql如何解决幻读问题   数据库三范式 索引是个什么样的数据结构呢? B+树 MyISAM与InnoDB 的区别   什么是聚簇索引? 最左匹配 Mysql的几种log       [TOC] 数据库Mysql相关事务的特性(ACID) 原子性（Atomicity）：原">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png">
<meta property="og:updated_time" content="2021-01-05T13:44:35.191Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据库总结">
<meta name="twitter:description" content="数据库 Mysql相关 事务的特性(ACID) 如果不考虑隔离性，会发生什么事呢？ 四种隔离级别 什么是快照读、当前读 MySql如何解决幻读问题   数据库三范式 索引是个什么样的数据结构呢? B+树 MyISAM与InnoDB 的区别   什么是聚簇索引? 最左匹配 Mysql的几种log       [TOC] 数据库Mysql相关事务的特性(ACID) 原子性（Atomicity）：原">
<meta name="twitter:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/12/28/数据库总结/">





  <title>数据库总结 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/12/28/数据库总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据库总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-28T17:46:00+08:00">
                2020-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#mysql相关">Mysql相关</a><ul>
<li><a href="#事务的特性acid">事务的特性(ACID)</a></li>
<li><a href="#如果不考虑隔离性会发生什么事呢">如果不考虑隔离性，会发生什么事呢？</a></li>
<li><a href="#四种隔离级别">四种隔离级别</a><ul>
<li><a href="#什么是快照读-当前读">什么是快照读、当前读</a></li>
<li><a href="#mysql如何解决幻读问题">MySql如何解决幻读问题</a></li>
</ul>
</li>
<li><a href="#数据库三范式">数据库三范式</a></li>
<li><a href="#索引是个什么样的数据结构呢">索引是个什么样的数据结构呢?</a><ul>
<li><a href="#b树">B+树</a></li>
<li><a href="#myisam与innodb-的区别">MyISAM与InnoDB 的区别</a></li>
</ul>
</li>
<li><a href="#什么是聚簇索引">什么是聚簇索引?</a></li>
<li><a href="#最左匹配">最左匹配</a></li>
<li><a href="#mysql的几种log">Mysql的几种log</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h2><span id="数据库">数据库</span></h2><h3><span id="mysql相关">Mysql相关</span></h3><h4><span id="事务的特性acid">事务的特性(ACID)</span></h4><ol>
<li><strong>原子性（Atomicity）</strong>：原子性是指一个事务中的操作，<strong>要么全部成功，要么全部失败</strong>，如果失败，就回滚到事务开始前的状态。</li>
<li><strong>一致性（Consistency）</strong>：一致性是指<strong>事务必须使数据库从一个一致性状态变换到另一个一致性状态</strong>，也就是说一个事务执行之前和执行之后都必须处于一致性状态。那转账举栗子，A账户和B账户之间相互转账，无论如何操作，A、B账户的总金额都必须是不变的。</li>
<li><strong>隔离性（Isolation）</strong>：<strong>隔离性是当多个用户并发的访问数据库时，如果操作同一张表，数据库则为每一个用户都开启一个事务，且事务之间互不干扰，也就是说事务之间的并发是隔离的</strong>。再举个栗子，现有两个并发的事务T1和T2，T1要么在T2开始前执行，要么在T2结束后执行，如果T1先执行，那T2就在T1结束后在执行。关于数据的隔离性级别，将在后文讲到。</li>
<li><strong>持久性（Durability）</strong>：持久性就是指如果<strong>事务一旦被提交，数据库中数据的改变就是永久性的，即使断电或者宕机的情况下，也不会丢失提交的事务操作。</strong></li>
</ol>
<hr>
<h4><span id="如果不考虑隔离性会发生什么事呢">如果不考虑隔离性，会发生什么事呢？</span></h4><ol>
<li><p><strong>脏读</strong>(select问题)</p>
<p>脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>；</span><br><span class="line">updata t_table <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'wangwu'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">--此时事务2查询id = 1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>；<span class="comment">--未提交</span></span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;        <span class="comment">--查询到 id = 1， name = 'wangwu'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可重复读</strong>(update问题)</p>
<p>不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。</p>
<p>不可重复读和脏读的区别是，<strong>脏读读取到的是一个未提交的数据</strong>，而<strong>不可重复读读取到的是前一个事务提交的数据</strong>。而不可重复读在一些情况也并不影响数据的正确性，比如需要多次查询的数据也是要以最后一次查询到的数据为主。</p>
<p><strong>解决不可重复读的方法是 锁行</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = list, 事务2在此时提交</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = wangwu</span></span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> t_table <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'wangwu'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>幻读</strong>(insert/delete问题)</p>
<p>幻读是<strong>事务非独立执行</strong>时发生的一种现象。例如事务 <code>T1</code> 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 <code>T2</code> 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 <code>T1</code> 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是<strong>不可重复读查询的都是同一个数据项</strong>，而<strong>幻读针对的是一批数据整体</strong>（比如数据的个数）。</p>
<p><strong>解决幻读的方式是 锁表。</strong></p>
</li>
</ol>
<hr>
<h4><span id="四种隔离级别">四种隔离级别</span></h4><p>四种隔离级别主要解决的是脏读、幻读和不可重复读的问题。</p>
<ol>
<li><p><strong>读未提交(Read uncommitted)</strong></p>
<p>这种事务隔离级别下，<code>select</code> 语句不加锁。此时，可能读取到不一致的数据，即<strong>脏读</strong>。这是并发最高，一致性最差的隔离级别。</p>
</li>
<li><p><strong>读已提交(Read committed)</strong></p>
<p>可避免<strong>脏读</strong>的发生，但是会有<strong>幻读</strong>和<strong>不可重复读</strong>的问题。在互联网大数据量，高并发量的场景下，几乎 <strong>不会使用</strong> 上述两种隔离级别。</p>
<p>这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>不然，普通的查询是不会加锁的，若有事务对数据进行更新 <code>UPDATE</code> 操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p>
<blockquote>
<p>那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
</blockquote>
<p>这就要说到另一个机制<strong>快照(snapshot)</strong>，而这种既能保证一致性又不加锁的读也被称为快照读    （<strong>Snapshot Read</strong>）。假设没有“快照读”，那么<strong>当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞</strong>（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而“快照读”就可以完成高并发的查询，不过，读提交只能避免脏读，并不能避免不可重复读和幻读。</p>
</li>
</ol>
<p>​    <strong>快照读</strong>的意思是，数据有多个版本， 当事务并发执行时， 某一事务读取的数据来自其中一个版本（快照）。</p>
<ol>
<li><p><strong>可重复读(Repeatable read)</strong></p>
<p><code>MySql</code> 默认隔离级别。可避免 <strong>脏读</strong> 、<strong>不可重复读</strong> 的发生。不可重复读对应的是修改，即 <code>UPDATE</code> 操作。但是可能还会有幻读问题。因为幻读问题对应的是插入 <code>INSERT</code> 操作，而不是 <code>UPDATE</code> 操作。</p>
<p>在这个级别下，普通的查询同样是使用的<strong>快照读</strong>，但是，和读提交不同的是，当事务启动时，就不允许进行修改操作(<code>Update</code>) 了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。</p>
</li>
<li><p><strong>串行化(Serializable)</strong></p>
<p>可避免 <strong>脏读、不可重复读、幻读</strong> 的发生。 <code>Serializable</code> 是一致性最好的，性能最差的。这种级别下，事务串行化顺序执行，也就是一个一个排队执行。这种级别下，<code>脏读</code> 、<code>不可重复读</code> 、<code>幻读</code> 都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
</li>
</ol>
<p>上面四种隔离级别最高的是 <strong>Serializable</strong> 级别，最低的是 <strong>Read uncommitted</strong> 级别，当然级别越高，执行效率就越低。像 <strong>Serializable</strong> 这样的级别，就是以 <strong>锁表</strong> 的方式(类似于多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。</p>
<h5><span id="什么是快照读-当前读">什么是快照读、当前读</span></h5><ul>
<li><strong>快照读</strong>, 读取专门的快照 (对于 <code>RC</code> ，快照( <code>ReadView</code> )会在每个语句中创建。对于 <code>RR</code> ，快照是在事务启动时创建的)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的select操作即可(不需要加锁,如: select ... lock in share mode, select ... for update)</span><br></pre></td></tr></table></figure>
<p>针对的也是 <code>select</code> 操作</p>
<ul>
<li><strong>当前读</strong>, 读取最新版本的记录, 没有快照。 在 <code>InnoDB</code> 中，当前读取根本不会创建任何快照。当前读会在搜索的时候加锁</li>
</ul>
<h5><span id="mysql如何解决幻读问题">MySql如何解决幻读问题</span></h5><p>两点需要说明：</p>
<ol>
<li>在可重复读隔离级别下，普通查询是<strong>快照读</strong>，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。</li>
<li>幻读专指新插入的行，读到原本存在行的更新结果不算。因为<strong>当前读的作用就是能读到所有已经提交记录的最新值</strong>。如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。</li>
</ol>
<p><strong>幻读产生的原因</strong></p>
<p>　　行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。 </p>
<p><strong>如何解决幻读？</strong></p>
<ol>
<li><p>在<strong>快照读</strong>读情况下，<code>mysql</code> 通过<strong>mvcc</strong>来避免幻读。</p>
<p><code>SESSION_A</code> 执行一个查询，这个查询可以访问任何表，这个查询的目的是创建一个当前时间点的快照， <code>SESSION_B</code> 再插入一条记录并提交。由于 <code>SESSION_A</code> 第一次的查询开始于 <code>SESSION_B</code> 插入数据前，所以创建了一个以 <code>SELECT</code> 操作的时间为基准点的 <code>read view</code> ，避免了幻读的产生。所以在 <code>SESSION_A</code> 的事务结束前,无法看到 <code>SESSION_B</code> 对表 <code>read_view</code> 做出的任何更改 <code>(insert,delete,update)</code>。</p>
<p>简单的select操作(不包括 select … lock in share mode, select … for update)。</p>
<ul>
<li>Read Committed隔离级别：每次select都生成一个快照读。</li>
<li>Read Repeatable隔离级别：<strong>开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。</strong></li>
</ul>
<p>在RR级别下，<strong>快照读是通过MVVC(多版本控制)和undo log</strong>来实现的，<strong>当前读是通过加record lock(记录锁)和gap lock(间隙锁)</strong>来实现的。</p>
</li>
<li><p>在<strong>当前读</strong>读情况下，<code>mysql</code> 通过<strong>next-key</strong>来避免幻读</p>
<p><strong>Innodb</strong>行锁分为:</p>
<p>| 类型           | 说明                                                         |<br>| ————– | ———————————————————— |<br>| Record Lock:   | 在索引上对单行记录加锁.                                      |<br>| Gap Lock:      | 锁定一个范围的记录,但不包括记录本身.锁加在未使用的空闲空间上,可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间. |<br>| Next-Key Lock: | 行锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。 |</p>
<p>当前读读取的是最新版本, 并且<strong>对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</strong></p>
<p>例如，假设要 <code>update</code> 一条记录，但是另一个事务已经 <code>delete</code> 这条数据并且 <code>commit</code> 了，如果不加锁就会产生冲突。所以 <code>update</code> 的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。</p>
<p>当以当前读模式<code>select * from t5 where id=7 for update;</code>获取 <code>id=7</code> 的数据时,产生了 <code>Next-Key Lock</code> ，锁住了 <code>4-10</code> 范围和 <code>id=7</code> 单个 <code>record</code> ，从而阻塞了 <code>SESSION_B</code> 在这个范围内插入数据，而在除此之外的范围内是可以插入数据的。</p>
<p><strong>尽量使用唯一索引,因为唯一索引会把Next-Key Lock降级为Record Lock</strong></p>
</li>
</ol>
<hr>
<h4><span id="数据库三范式">数据库三范式</span></h4><ol>
<li><p>第一范式(确保每列保持<strong>原子性</strong>)</p>
<p>第一范式是最基本的范式。如果<strong>数据库表中的所有字段值都是不可分解的原子值</strong>，就说明该数据库表满足了第一范式。</p>
</li>
<li><p>第二范式(<strong>确保表中的每列都和主键相关</strong>)</p>
<p>第二范式在第一范式的基础之上更进一层。<strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）</strong>。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。(唯一性 一个表只说明一个事物)</p>
<p>主要是针对<strong>联合主键</strong>而言，比如有两个列都是主键，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式。这种情况需要进行表的拆分。</p>
</li>
<li><p>第三范式(<strong>确保每列都和主键列直接相关,而不是间接相关</strong>)</p>
<p>确保每列都和主键列直接相关,而不是间接相关也就是：<strong>非主键字段不能相互依赖，每列都与主键有直接关系，不存在传递依赖。</strong></p>
</li>
</ol>
<p>主键在一个表里只能存在一个！因为建立主键后，DBMS会默认把建立主键的列建立聚簇索引。但是一个表是允许把几个列一起设为主键的。</p>
<hr>
<h4><span id="索引是个什么样的数据结构呢">索引是个什么样的数据结构呢?</span></h4><p>索引是帮助 <code>MySQL</code> <strong>高效获取数据</strong>的<strong>排好序的数据结构</strong>。</p>
<p>索引主要有以下几种：</p>
<ol>
<li><strong>聚集索引（主键索引）</strong>：在数据库里面，所有行数都会按照主键索引进行排序。</li>
<li><strong>非聚集索引</strong>：就是给普通字段加上索引。</li>
<li><strong>联合索引</strong>：就是好几个字段组成的索引，称为联合索引。(<strong>遵从最左前缀原则</strong>)</li>
</ol>
<p>索引的数据结构和具体存储引擎的实现有关, 在 <code>MySQL</code> 中使用较多的索引有 <code>Hash索引</code> ，<code>B+</code> 树索引等,而我们经常使用的 <code>InnoDB</code> 存储引擎的默认索引实现为：<code>B+</code> 树索引。</p>
<ul>
<li><code>hash索引</code> 底层就是 <code>hash表</code> ，进行查找时，调用一次 <code>hash</code> 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。<code>B+</code> 树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
<li><code>hash索引</code> 进行等值查询更快(一般情况下)，但是却<strong>无法进行范围查询</strong>。因为在 <code>hash索引</code> 中经过 <code>hash函数</code> 建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询；而 <code>B+树</code> 的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</li>
<li><code>hash索引</code> 任何时候都避免不了<strong>回表查询数据</strong>，而 <code>B+树</code> 在符合某些条件(<strong>聚簇索引</strong>，<strong>覆盖索引</strong>等)的时候可以只通过索引完成查询。</li>
<li><code>B+</code> 树单个节点可以存储更多的数据，减少 <code>I/O</code> 的次数。</li>
<li>查找性能更稳定，因为都是要查找到叶子结点。</li>
<li>叶子结点形成了有序链表，便于查询。</li>
</ul>
<p><strong>MyISAM</strong>索引文件和数据文件是分离的(非聚集)</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1608640486933.png" alt="1608640486933"></p>
<p><strong>MyISAM</strong>先查找索引，找到的索引的<strong>value</strong>保存的是数据在磁盘中的地址，所以还要回表查询。</p>
<ul>
<li><strong>InnoDB</strong>索引实现的是聚集的<ul>
<li>表数据文件本身就是按照B+树组织的一个索引结构文件</li>
<li><strong>聚集索引</strong>：叶节点包含了完整的数据记录。(索引跟数据分开像<strong>MyISAM</strong>这样的交非聚集索引，要先查找索引，再回表查询；聚集索引是索引和数据在一起的索引，像<strong>InnoDB</strong>这样的)</li>
<li><strong>InnoDB</strong>必须有主键，并且推荐使用整形的自增主键。如果没有建主键会找一个唯一索引默认建主键；如果找不到的话会加一列隐形的列，来默认维护主键。整形更加方便比较、同时占用空间更小。<strong>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</strong></li>
</ul>
</li>
</ul>
<h5><span id="b树">B+树</span></h5><ul>
<li>非叶子节点不存储 <code>data</code> ，只存储索引(冗余)，可以放更多的索引</li>
<li>叶子节点包含所有的索引字段</li>
<li>叶子节点用指针链接，提高区间访问的性能。</li>
</ul>
<h5><span id="myisam与innodb-的区别">MyISAM与InnoDB 的区别</span></h5><ol>
<li><strong>InnoDB支持事务，MyISAM不支持</strong>，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li><strong>InnoDB支持外键，而MyISAM不支持</strong>。对一个包含外键的InnoDB表转为MYISAM会失败； 外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</li>
<li><strong>InnoDB是聚集索引</strong>，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li>
<li><strong>InnoDB不保存表的具体行数</strong>，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</li>
<li><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></li>
<li>InnoDB表<strong>必须有唯一索引（如主键）</strong>（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</li>
</ol>
<hr>
<h4><span id="什么是聚簇索引">什么是聚簇索引?</span></h4><p>在 <code>B+树</code> 的索引中，叶子节点可能存储了当前的 <code>key</code> 值，也可能存储了当前的 <code>key</code> 值以及整行的数据，这就是<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。在 <code>InnoDB</code> 中，只有<strong>主键索引</strong>是<strong>聚簇索引</strong>，如果没有主键，则挑选一个唯一键建立聚簇索引.如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<hr>
<h4><span id="最左匹配">最左匹配</span></h4><p><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p>
<p><strong>最左匹配原则</strong>都是<strong>针对联合索引</strong>来说的，所以我们有必要了解一下<strong>联合索引</strong>的原理。了解了联合索引，那么为什么会有最左匹配原则这种说法也就理解了。</p>
<p>我们都知道索引的底层是一颗 <code>B+</code> 树，那么联合索引当然还是一颗 <code>B+</code> 树，只不过联合索引的健值数量不是一个，而是多个。构建一颗 <code>B+</code> 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p>
<p><img src="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png" alt="img"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以 <code>b = 2</code> 这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以<strong>最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引</strong>。例如 <code>a = 1</code>  and <code>b = 2</code> a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而 <code>a&gt;1</code> and <code>b=2</code> ，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<h4><span id="mysql的几种log">Mysql的几种log</span></h4><p>事务特性</p>
<ul>
<li>持久型数据库怎么实现的</li>
<li>数据库有哪几种日志</li>
<li>分布式下还能满足ACID吗</li>
<li>数据库有哪几种锁</li>
<li>联合索引知道吗</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/26/计算机网络总结/" rel="next" title="计算机网络总结">
                <i class="fa fa-chevron-left"></i> 计算机网络总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/01/Redis总结/" rel="prev" title="Redis总结">
                Redis总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">342</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">90</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">Mysql相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.1.</span> <span class="nav-text">事务的特性(ACID)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.</span> <span class="nav-text">如果不考虑隔离性，会发生什么事呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.</span> <span class="nav-text">四种隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">什么是快照读、当前读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">MySql如何解决幻读问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.4.</span> <span class="nav-text">数据库三范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.</span> <span class="nav-text">索引是个什么样的数据结构呢?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">MyISAM与InnoDB 的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.6.</span> <span class="nav-text">什么是聚簇索引?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.7.</span> <span class="nav-text">最左匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.8.</span> <span class="nav-text">Mysql的几种log</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
