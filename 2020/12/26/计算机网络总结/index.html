<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,计算机网络,">










<meta name="description" content="OSI七层模型，每一层的协议 协议分别有：   TCP/UDP/运输层 ⭐UDP和TCP的差别 TCP/UDP数据发送和接收过程 发送端 接收端 复用与分用   TCP协议的可靠性 TCP协议保证数据传输可靠性的方式 首部校验和 序列号和确认应答(ACK) 序列号 确认应答 选择确认 SACK   超时重传 流量控制 滑动窗口(以字节为单位) 拥塞控制 慢开始 拥塞避免 快重传 快恢复">
<meta name="keywords" content="基础知识,计算机网络">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络总结">
<meta property="og:url" content="http://chenqi1997.github.io/2020/12/26/计算机网络总结/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="OSI七层模型，每一层的协议 协议分别有：   TCP/UDP/运输层 ⭐UDP和TCP的差别 TCP/UDP数据发送和接收过程 发送端 接收端 复用与分用   TCP协议的可靠性 TCP协议保证数据传输可靠性的方式 首部校验和 序列号和确认应答(ACK) 序列号 确认应答 选择确认 SACK   超时重传 流量控制 滑动窗口(以字节为单位) 拥塞控制 慢开始 拥塞避免 快重传 快恢复">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcjvgSoF3zeGINoyibX5tpfgfQwBABm2KMEnohSmkRXjzicCuQtt4IWsc9fniahl1mW39gS674icZibqibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img-blog.csdn.net/20180316155619885?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzE2MDkzMzIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1739381/201907/1739381-20190718231440734-1731506013.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568283339430.91a72ae3.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180524102010286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568793245619.0ba706e9.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180524111634561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568790013316.97bfddcb.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568790430010.9e25f59d.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568796886603.87101025.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568796161225.0a85de7d.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568796172902.50a3f779.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181130165347546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzA4MDI3,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568704529477.08a8d8a2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201213000709282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODI0MTQ4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568797056445.aa1412a3.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568797480363.f8ec5647.png">
<meta property="og:image" content="https://img-blog.csdn.net/20160911000133291">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1233668/201806/1233668-20180613233505890-1600510236.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613471822566.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568288257688.197541c0.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613473588045.png">
<meta property="og:image" content="https://krahets.gitee.io/assets/img/1568635687315.e67e9b59.png">
<meta property="og:image" content="https://img-blog.csdn.net/20150730120353079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1627759/201906/1627759-20190615112708629-638195014.jpg">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613463990017.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613464426114.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5YING7tophKDYrYreRzSvGN0BlJ6LibtW2mK4QTTckvpm3408gax7XUg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5hTnk3S5XJBVElZdWeB6U8lrMlyY9iaPZFj7WKE1OeSw3E3TNUj9Nz3A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/885859/201907/885859-20190724173147088-630413355.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/885859/201907/885859-20190724173242717-440362909.png">
<meta property="og:image" content="c:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613472309683.png">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140849">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200138896">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200139219">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200139703">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140021">
<meta property="og:image" content="https://img-blog.csdn.net/20161028200140375">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190915131156673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190915142010343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190903153708344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXNoZW5neGlfcm9vdA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMj1rxibhibqZx2wKJiaFvWic5iaqcOzoicHQVQ07GHIveN1Sb0ZV2tEQLic5nw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMSj8caicicn1aLlm47p4w3OKgk7dHGXUjRkGibPMfF4VAcdptA5wibPpg1w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:updated_time" content="2021-02-24T10:00:21.470Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机网络总结">
<meta name="twitter:description" content="OSI七层模型，每一层的协议 协议分别有：   TCP/UDP/运输层 ⭐UDP和TCP的差别 TCP/UDP数据发送和接收过程 发送端 接收端 复用与分用   TCP协议的可靠性 TCP协议保证数据传输可靠性的方式 首部校验和 序列号和确认应答(ACK) 序列号 确认应答 选择确认 SACK   超时重传 流量控制 滑动窗口(以字节为单位) 拥塞控制 慢开始 拥塞避免 快重传 快恢复">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcjvgSoF3zeGINoyibX5tpfgfQwBABm2KMEnohSmkRXjzicCuQtt4IWsc9fniahl1mW39gS674icZibqibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2020/12/26/计算机网络总结/">





  <title>计算机网络总结 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2020/12/26/计算机网络总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算机网络总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-26T17:46:00+08:00">
                2020-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#osi七层模型每一层的协议">OSI七层模型，每一层的协议</a><ul>
<li><a href="#协议分别有">协议分别有：</a></li>
</ul>
</li>
<li><a href="#tcpudp运输层">TCP/UDP/运输层</a><ul>
<li><a href="#udp和tcp的差别">⭐UDP和TCP的差别</a></li>
<li><a href="#tcpudp数据发送和接收过程">TCP/UDP数据发送和接收过程</a><ul>
<li><a href="#发送端"><strong>发送端</strong></a></li>
<li><a href="#接收端"><strong>接收端</strong></a></li>
<li><a href="#复用与分用">复用与分用</a></li>
</ul>
</li>
<li><a href="#tcp协议的可靠性">TCP协议的可靠性</a></li>
<li><a href="#tcp协议保证数据传输可靠性的方式">TCP协议保证数据传输可靠性的方式</a><ul>
<li><a href="#首部校验和">首部校验和</a></li>
<li><a href="#序列号和确认应答ack">序列号和确认应答(ACK)</a><ul>
<li><a href="#序列号">序列号</a></li>
<li><a href="#确认应答">确认应答</a></li>
<li><a href="#选择确认-sack">选择确认 SACK</a></li>
</ul>
</li>
<li><a href="#超时重传">超时重传</a></li>
<li><a href="#流量控制">流量控制</a></li>
<li><a href="#滑动窗口以字节为单位">滑动窗口(以字节为单位)</a></li>
<li><a href="#拥塞控制">拥塞控制</a><ul>
<li><a href="#慢开始"><strong>慢开始</strong></a></li>
<li><a href="#拥塞避免"><strong>拥塞避免</strong></a></li>
<li><a href="#快重传"><strong>快重传</strong></a></li>
<li><a href="#快恢复"><strong>快恢复</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tcp-报文段首部格式20byte">TCP 报文段首部格式(20Byte)</a></li>
<li><a href="#udp报文段首部格式8byte">UDP报文段首部格式(8Byte)</a><ul>
<li><a href="#计算伪首部的原因">计算伪首部的原因</a></li>
</ul>
</li>
<li><a href="#停止等待-arq-协议">停止等待 ARQ 协议</a></li>
<li><a href="#常见的拥塞控制算法">常见的拥塞控制算法</a></li>
<li><a href="#三次握手四次挥手">三次握手四次挥手</a><ul>
<li><a href="#三次握手">三次握手</a></li>
<li><a href="#四次挥手">四次挥手</a></li>
<li><a href="#tcp三次握手如果第三次客户端发出的信息服务器没收到怎么办">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</a></li>
<li><a href="#如果出现了大量的timewait可能有什么原因">如果出现了大量的TIMEWAIT可能有什么原因？</a><ul>
<li><a href="#如何尽量处理timewait过多"><strong>如何尽量处理TIMEWAIT过多?</strong></a></li>
</ul>
</li>
<li><a href="#如果出现了大量的closewait可能有什么原因">如果出现了大量的CLOSEWAIT可能有什么原因？</a></li>
</ul>
</li>
<li><a href="#tcp重传机制">TCP重传机制</a><ul>
<li><a href="#tcp协议中的计时器">TCP协议中的计时器</a></li>
<li><a href="#nagle算法">Nagle算法</a></li>
</ul>
</li>
<li><a href="#tcpip中的分组和分片">TCP/IP中的分组和分片</a><ul>
<li><a href="#分组交换">分组交换</a></li>
<li><a href="#分片">分片</a></li>
</ul>
</li>
<li><a href="#socket">Socket</a><ul>
<li><a href="#什么是socket">什么是socket</a><ul>
<li><a href="#socket函数">socket函数</a></li>
<li><a href="#bind函数">bind函数</a></li>
<li><a href="#listenconnect函数">listen/connect函数</a></li>
<li><a href="#accept函数">accept函数</a></li>
</ul>
</li>
<li><a href="#readwrite函数">read/write函数</a></li>
<li><a href="#socket通信中tcp-udp数据包大小的确定">SOCKET通信中TCP、UDP数据包大小的确定</a><ul>
<li><a href="#mtu最大传输单元">MTU最大传输单元</a></li>
</ul>
</li>
<li><a href="#backlog是干嘛的">backlog是干嘛的</a></li>
</ul>
</li>
<li><a href="#为什么会发生粘包黏包">为什么会发生粘包/黏包？</a><ul>
<li><a href="#tcp当中才会有粘包问题udp不存在粘包问题"><strong>TCP当中才会有粘包问题，UDP不存在粘包问题</strong></a></li>
<li><a href="#如何避免粘包问题">如何避免粘包问题？</a></li>
</ul>
</li>
<li><a href="#为什么会发生丢包">为什么会发生丢包？</a></li>
<li><a href="#访问toutiaocom打不开应该怎么排查错误">访问toutiao.com打不开，应该怎么排查错误？</a></li>
</ul>
</li>
<li><a href="#ip网络层">IP/网络层</a><ul>
<li><a href="#地址解析协议-arp">地址解析协议 ARP</a><ul>
<li><a href="#计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</a></li>
</ul>
</li>
<li><a href="#dhcp">DHCP</a></li>
<li><a href="#icmpigmp">ICMP/IGMP</a><ul>
<li><a href="#网际控制报文协议-icmp">网际控制报文协议 <strong>ICMP</strong></a></li>
<li><a href="#icmp-报文种类">ICMP 报文种类</a><ul>
<li><a href="#ping和telnet的区别">ping和telnet的区别</a></li>
</ul>
</li>
<li><a href="#网际组管理协议-igmp">网际组管理协议 <strong>IGMP</strong></a></li>
</ul>
</li>
<li><a href="#ip-数据报的格式">IP 数据报的格式</a><ul>
<li><a href="#首部固定字段">首部固定字段</a></li>
<li><a href="#首部可变部分">首部可变部分</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http">HTTP</a><ul>
<li><a href="#http状态码">HTTP状态码</a></li>
<li><a href="#http字段">HTTP字段</a></li>
<li><a href="#https的通信过程">⭐HTTPS的通信过程</a><ul>
<li><a href="#非对称加密算法对称加密算法">非对称加密算法+对称加密算法</a></li>
<li><a href="#数字证书-防止中间人攻击">数字证书—防止中间人攻击</a></li>
<li><a href="#数字摘要算法">数字摘要算法</a></li>
<li><a href="#证书内置">证书内置</a></li>
</ul>
</li>
<li><a href="#getpost-区别">get/post 区别</a></li>
<li><a href="#httphttps-09-10-11-20-30的特点和区别">http/https 0.9、1.0、1.1、2.0、3.0的特点和区别</a><ul>
<li><a href="#http09">Http0.9</a></li>
<li><a href="#http10">Http1.0</a></li>
<li><a href="#http11">Http1.1</a></li>
<li><a href="#http20基于https">Http2.0(基于HTTPS)</a></li>
<li><a href="#http30">Http3.0</a></li>
</ul>
</li>
<li><a href="#quic和bbr">QUIC和BBR</a></li>
<li><a href="#http的无状态性">HTTP的无状态性</a><ul>
<li><a href="#cookie">Cookie</a></li>
<li><a href="#session">Session</a></li>
<li><a href="#session和cookie的关系">Session和Cookie的关系</a></li>
</ul>
</li>
<li><a href="#http请求种类">HTTP请求种类</a></li>
<li><a href="#http报文结构和内容">HTTP报文结构和内容</a><ul>
<li><a href="#请求报文">请求报文</a><ul>
<li><a href="#请求行">请求行</a></li>
<li><a href="#请求头部">请求头部</a></li>
<li><a href="#空行">(空行)</a></li>
<li><a href="#请求数据">请求数据</a></li>
</ul>
</li>
<li><a href="#响应报文">响应报文</a><ul>
<li><a href="#状态行">状态行</a></li>
<li><a href="#响应头部">响应头部</a></li>
<li><a href="#空行-1">(空行)</a></li>
<li><a href="#响应体">响应体</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#从浏览器输入url到出现页面经过了哪些阶段">从浏览器输入URL到出现页面经过了哪些阶段</a><ul>
<li><a href="#输入网址"><strong>输入网址</strong>：</a></li>
<li><a href="#缓存解析"><strong>缓存解析</strong></a></li>
<li><a href="#域名解析dns"><strong>域名解析(DNS)</strong></a></li>
<li><a href="#tcp链接三次握手"><strong>tcp链接，三次握手</strong></a></li>
<li><a href="#发送http请求">发送HTTP请求</a></li>
<li><a href="#服务器收到请求"><strong>服务器收到请求</strong></a></li>
<li><a href="#浏览器页面渲染"><strong>浏览器页面渲染</strong></a></li>
<li><a href="#断开连接四次挥手"><strong>断开连接，四次挥手</strong></a></li>
</ul>
</li>
<li><a href="#http如何实现缓存怎样告诉浏览器这个可以被缓存以及缓存时间">HTTP如何实现缓存，怎样告诉浏览器这个可以被缓存以及缓存时间</a></li>
</ul>
</li>
<li><a href="#网络io">网络IO</a><ul>
<li><a href="#五种io模型">五种IO模型</a><ul>
<li><a href="#阻塞iobio">阻塞IO(BIO)</a></li>
<li><a href="#非阻塞ionio">非阻塞IO(NIO)</a></li>
<li><a href="#io多路复用">IO多路复用</a></li>
<li><a href="#信号驱动的io模型sigio">信号驱动的IO模型(SIGIO)</a></li>
<li><a href="#异步io模型aio非阻塞">异步IO模型(AIO)(非阻塞)</a></li>
</ul>
</li>
<li><a href="#两种io事件处理模式">两种IO事件处理模式</a><ul>
<li><a href="#reactor模式同步的">Reactor模式(同步的)</a></li>
<li><a href="#proactor模式-异步">Proactor模式 (异步)</a></li>
</ul>
</li>
<li><a href="#io多路复用selectpollepoll同步阻塞">⭐IO多路复用：select/poll/epoll(同步/阻塞)</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a><ul>
<li><a href="#epoll-函数">epoll 函数</a></li>
<li><a href="#epoll的底层实现"><strong>epoll的底层实现</strong></a></li>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
<li><a href="#边缘触发et水平触发lt">边缘触发ET&amp;水平触发LT</a></li>
<li><a href="#lt和et的读写问题">LT和ET的读写问题</a></li>
<li><a href="#et模式的线程饥饿问题">ET模式的线程饥饿问题</a></li>
<li><a href="#epolloneshot设置">EPOLLONESHOT设置</a></li>
<li><a href="#两种模式的选择">两种模式的选择</a></li>
<li><a href="#epoll的惊群问题epollexclusive">Epoll的惊群问题(EPOLLEXCLUSIVE)</a></li>
<li><a href="#epoll边缘触发的io应该怎么写">Epoll边缘触发的IO应该怎么写？</a></li>
</ul>
</li>
<li><a href="#epollpoll的选择">Epoll/poll的选择？</a><ul>
<li><a href="#什么情况下使用epoll">什么情况下使用Epoll：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcjvgSoF3zeGINoyibX5tpfgfQwBABm2KMEnohSmkRXjzicCuQtt4IWsc9fniahl1mW39gS674icZibqibQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h2><span id="osi七层模型每一层的协议">OSI七层模型，每一层的协议</span></h2><p><a href="https://blog.csdn.net/qq_16093323/article/details/79582554?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=64d1fc0e-2b2f-4f9c-b5db-b276ab07ce2e&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">https://blog.csdn.net/qq_16093323/article/details/79582554?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=64d1fc0e-2b2f-4f9c-b5db-b276ab07ce2e&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<p><img src="https://img-blog.csdn.net/20180316155619885?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzE2MDkzMzIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1739381/201907/1739381-20190718231440734-1731506013.png" alt="img"></p>
<h4><span id="协议分别有">协议分别有：</span></h4><ol>
<li><p>物理层协议有：EIA/TIA-232，EIA/TIA-499，V.35， V.24，RJ45， Ethernet，SLTP</p>
</li>
<li><p>数据链路层协议有：Frame Relay，HDLC， IEEE 802.3/802.2, PPP</p>
</li>
<li><p>网络层协议有：IP，IPX，RIP，OSPF, ARP等等</p>
</li>
<li><p>传输层协议有：TCP，UDP，SPX</p>
</li>
<li><p>会话层协议有：RPC，SQL，NFS，NetBIOS，names，AppleTalk</p>
</li>
<li><p>表示层协议有：<strong>格式化的表示和转换数据服务，数据的压缩和解压缩， 加密和解密等工作</strong>：TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption</p>
</li>
<li><p>应用层协议有：FTP，WWW，Telnet，NFS，SMTP，Gateway，SNMP</p>
</li>
</ol>
<h2><span id="tcpudp运输层">TCP/UDP/运输层</span></h2><h3><span id="udp和tcp的差别">⭐UDP和TCP的差别</span></h3><p><strong>UDP：</strong></p>
<ul>
<li><strong>无连接</strong>：减少了开销和发送前时延；</li>
<li><strong>尽最大努力交付</strong>：不保证可靠交付；</li>
<li><strong>面向报文</strong>：对应用层交下来的报文既不合并，也不拆分，保留这些报文的边界。</li>
<li><strong>没有拥塞控制</strong>：网络拥塞不会使源主机发送速率降低，允许在网络拥塞时丢失一些数据，却不允许数据有太大的时延。</li>
<li><strong>支持一对一、一对多、多对一、多对多的交互通信</strong></li>
<li><strong>首部开销小：</strong> 首部长度只有 <strong>8</strong> 字节，比 TCP 的 <strong>20</strong> 字节短。</li>
</ul>
<p><strong>TCP:</strong></p>
<ul>
<li><strong>面向连接：</strong> 传输前需建立连接，传输完成需释放连接；TCP 连接是一条<strong>逻辑连接</strong>。</li>
<li><strong>点对点：</strong> 每一条 TCP 连接只能有两个端点；</li>
<li><strong>提供可靠交付：</strong> 无差错、不丢失、不重复、不失序；</li>
<li><strong>全双工通信：</strong> 设有发送缓存和接收缓存，允许双方随时发送数据。</li>
<li><strong>面向字节流：</strong> TCP 把应用进程交下来的数据看作<strong>一连串的无结构字节流</strong>；</li>
</ul>
<hr>
<h3><span id="tcpudp数据发送和接收过程">TCP/UDP数据发送和接收过程</span></h3><h4><span id="发送端"><strong>发送端</strong></span></h4><p>数据发送是发送到物理链路层的，从<strong>应用层</strong>开始，经过一层层的数据报文的封装，最终封装成<strong>以太网封装格式</strong> 和 <strong>802.x 封装格式的数据包</strong>，通过有线网络或无线网络在以太网上传输<strong>数据帧</strong>（bit流）。</p>
<h4><span id="接收端"><strong>接收端</strong></span></h4><p><img src="https://krahets.gitee.io/assets/img/1568283339430.91a72ae3.png" alt="1568283339430"></p>
<p>接收端和发送端的顺序刚好相反。即分别经过</p>
<ul>
<li>经过数据链路层去掉<strong>以太网的头部</strong>得到<strong>以太网MAC帧</strong></li>
<li>经过网络层去掉<strong>IP的头部</strong>得到<strong>IP数据包</strong></li>
<li>经过传输层去掉 <code>TCP/UDP</code> 的头部得到<strong>报文段/用户数据报</strong></li>
<li>经过应用层得到数据流</li>
</ul>
<p>就完成了整个的数据传输过程。</p>
<h4><span id="复用与分用">复用与分用</span></h4><p>应用层所有应用进程都可以通过运输层传输到 <code>IP</code> 层，称为<strong>复用</strong>；运输层从 <code>IP</code>  层收到发送给各应用进程的数据后，必须分别交付给指明的各应用进程，称为<strong>分用</strong>。</p>
<hr>
<h3><span id="tcp协议的可靠性">TCP协议的可靠性</span></h3><ol>
<li><strong>应用数据被分割成TCP认为最适合发送的数据块</strong>。(这和UDP完全不同，应用程序产生的数据报长度将保持不变)。</li>
<li><strong>超时重传:</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认,将重发这个报文段。</li>
<li>TCP给发送的每一一个包进行编号 ,接收方对数据包进行排序,把有序数据传送给应用层。（TCP报文段作为IP数据报来传输，IP数据报的大刀可能会失序，因此TCP报文段的到达也可能会失序，如果必要，TCP将对收到的数据进行<strong>重新排序</strong>）。</li>
<li><strong>校验和</strong>: TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错, TCP将丢弃这个报文段和不确认收到此报文段。</li>
<li>IP数据报会发生重复，TCP的接收端会<strong>丢弃重复</strong>的数据。</li>
<li><strong>流量控制:</strong> TCP连接的每一方都有固定大小的缓冲空间 , TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据,能提示发送方降低发送的速率,防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li><strong>拥塞控制</strong>：当网络拥塞时,减少数据的发送。</li>
<li><strong>确认响应</strong>：对于一个收到的请求，将发送一个确认。这个确认通常要延迟几分之一秒。</li>
</ol>
<h3><span id="tcp协议保证数据传输可靠性的方式">TCP协议保证数据传输可靠性的方式</span></h3><h4><span id="首部校验和">首部校验和</span></h4><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。<br><strong>发送方</strong>：在发送数据之前计算检验和，并进行校验和的填充。<br><strong>接收方</strong>：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p>
<p><img src="https://img-blog.csdn.net/20180524102010286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<h4><span id="序列号和确认应答ack">序列号和确认应答(ACK)</span></h4><h5><span id="序列号">序列号</span></h5><p><code>TCP</code> 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答的作用，有了序列号能够<strong>将接收到的数据根据序列号排序，并且去掉重复序列号的数据</strong>。这也是 <code>TCP</code> 传输可靠性的保证之一。</p>
<h5><span id="确认应答">确认应答</span></h5><p><code>TCP</code> 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，也就是发送 <code>ACK</code> 报文。这个 <code>ACK</code> 报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<h5><span id="选择确认-sack">选择确认 SACK</span></h5><ul>
<li><p>假设收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么时候能设法只传送缺少的数据而不重传已经正确到达接收方的数据？选择确认 <code>SACK</code> 就是一种可行的处理方法。</p>
<p><img src="https://krahets.gitee.io/assets/img/1568793245619.0ba706e9.png" alt="1568793245619"></p>
</li>
<li><p>如果要使用选择确认 <code>SACK</code> ，那么在建立 <code>TCP</code> 连接时，就要在首部<strong>选项</strong>中加“允许 SACK”选项。</p>
<ul>
<li>首部选项长度最多 40 字节，指定一个边界需要用掉 4 字节（因为<strong>序号</strong>是 4 字节），因此选项中最多可以指明 4 个字节块的边界信息（8个边界共用掉 32 字节，还有 2 字节分别用来指明 SACK 选项和这个选项要占用多少字节）。</li>
</ul>
</li>
</ul>
<hr>
<h4><span id="超时重传">超时重传</span></h4><p>在进行 <code>TCP</code> 传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 <code>ACK</code> 报文，并解析 <code>ACK</code> 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的 <code>ACK</code> 报文，这该怎么办呢？而没有收到 <code>ACK</code> 报文的原因可能是什么呢？</p>
<p>首先，发送方没有介绍到响应的 <code>ACK</code> 报文原因可能有两点：</p>
<ol>
<li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本<strong>没有接收</strong>到。</li>
<li>接收方<strong>接收到了</strong>响应的数据，但是发送的 <code>ACK</code> 报文响应却由于网络原因<strong>丢包</strong>了。</li>
</ol>
<p>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>。简单理解就是发送方在发送完数据后等待一个时间(<strong>500ms的整数倍</strong>)，时间到达没有接收到 <code>ACK</code> 报文，那么对刚才发送的数据进行重新发送。</p>
<p>如果是刚才第一个原因，接收方收到二次重发的数据后，便进行 <code>ACK</code> 应答。</p>
<p>如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是<strong>序列号</strong>，所以上面说序列号还有<strong>去除重复数据的作用</strong>），<strong>那么直接丢弃，仍旧发送 <code>ACK</code> 应答。</strong></p>
<hr>
<h4><span id="流量控制">流量控制</span></h4><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。</p>
<p>而<strong>TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制</strong>。在TCP协议的报头信息当中，有一个<strong>16位字段的窗口大小</strong>。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是<strong>接收端接收数据缓冲区的剩余大小rwnd</strong>。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。</p>
<p><strong>接收端会在确认应答发送 <code>ACK</code> 报文时，将自己的即时窗口大小填入，并跟随 <code>ACK</code> 报文一起发送过去</strong>。</p>
<p><strong>发送方根据</strong> <code>ACK</code> 报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p><img src="https://img-blog.csdn.net/20180524111634561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<h4><span id="滑动窗口以字节为单位">滑动窗口(以字节为单位)</span></h4><ul>
<li>假定 <code>A</code> 收到来自 <code>B</code> 的确认报文段，其中窗口是 20 字节，确认号是 31 (表明 <code>B</code> 期望收到的下一个序号是 31)。根据这两个数据， <code>A</code> 构造出自己的发送窗口。</li>
</ul>
<p><img src="https://krahets.gitee.io/assets/img/1568790013316.97bfddcb.png" alt="1568790013316"></p>
<ul>
<li><p>发送窗口由<strong>前沿</strong>和<strong>后沿</strong>共同确定。发送窗口通常<strong>不断向前移动</strong>，也有<strong>可能不动</strong>（一是没有收到新的确认；二是收到了新的确认但对方通知窗口缩小了，因此只有后沿缩小，前沿正好不动）。</p>
</li>
<li><p>描述一个发送窗口的状态需要<strong>三个指针</strong>：$P_1,P_2,P_3$，指针指向字节序号。</p>
<ul>
<li>小于 $P_1$ 是已经发送并<strong>收到确认</strong>的部分</li>
<li>$P_1 - P_2$ 是已经发送但<strong>未收到确认</strong>的部分</li>
<li>$P_2 - P_3$ 是<strong>窗口内允许发送</strong>但<strong>尚未发送</strong>的部分</li>
<li>大于 $P_3$ 是<strong>窗口外不允许发送</strong>的部分</li>
</ul>
<p><img src="https://krahets.gitee.io/assets/img/1568790430010.9e25f59d.png" alt="1568790430010"></p>
</li>
</ul>
<hr>
<h4><span id="拥塞控制">拥塞控制</span></h4><ul>
<li><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p>
<p><img src="https://krahets.gitee.io/assets/img/1568796886603.87101025.png" alt="1568796886603"></p>
</li>
</ul>
<ul>
<li><p>发送方窗口的上限值应取<strong>接收方窗口 rwnd 和拥塞窗口 cwnd 两个变量中的较小值</strong>：</p>
</li>
<li><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p>
</li>
<li><p>TCP拥塞控制由四个部分组成：<strong>慢开始，拥塞避免，快重传，快恢复</strong></p>
<p><img src="https://krahets.gitee.io/assets/img/1568796161225.0a85de7d.png" alt="1568796161225"></p>
</li>
</ul>
<h5><span id="慢开始"><strong>慢开始</strong></span></h5><ul>
<li>在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做<strong>拥塞窗口(cwnd)</strong>的概念。发送刚开始定义拥塞窗口为 <code>1</code>，在传输的过程中以<strong>2的倍数</strong>指数增大 <code>cwnd</code> 直至其大于 <code>ssthreshold</code> ，之后转为<strong>拥塞避免</strong>，<strong>每次收到ACK应答，拥塞窗口加 1</strong>。</li>
<li>在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</li>
</ul>
<h5><span id="拥塞避免"><strong>拥塞避免</strong></span></h5><ul>
<li><strong>当 cwnd &lt; ssthresh 时</strong>，使用慢开始算法；<strong>当 cwnd &gt; ssthresh 时</strong>，使用拥塞避免算法。</li>
<li>网络出现超时（既发生重传时），发送方判断网络拥塞，于是调整门限值 <strong>ssthresh = cwnd / 2，cwnd = 1</strong>，并进入慢开始阶段；当逐渐增大到 <strong>ssthresh = cwnd</strong> 时，进入拥塞避免阶段。</li>
</ul>
<h5><span id="快重传"><strong>快重传</strong></span></h5><p>让发送方尽早<strong>知道个别报文段的丢失</strong>，以至于<strong>不需超时重传</strong>。使用快重传可以使整个网络吞吐量提升 20% 。</p>
<ul>
<li><p>快重传要求接收方不要等待自己发送数据时才捎带确认，而是<strong>立即发送确认</strong>；即使收到了失序的报文段也要立即发出对已收到的报文段(图中M2)的<strong>重复确认</strong>。</p>
</li>
<li><p>如下图所示，发送方只要<strong>一连收到 3 个重复确认ACK</strong>，就知道接收方没有收到 <code>M3</code> ，而<strong>立即重传 M3</strong> 。</p>
</li>
</ul>
<p>  <img src="https://krahets.gitee.io/assets/img/1568796172902.50a3f779.png" alt="1568796172902"></p>
<h5><span id="快恢复"><strong>快恢复</strong></span></h5><p>当接收到连续 3 个重复确认时，知道只是丢失了个别报文段，于是不启动慢开始，而是执行快恢复。</p>
<ul>
<li>发送方调整门限值 <strong>ssthresh = cwnd / 2</strong>；同时设置 <strong>cwnd = ssthresh</strong> ，立即进入<strong>拥塞避免</strong>。</li>
<li>这样做的好处是<strong>避免个别丢失的报文段被误认为是网络拥塞造成。</strong></li>
</ul>
<hr>
<h3><span id="tcp-报文段首部格式20byte">TCP 报文段首部格式(20Byte)</span></h3><ul>
<li>TCP 报文段首部前 <code>20</code> 字节固定，后面有 <code>4n</code> 字节可根据需要加选项。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181130165347546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzA4MDI3,size_16,color_FFFFFF,t_70" alt="图片来源于网络"></p>
<ul>
<li><strong>源端口和目的端口：</strong> 各占 <strong>2</strong> 字节；TCP 的分用功能通过端口实现。</li>
<li><strong>序号(seq)：</strong> 占 <strong>4</strong> 字节（序号范围 $[0,2^{32}-1]$）；TCP 传送的<strong>字节流</strong>中每一个字节都<strong>按顺序编号</strong>；序号字段代表本报文段发送数据的<strong>第一个字节的序号</strong>，例如一报文段序号 <code>301</code> ，最后一个字节序号 <code>400</code> ，那么下一个报文段的数据序号应当从 <code>401</code> 开始。</li>
<li><strong>确认号(ACK)</strong>：占 <strong>4</strong> 字节；代表<strong>期望收到对方下一个报文段第一个数据字节的序号</strong>；例如 <code>B</code> 正确收到一个报文段，序号字段是 <code>501</code>，数据长度是 <code>200</code> 字节，则 <code>B</code> 期望收到下一个数据序号是 <code>701</code> ，即将发送给 <code>A</code> 的确认报文段中的确认号置为 <code>701</code> 。若确认号 = <code>N</code>，代表直到序号 <code>N-1</code> 的所有数据都已正确收到。</li>
<li><strong>数据偏移</strong>：占 <strong>4</strong> 字节；指出 TCP 报文段<strong>数据起始处</strong>距离 TCP 报文段起始处的距离；能表示的最大十进制数字为 15，因此数据偏移最大值是 60 字节，也是 TCP 首部的最大长度。</li>
<li><strong>保留：</strong> 占 <strong>6</strong> 位，保留今后使用，应设置为 0；</li>
<li><strong>紧急 URG (urgent)：</strong> 当 <strong>URG = 1</strong> 时，表明紧急指针字段有效。发送方 TCP 把紧急数据插入到本报文段数据的<strong>最前面</strong>。</li>
<li><strong>确认 ACK (acknowledgment)</strong>：仅当 <strong>ACK = 1</strong> 时<strong>确认号</strong>字段有效。TCP 规定，在连接建立后所有传送的报文段应将 <code>ACK</code> 置 1 。</li>
<li><strong>推送 PSH (push)：</strong> 当两个应用进程交互式通信时，一段应用进程希望键入一个命令后立即收到对方响应；推送操作很少使用。</li>
<li><strong>复位 RST (reset)：</strong> <code>RST = 1</code> 代表 TCP 出现严重差错（例如主机崩溃），必须释放连接； <code>RST</code> 还用来拒绝一个非法的报文段或拒绝打开一个连接。</li>
<li><strong>同步 SYN (synchronization)：</strong> 连接建立时用来同步序号。当 <code>SYN = 1</code> 而 <code>ACK = 0</code> 时，表明这是一个<strong>连接请求</strong>报文段。<code>SYN = 1</code> 和 <code>ACK = 1</code> 就表示<strong>连接接受</strong>。</li>
<li><strong>终止 FIN (finish)：</strong> 用来释放一个连接。当 <code>FIN = 1</code> 时，表明发送方数据已经发送完毕，并要求<strong>释放连接</strong>。</li>
<li><strong>窗口：</strong> 占 <strong>2</strong> 字节；指发送本报文段的一方的<strong>接收窗口</strong>（窗口大小是由接收方定的，作为发送方设置其发送窗口的依据）。窗口字段明确指出了现在允许对方发送的数据量。窗口值是动态变化的。</li>
<li><strong>检验和：</strong> 占 <strong>2</strong> 字节；检验范围包括<strong>首部和数据</strong>两部分。计算检验和前需要在 TCP 报文段前面加上 12 字节的伪首部，格式与 UDP 伪首部一样，但应把第 4 个字段中的 17 改为 6 （TCP 协议号为 6 ），把第 5 个字段中 UDP 长度改为 TCP 长度。</li>
<li><strong>紧急指针：</strong>占 <strong>2</strong> 字节；仅在 <code>URG = 1</code> 时才有意义，指出本报文段中紧急数据的字节数（紧急数据后都是普通数据），紧急指针指出了紧急数据的末尾所在报文段中的位置；窗口为 0 时也可发紧急数据。</li>
<li><strong>选项：</strong> 长度可变，<strong>最长 40 字节</strong>。<strong>无选项时， TCP 首部长度为 20 字节。</strong></li>
</ul>
<p>相应的，<code>UDP</code> 的报文段只有<strong>源端口+目的端口+长度+检验和：</strong> 各占 <strong>2</strong> 字节，<strong>首部长度为8字节。</strong></p>
<p><strong>长度字段：</strong>占<code>16</code>比特。标明 <code>UDP</code> 头部和 <code>UDP</code> 数据的总长度字节，<code>UDP</code> 首部的长度为固定的 <code>8</code> 个字节，加上 <code>UDP</code> 数据长度就是长度大小，<code>UDP</code> 数据长度可以通过 <code>wireshark</code> 抓包看到。</p>
<p><img src="https://krahets.gitee.io/assets/img/1568704529477.08a8d8a2.png" alt="1568704529477"></p>
<hr>
<h3><span id="udp报文段首部格式8byte">UDP报文段首部格式(8Byte)</span></h3><p><img src="https://img-blog.csdnimg.cn/20201213000709282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODI0MTQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>UDP</strong> 首部字段有 <strong>8 个字节</strong>，由 4 个字段组成，每个字段都是两个字节。</p>
<ul>
<li><p><strong>源端口：</strong><br>表示发送端端口，字段长度16位。可选项，有时候可能不会设置源端口号。没有源端口号的时候该字段的值设置为0。可用于不需要返回的通信中。</p>
</li>
<li><p><strong>目标端口：</strong><br>表示接收端端口，字段长度16位。</p>
</li>
<li><p><strong>包长度：</strong><br>该字段保存了UDP首部的长度跟数据长度之和。单位为字节（8位的字节），实际最大长度不可能超过65507字节 2^16(635535) - 8字节UDP报头 − 20字节IP头部</p>
</li>
<li><p><strong>校验和：</strong><br>校验和是为了提供可靠的UDP首部和数据。如果不使用校验和，该字段应被填充为全0。这种情况下，由于不进行校验和计算，协议处理的开销就会降低，从而可以<strong>提高数据转发的速度。</strong><br>在计算校验和时，为了能够计算校验和，需要在UDP数据包前添加一个“伪首部”。<strong>伪首部包括了IPv4头部中的一些信息，但它并不是发送IP数据包时使用的IP数据包的头部，而只是一个用来计算校验和而已</strong>。接收主机在收到UDP报文以后，从IP首部获悉IP地址信息构造UDP伪首部。在进行校验和计算。</p>
</li>
</ul>
<h4><span id="计算伪首部的原因">计算伪首部的原因</span></h4><p>识别一个通信应用需要五元组。<strong>“源IP地址”</strong>、<strong>“目标IP地址”</strong>、<strong>“源端口”</strong>、<strong>“目标端口”</strong>、<strong>“协议号”</strong>。UDP首部只包含了（源端口和目标端口），用此来校验，如果其他三项信息被破坏，极有可能导致应收包应用收不到，不应该收包的应用收到。</p>
<p>为此，有必要在通信中，验证这5项的识别码是否正确，就引入了伪首部的概念。</p>
<hr>
<h3><span id="停止等待-arq-协议">停止等待 ARQ 协议</span></h3><hr>
<h3><span id="常见的拥塞控制算法">常见的拥塞控制算法</span></h3><p>Reno、HSTCP、BIC、Vegas、Westwood、BBR</p>
<hr>
<h3><span id="三次握手四次挥手">三次握手四次挥手</span></h3><h4><span id="三次握手">三次握手</span></h4><ul>
<li><strong>防止已失效的连接请求又传送到服务器端，因而产生错误：</strong>假设 <code>A</code> 发出的第一个连接请求报文段没有丢失，而是在网络某处长时间滞留了，本来这是一个失效的连接请求；但后续 <code>B</code> 收到了它，误认为是 <code>A</code> 的连接请求，就向 <code>A</code> 发出确认报文段。若不采用三报文握手，此时一个已经失效的连接已经被建立，网络资源被白白浪费了。</li>
</ul>
<table>
<thead>
<tr>
<th>握手次数</th>
<th>A 确认</th>
<th>B 确认</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一次</td>
<td></td>
<td>A 发送正常，B 接收正常</td>
</tr>
<tr>
<td>第二次</td>
<td>A 发送正常， B 接收正常；A接收正常，B发送正常</td>
<td></td>
</tr>
<tr>
<td>第三次</td>
<td></td>
<td>A 发送正常， B 接收正常；A接收正常，B发送正常</td>
</tr>
</tbody>
</table>
<p><img src="https://krahets.gitee.io/assets/img/1568797056445.aa1412a3.png" alt="1568797056445"></p>
<h4><span id="四次挥手">四次挥手</span></h4><ol>
<li><code>A</code> 发送 TCP 连接释放报文，进入 <strong>FIN-WAIT-1</strong> 状态，<strong>等待 B 的确认</strong>；</li>
<li><code>B</code> 收到报文段后立即发出确认，并进入 <strong>CLOSE-WAIT</strong> 状态；此时 <code>A</code> 到 <code>B</code> 的单向连接已经被释放， TCP 连接处于<strong>半关闭状态</strong>；<code>B</code> 继续向 <code>A</code> 传输未完成的数据。</li>
<li><code>A</code> 收到 <code>B</code> 的确认后，进入 <strong>FIN-WAIT-2</strong> 状态，<strong>等待 B 的连接释放报文段</strong>；</li>
<li>若 <code>B</code> 已经将所有数据向 <code>A</code> 发送完毕，则向 <code>A</code> 发送 TCP 连接释放报文，并进入 <strong>LAST-ACK</strong> 状态，<strong>等待 A 的确认</strong>；</li>
<li><code>A</code> 收到 <code>B</code> 的连接释放报文段后，立即发出确认，然后进入 <strong>TIME-WAIT</strong> 状态，必须经过时间等待计时器 设置的时间 <strong>2MSL(4 min)</strong> 后，<code>A</code> 才进入 <strong>CLOSED</strong> 状态，这是因为：<ul>
<li><strong>第一：</strong> 由于 <code>A</code> 到 <code>B</code> 的最后的 <code>ACK</code> 确认报文段有可能丢失，<code>B</code> 可能回超时重传释放连接报文段，而 <code>A</code> 就能在 <code>2MSL</code> 时间内收到这个重传的连接释放报文段，并重传确认且重新启动 <code>2MSL</code> 计时器。</li>
<li><strong>第二：</strong> 防止<strong>“已失效的连接请求报文段”</strong>出现在本连接中， <code>A</code> 等待 <code>2MSL</code> 就可以使本链接持续时间内所产生的所有报文段在网络中小时。</li>
</ul>
</li>
</ol>
<p><img src="https://krahets.gitee.io/assets/img/1568797480363.f8ec5647.png" alt="1568797480363"></p>
<hr>
<h4><span id="tcp三次握手如果第三次客户端发出的信息服务器没收到怎么办">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</span></h4><hr>
<h4><span id="如果出现了大量的timewait可能有什么原因">如果出现了大量的TIMEWAIT可能有什么原因？</span></h4><p>一些<strong>爬虫服务器或者WEB服务器</strong>（如果网管在安装的时候没有做内核参数优化的话）上经常会遇到这个问题，这个问题是怎么产生的呢？</p>
<p>对于基于 <code>TCP</code> 的 <code>HTTP</code> 协议，关闭 <code>TCP</code> 连接的是 <code>Server</code> 端，这样，<code>Server</code> 端会进入 <code>TIME_WAIT</code> 状态，可想而知，对于访问量大的 <code>Web Server</code> ，会存在大量的 <code>TIME_WAIT</code> 状态，假如 <code>Server</code> 一秒钟接收1000个请求，那么就会积压 <code>240*1000=240000</code> 个 <code>TIME_WAIT</code> 的记录，<strong>维护这些状态给Server带来负担</strong>。当然现代操作系统都会用快速的查找算法来管理这些TIME_WAIT，所以对于新的 TCP连接请求，判断是否hit中一个TIME_WAIT不会太费时间，但是有这么多状态要维护总是不好。</p>
<h5><span id="如何尽量处理timewait过多"><strong>如何尽量处理TIMEWAIT过多?</strong></span></h5><p>解决思路很简单，就是让服务器能够<strong>快速回收和重用</strong>那些TIME_WAIT的资源。编辑内核文件 <code>/etc/sysctl.conf</code> ，加入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">表示当keepalive启用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒</span></span><br><span class="line">net.ipv4.tcp_keepalive_time=1200</span><br><span class="line"><span class="meta">#</span><span class="bash">表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"><span class="meta">#</span><span class="bash">表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="meta">#</span><span class="bash">表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="meta">#</span><span class="bash">表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"><span class="meta">#</span><span class="bash">减少超时前的探测次数</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes=5</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="如果出现了大量的closewait可能有什么原因">如果出现了大量的CLOSEWAIT可能有什么原因？</span></h4><p><code>TIME_WAIT</code> 状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。<br>但是CLOSE_WAIT就不一样了，从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是<strong>在对方关闭连接之后服务器程序自己没有进一步发出ACK信号</strong>。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是<strong>这个资源就一直被程序占着</strong>。个人觉得这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。</p>
<p>举个场景，来说明CLOSE_WAIT和TIME_WAIT的区别：<br>服务器A是一台爬虫服务器，它使用简单的HttpClient去请求资源服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完资源后，服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，服务器A的连接状态我们可以看到是TIME_WAIT。如果一旦发生异常呢？假设请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，如果服务器A被动关闭连接之后程序员忘了让HttpClient释放连接，那就会造成CLOSE_WAIT的状态了。</p>
<p>所以如果将大量CLOSE_WAIT的解决办法总结为一句话那就是：<strong>查代码</strong>。因为问题出在服务器程序里头啊。</p>
<hr>
<h3><span id="tcp重传机制">TCP重传机制</span></h3><p><img src="https://img-blog.csdn.net/20160911000133291" alt="img"></p>
<ol>
<li><p>Server 发送80个字节 Part1，seq = 1 </p>
</li>
<li><p>Server 发送120个字节Part2，Seq = 81</p>
</li>
<li><p>Server发送160个字节Part3，Seq = 201，此包由于其他原因丢失</p>
</li>
<li><p>Client收到前2个报文段，并发送ACK = 201</p>
</li>
<li><p>Server发送140个字节Part4， Seq = 361</p>
</li>
<li>Server收到Client对于<strong>前两个报文段的ACK，将2个报文从窗口中移除</strong>，窗口有200个字节的余量</li>
<li>报文3的<strong>重传定时器到期</strong>，没有收到ACK，进行重传这个时候Client已经收到报文4，<strong>存放在缓冲区中，也不会发送ACK【累计通知，发送ACK就表示3也收到了】</strong>，等待报文3，报文3收到之后，一块对3,4进行确认</li>
<li>Server收到确认之后，将报文3,4移除窗口，所有数据发送完成</li>
</ol>
<p>超时重传指的是，发送数据包在一定的时间周期内没有收到相应的 <code>ACK</code> ，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 <code>RTO(Retransmision TimeOut)</code> 。  </p>
<p>检测丢失 <code>segment</code> 的方法从概念上讲还是比较简单的，每一次开始发送一个 <code>TCP segment</code> 的时候，就启动<strong>重传定时器</strong>，定时器的时间一开始是一个预设的值（Linux 规定为1s），随着通讯的变化以及时间的推移，这个定时器的溢出值是不断的在变化的，有相关算法计算 <code>RTO</code> ，如果在 <code>ACK</code> 收到之前，定时器到期，协议栈就会认为这个片段被丢失，重新传送数据。</p>
<p><img src="https://images2018.cnblogs.com/blog/1233668/201806/1233668-20180613233505890-1600510236.png" alt="img"></p>
<p>有这样几点原则：</p>
<ol>
<li><p>这些被发送的片段放在一个窗口中，等待被确认，<strong>没有确认不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变</strong>，这个地方其实在滑动窗口的时候也有提到过</p>
</li>
<li><p><strong>只有等到 <code>ACK</code> 收到的时候，变成发送并 <code>ACK</code> 的片段，才会被从窗口中移走。</strong></p>
</li>
<li><p>如果定时器到期没有收到对应 <code>ACK</code> ， 就重传这个 <code>TCP segment</code> </p>
</li>
<li>重传之后也没有办法完全保证，数据段一定被收到，所以<strong>仍然会重置定时器</strong>，等待 <code>ACK</code> ，如果定时器到期还是没有收到 <code>ACK</code> ，<strong>继续重传</strong>，这个过程重传的 <code>TCP segment</code> 一直留着队列之内。</li>
</ol>
<h4><span id="tcp协议中的计时器">TCP协议中的计时器</span></h4><p>我们可以理解成一块闹钟，隔一段时间响一次，提醒TCP做特定的事情。TCP要正常工作，必须要有特定的计时器。那么TCP中有哪些计时器呢？</p>
<p>TCP中有四种计时器（Timer），分别为：</p>
<ul>
<li><p><strong>重传计时器：Retransmission Timer</strong></p>
<p>TCP为了保证数据可靠传输，就规定在重传的时间片 <code>RTO</code> 到了以后，如果还没有收到对方的 <code>ACK</code> ，就重发此包，以避免陷入无限等待中。</p>
<p>当TCP发送报文段时，就创建该特定报文的重传计时器。可能发生两种情况：</p>
<ol>
<li><p>若在计时器截止时间到之前收到了对此特定报文段的确认，则撤销此计时器。</p>
</li>
<li><p>若在收到了对此特定报文段的确认之前计时器截止时间到，<strong>则重传此报文段，并将计时器复位</strong>。</p>
</li>
</ol>
</li>
<li><p><strong>持久计时器：Persistent Timer</strong></p>
<ul>
<li>先来考虑一下情景：发送端向接收端发送数据包知道接受窗口填满了，然后接受窗口告诉发送方接受窗口填满了停止发送数据。此时的状态称为“零窗口”状态，<strong>发送端和接收端窗口大小均为0</strong>。直到接受TCP<strong>发送确认并宣布一个非零的窗口大小</strong>。<strong>但这个确认会丢失</strong>。我们知道TCP中，对确认是不需要发送确认的。<strong>若确认丢失了，接受TCP并不知道</strong>，而是会认为他已经完成了任务，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口大小。双方的TCP都在永远的等待着对方。</li>
<li>要打开这种死锁，TCP为每一个链接使用一个持久计时器。当发送TCP收到窗口大小为0的确认时，就启动持久计时器。当持久计时器期限到时，发送TCP就发送一个特殊的报文段，叫做<strong>探测报文</strong>。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。</li>
<li>持久计时器的值设置为重传时间的数值。但是，<strong>若没有收到从接收端来的响应，则需发送另一个探测报文段，并将持久计时器的值加倍和复位</strong>。发送端继续发送探测报文段，将持久计时器设定的值加倍和复位，直到这个值增大到门限值（通常是60秒）为止。在这以后，发送端每个60秒就发送一个探测报文，直到窗口重新打开。</li>
</ul>
</li>
<li><p><strong>保活计时器：Keeplive Timer</strong></p>
<ul>
<li>保活计时器使用在某些实现中，用来<strong>防止在两个TCP之间的连接出现长时间的空闲</strong>。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处理打开状态。</li>
<li>要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。<strong>每当服务器收到客户的信息，就将计时器复位</strong>。通常设置为<strong>两小时</strong>。若服务器过了两小时还没有收到客户的信息，他就发送<strong>探测报文段</strong>。若发送了10个探测报文段（每一个像个75秒）还没有响应，就假定客户出了故障，因而就终止了该连接。</li>
<li>这种连接的断开当然不会使用四次握手，而是直接硬性的中断和客户端的TCP连接。</li>
</ul>
</li>
<li><p><strong>时间等待计时器：Timer_Wait Timer</strong>：对应 <code>TIME-WAIT</code> 阶段</p>
<ul>
<li>时间等待计时器是在四次握手的时候使用的。四次握手的简单过程是这样的：<ul>
<li>假设客户端准备中断连接，首先向服务器端发送一个 <code>FIN</code> 的请求关闭包 <code>FIN=final</code> ，然后由 <code>established</code> 过渡到 <code>FIN-WAIT1</code> 状态。</li>
<li>服务器收到 <code>FIN</code> 包以后会发送一个 <code>ACK</code> ，然后自己由 <code>Established</code> 进入 <code>CLOSE-WAIT</code> ，此时通信进入半双工状态，即留给服务器一个机会将剩余数据传递给客户端。</li>
<li>传递完后服务器发送一个 <code>FIN+ACK</code> 的包，表示我已经发送完数据可以断开连接了，就这便进入 <code>LAST_ACK</code> 阶段。</li>
<li>客户端收到以后，发送一个 <code>ACK</code> 表示收到并同意请求，接着由 <code>FIN-WAIT2</code> 进入 <code>TIME-WAIT</code> 阶段。服务器收到 <code>ACK</code> ，结束连接。此时（即客户端发送完ACK包之后），<strong>客户端还要等待2MSL（MSL=maxinum segment lifetime最长报文生存时间，2MSL就是两倍的MSL）才能真正的关闭连接。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><span id="nagle算法">Nagle算法</span></h4><p><strong>Small Packet Problem</strong></p>
<p>在使用一些协议通讯的时候，比如 <code>Telnet</code> ，会有一个字节字节的发送的情景，每次发送一个字节的有用数据，就会产生 <code>41</code> 个字节长的分组：<code>20</code> 个字节的 <code>IP Header</code> 和 <code>20</code> 个字节的 <code>TCP Header</code> ，这就导致了1个字节的有用信息要浪费掉 <code>40</code> 个字节的头部信息，这是一笔巨大的字节开销，而且这种 <code>Small packet</code> 在广域网上会增加拥塞的出现。</p>
<p>如果解决这种问题？<code>Nagle</code> 就提出了一种通过减少需要通过网络发送包的数量来提高 <code>TCP/IP</code> 传输的效率，这就是 <code>Nagle</code> 算法</p>
<hr>
<h3><span id="tcpip中的分组和分片">TCP/IP中的分组和分片</span></h3><h4><span id="分组交换">分组交换</span></h4><p>连接到通信电路的计算机将所有要发送的数据分成了多个数据包，按照一定的顺序排列后分别发送。有了分组交换，数据被细分后，所有的计算机就可以一齐收发数据，这样也提高了通信线路的利用率。在分组的过程中，已经在每个分组的首部写入了发送端和接收端的地址，因此即使同一条线路同时为多个用户提供服务，也可以明确区分每个分组数据发往的目的地。</p>
<p>网络传输中，每个节点会根据分组数据的地址信息，来判断该报文应该由哪个网卡发送出去，为此，各个地址会参考一个发出接口列表，在这一点上MAC寻址与IP寻址是一样的，只不过MAC寻址参考的表是<strong>地址转发表</strong>，而IP寻址中参考的是<strong>路由控制表</strong>。<strong>MAC地址转发表中所记录的是实际的MAC地址本身，而路由表中记录的IP地址是集中了之后的网络号。</strong></p>
<h4><span id="分片">分片</span></h4><p>我们最常见数据链路是以太网，它的 <strong>最大传输单元MTU</strong> 是 <code>1500</code> 字节。那么当 <code>IP</code> 数据包大小大于 <strong>MTU</strong> 时， <code>IP</code> 数据包就会被分片。<strong>经过分片之后的 <code>IP</code> 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。</strong></p>
<p>假设发送方发送一个 4000 字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3 个小数据报进行传输，再交由接收方重组成大数据报。</p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613471822566.png" alt="1613471822566"></p>
<p>在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，<strong>所以 TCP 引入了 MSS(最大报文段长度)， 也就是在</strong><br><strong>TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 MTU 的数据报文。</strong></p>
<hr>
<h3><span id="socket">Socket</span></h3><h4><span id="什么是socket">什么是socket</span></h4><p><img src="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><code>Socket</code> 是应用层与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，<code>Socket</code> 其实就是一个门面模式，它把复杂的 <code>TCP/IP</code> 协议族隐藏在 <code>Socket</code> 接口后面，对用户来说，一组简单的接口就是全部，让<code>Socket</code> 去组织数据，以符合指定的协议。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>先从服务器端说起。服务器端先初始化 <code>Socket</code> ，然后与端口绑定( <code>bind</code> )，对端口进行监听( <code>listen</code> )，调用 <code>accept</code> 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 <code>Socket</code> ，然后连接服务器( <code>connect</code> )，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<h5><span id="socket函数">socket函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<strong>socket()</strong>用于创建一个<strong>socket描述符（socket descriptor）</strong>，它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<ul>
<li><strong>domain</strong>：即<strong>协议域</strong>，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li><strong>type</strong>：<strong>指定socket类型</strong>。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li>
<li><strong>protocol</strong>：<strong>指定协议</strong>。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议等等。</li>
</ul>
<h5><span id="bind函数">bind函数</span></h5><p>正如上面所说 <code>bind()</code> 函数把一个地址族中的特定地址赋给 <code>socket</code> 。例如对应 <code>AF_INET</code> 、<code>AF_INET6</code> 就是把一个 <code>ipv4</code> 或 <code>ipv6</code> 地址和端口号组合赋给 <code>socket</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h5><span id="listenconnect函数">listen/connect函数</span></h5><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h5><span id="accept函数">accept函数</span></h5><p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4><span id="readwrite函数">read/write函数</span></h4><p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read()/write()</span><br><span class="line">recv()/send()</span><br><span class="line">readv()/writev()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="socket通信中tcp-udp数据包大小的确定">SOCKET通信中TCP、UDP数据包大小的确定</span></h4><p><code>UDP</code> 和 <code>TCP</code> 协议利用端口号实现多项应用同时发送和接收数据。数据通过源端口发送出去，通过目标端口接收。有的网络应用只能使用预留或注册的静态端口；而另外一些网络应用则可以使用未被注册的动态端口。因为 <code>UDP</code> 和 <code>TCP</code> 报头使用两个字节存放端口号，所以端口号的有效范围是从 <code>0</code> 到 <code>65535</code> 。动态端口的范围是从 <code>1024</code> 到 <code>65535</code> 。</p>
<h5><span id="mtu最大传输单元">MTU最大传输单元</span></h5><ul>
<li>由于以太网最大的数据帧是 <code>1518Bytes</code> ，刨去以太网帧的帧头（DMAC目的MAC地址<strong>6Bytes</strong>+SMAC源MAC地址<strong>6Bytes</strong>+Type域<strong>2bytes</strong>）<strong>14Bytes</strong>和<strong>帧尾CRC校验部分4Bytes</strong> 那么剩下承载上层协议的地方也就是Data域最大就只能有<strong>1500Bytes</strong>这个值我们就把它称之为<strong>MTU</strong>。</li>
<li>数据链路层规定了<strong>数据帧中数据字段的最大长度 MTU</strong> ，最常用的以太网规定 <strong>MTU = 1500</strong> 字节，若长度超过 <code>MTU</code> 值，就必须把数据报分片处理。</li>
<li>虽然尽可能长的 <code>IP</code> 数据报会使传输效率变高（首部长度占比小），但数据报短路由器转发速度也更快。</li>
</ul>
<p>因此：</p>
<p><strong>UDP</strong> 包的大小就应该是 <strong>1500 - IP头(20) - UDP头(8) = 1472(BYTES)</strong><br><strong>TCP</strong> 包的大小就应该是 <strong>1500 - IP头(20) - TCP头(20) = 1460 (BYTES)</strong></p>
<p>在用 <code>Socket</code> 编程时， <code>UDP</code>协议要求包小于 <code>64K</code> ，<code>TCP</code>没有限定。</p>
<p>不过鉴于Internet上的<strong>标准MTU</strong>值为<strong>576字节</strong>，所以建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在<strong>548字节 (576-8-20)</strong>以内。</p>
<hr>
<h4><span id="backlog是干嘛的">backlog是干嘛的</span></h4><p><a href="https://segmentfault.com/a/1190000019252960" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019252960</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="为什么会发生粘包黏包">为什么会发生粘包/黏包？</span></h3><h4><span id="tcp当中才会有粘包问题udp不存在粘包问题"><strong>TCP当中才会有粘包问题，UDP不存在粘包问题</strong></span></h4><p>首先粘包中的”包”指的是<strong>应用层的数据包</strong>，在TCP协议头中，没有像UDP一样的报文长度，只有一个序列号字段。</p>
<ul>
<li>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li>
<li><p>TCP 粘包/分包的原因：</p>
<ul>
<li><strong>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象</strong>。</li>
<li><strong>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</strong></li>
</ul>
</li>
<li><p>从应用层的角度来看，应用层交付给传输层的数据都是一连串的字节数据，应用程序看到这一连串的字节数据，并不知道是从哪个部分到哪个部分是一个完整的应用数据包。</p>
</li>
<li>从传输层的角度来看，TCP是一个报文过来的，按序号排好序的放在缓冲区中。</li>
</ul>
<h4><span id="如何避免粘包问题">如何避免粘包问题？</span></h4><p><strong>在应用层将包分开，明确两个包的边界</strong></p>
<ul>
<li>对于定常的包，保证每次都按固定大小读取即可；</li>
<li>对于变长的包，可以在报头的位置约定一个包总长度的字段，从而就知道了包的结束位置；</li>
<li>对于变长的包，还可以在包和包之间使用明确的分隔符（应用层协议是由程序员自己来确定的）</li>
</ul>
<hr>
<h3><span id="为什么会发生丢包">为什么会发生丢包？</span></h3><hr>
<h3><span id="访问toutiaocom打不开应该怎么排查错误">访问toutiao.com打不开，应该怎么排查错误？</span></h3><p>首先网站打不开之后我们排查到底是哪里出了问题，首先域名，域名假如ping不通说明域名解析有问题，域名能ping通但是网站访问不了就有可能是网站程序或者是服务器的问题。也可以根据网站的提醒，当显示404或者一些服务器错误的提醒，404代表的是网页不存在，有可能是网站代码出了问题这样我们集中排查网站程序的问题就行了。也有许多情况是我的电脑打不开，但是有的同伙电脑能打开，这个情况有两种情况，一种是域名dns问题，一种是网站服务器问题导致的个别地区访问不了网站的情况。</p>
<ul>
<li>远端原因：服务器网络中断，web服务程序停止/重启，等等。</li>
<li>本地原因：本机网络中断，浏览器故障，安全/流氓软件拦截等。</li>
<li>链路原因：ISP网络故障，路由器，dns服务故障。</li>
</ul>
<p>先确定一下自己的本地网络是不是有问题，看看打开baidu之类的能不能打开hh。</p>
<p>如果确定本地网络没有问题可以先ping一下域名或者是IP地址，如果返回ip地址和回复，说明本地网络和要访问的网站都没有问题，也就是派出了远端原因和本地原因。接下来就很有可能是链路的原因了，ISP网络故障，路由器，dns服务故障等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">一、网络设置的问题</span><br><span class="line"> </span><br><span class="line">这种原因比较多出现在需要手动指定IP、网关、DNS服务器联网方式下，及使用代理服务器上网的。仔细检查计算机的网络设置。 </span><br><span class="line"> </span><br><span class="line">二、DNS服务器的问题</span><br><span class="line"> </span><br><span class="line">当IE无法浏览网页时，可先尝试用IP地址来访问，如果可以访问，那么应该是DNS的问题，造成DNS的问题可能是连网时获取DNS出错或DNS服务器本身问题，这时你可以手动指定DNS服务（地址可以是你当地ISP提供的DNS服务器地址，也可以用其它地方可正常使用DNS服务器地址。）在网络的属性里进行，（控制面板—网络和拔号连接—本地连接—右键属性—TCP/IP协议—属性—使用下面的DNS服务器地址）。不同的ISP有不同的DNS地址。有时候则是路由器或网卡的问题，无法与ISP的DNS服务连接，这种情况的话，可把路由器关一会再开，或者重新设置路由器。 </span><br><span class="line"> </span><br><span class="line">还有一种可能，是本地DNS缓存出现了问题。为了提高网站访问速度，系统会自动将已经访问过并获取IP地址的网站存入本地的DNS缓存里，一旦再对这个网站进行访问，则不再通过DNS服务器而直接从本地DNS缓存取出该网站的IP地址进行访问。所以，如果本地DNS缓存出现了问题，会导致网站无法访问。可以在“运行”中执行ipconfig /flushdns来重建本地DNS缓存。 </span><br><span class="line"> </span><br><span class="line">三、IE浏览器本身的问题</span><br><span class="line"> </span><br><span class="line">当IE浏览器本身出现故障时，自然会影响到浏览了；或者IE被恶意修改破坏也会导致无法浏览网页。这时可以尝试用“黄山IE修复专家”来修复（建议到安全模式下修复），或者重新IE（如重装IE遇到无法重新的问题，可参考：附一解决无法重装IE） </span><br><span class="line"> </span><br><span class="line">四、网络防火墙的问题</span><br><span class="line"> </span><br><span class="line">如果网络防火墙设置不当，如安全等级过高、不小心把IE放进了阻止访问列表、错误的防火墙策略等，可尝试检查策略、降低防火墙安全等级或直接关掉试试是否恢复正常。 </span><br><span class="line"> </span><br><span class="line">五、网络协议和网卡驱动的问题</span><br><span class="line"> </span><br><span class="line">IE无法浏览，有可能是网络协议（特别是TCP/IP协议）或网卡驱动损坏导致，可尝试重新网卡驱动和网络协议。 </span><br><span class="line"> </span><br><span class="line">六、HOSTS文件的问题</span><br><span class="line"> </span><br><span class="line">HOSTS文件被修改，也会导致浏览的不正常，解决方法当然是清空HOSTS文件里的内容。 </span><br><span class="line"> </span><br><span class="line">七、系统文件的问题</span><br><span class="line"> </span><br><span class="line">当与IE有关的系统文件被更换或损坏时，会影响到IE正常的使用，这时可使用SFC命令修复一下，WIN98系统可在“运行”中执行SFC，然后执行扫描；WIN2000/XP/2003则在“运行”中执行sfc /scannow尝试修复。 </span><br><span class="line"> </span><br><span class="line">其中当只有IE无法浏览网页，而QQ可以上时，则往往由于winsock.dll、wsock32.dll或wsock.vxd（VXD只在WIN9X系统下存在）等文件损坏或丢失造成，Winsock是构成TCP/IP协议的重要组成部分，一般要重装TCP/IP协议。但xp开始集成TCP/IP协议，所以不能像98那样简单卸载后重装，可以使用 netsh 命令重置 TCP/IP协议，使其恢复到初次安装操作系统时的状态。具体操作如下： </span><br><span class="line"> </span><br><span class="line">点击“开始 运行”，在运行对话框中输入“CMD”命令，弹出命令提示符窗口，接着输入“netsh int ip reset c:\resetlog.txt”命令后会回车即可，其中“resetlog.txt”文件是用来记录命令执行结果的日志文件，该参数选项必须指定，这里指定的日志文件的完整路径是“c:\resetlog.txt”。执行此命令后的结果与删除并重新安装 TCP/IP 协议的效果相同。 </span><br><span class="line"> </span><br><span class="line">小提示：netsh命令是一个基于命令行的脚本编写工具，你可以使用此命令配置和监视Windows 系统，此外它还提供了交互式网络外壳程序接口，netsh命令的使用格式请参看帮助文件（在令提示符窗口中输入“netsh/?”即可）。</span><br><span class="line"> </span><br><span class="line">第二个解决方法是修复以上文件，WIN9X使用SFC重新提取以上文件，WIN2000/XP/2003使用sfc /scannow命令修复文件,当用sfc /scannow无法修复时，可试试网上发布的专门针对这个问题的修复工具WinSockFix，可以在网上搜索下载。</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="ip网络层">IP/网络层</span></h2><h3><span id="地址解析协议-arp">地址解析协议 ARP</span></h3><h5><span id="计算机网络是如何根据ip地址定位到一台主机的">计算机网络是如何根据IP地址定位到一台主机的</span></h5><p><img src="https://krahets.gitee.io/assets/img/1568551356084.394e4465.png" alt="1568551356084"></p>
<ul>
<li><strong>APR 协议作用：</strong> 已经知道一个机器的 <strong>IP 地址</strong>，需要找出对应的<strong>硬件地址</strong>。<ul>
<li><strong>RARP 协议</strong>：现在的 <code>DHCP</code> 协议包含逆地址解析协议功能，即从<strong>硬件地址</strong>找出其 <strong>IP 地址</strong>。</li>
</ul>
</li>
<li><strong>ARP 协议工作原理：</strong> 网络层使用 <code>IP</code> 地址，但实际网络链路上传送数据帧时，最终必须使用该网络的硬件地址( <code>MAC</code> )。<code>ARP</code> 解决方法是在<strong>主机 ARP 高速缓存</strong> 中存放一个从 <code>IP</code> 地址到硬件地址的映射表，并实时动态更新（新增或超时删除）。<ul>
<li>当主机 A 要向主机 B 发送 <code>IP</code> 数据报时，就在其 <code>ARP</code> 高速缓存中查看有无主机 B 的 <code>IP</code> 地址，如有就查找并<strong>写入 MAC 帧</strong>，并传输。</li>
<li>有可能查不到主机 B 的 <code>IP</code> 地址，可能主机 B 刚入网，可能主机 A 刚加电（高速缓存为空）。在这种情况下，主机 A 就自动运行 <code>ARP</code>，通过广播请求分组找出主机 B 的硬件地址。</li>
</ul>
</li>
<li><strong>ARP 协议工作流程：</strong><ol>
<li>主机 A 在<strong>本局域网</strong>上发送一个 <code>ARP</code> 请求分组，在本局域网上所有主机上运行的 <code>ARP</code> 进程都收到此请求分组。</li>
<li>主机 B 收下这个 <code>ARP</code> 请求，并向主机 A 发送响应分组（普通的单播，发送给主机 A ）。同时，把请求分组里 A 的 <code>IP</code> 地址到硬件地址的映射写入主机 B 的 <code>ARP</code> 高速缓存中。</li>
<li>主机 A 收到主机 B 的响应分组后，就在 <code>ARP</code> 高速缓存中写入主机 B 的 <code>IP</code> 地址到硬件地址的映射。</li>
</ol>
</li>
<li><strong>ARP生存时间：</strong> 超过生存时间（例如 10 ~ 20 分钟）的项目从高速缓存中删掉。这样如果 B 更换了设备， A 无法找到原主机 B ，但过了一段时间， A 的 <code>ARP</code> 高速缓存中已经删除了 B 原先硬件地址，于是 A 重新广播发送 <code>ARP</code> 请求分组，找到新的 B 硬件地址。</li>
</ul>
<hr>
<h3><span id="dhcp">DHCP</span></h3><p><strong>DHCP(Dynamic Host Configuration Protocol)</strong>在生活中很常见，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配IP 信息繁琐的过程。</p>
<ul>
<li>客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li>
<li>DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li>
<li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。</li>
<li>最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。</li>
</ul>
<p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且<strong>客户端能够在租用期内使用 DHCP 服务器分配的</strong><br><strong>IP 地址</strong>。<strong>可以发现，DHCP 交互中，全程都是使用 UDP 广播通信。</strong>那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</p>
<p>为了解决这一问题，就出现了 DHCP 中继代理。有了 DHCP 中继代理以后，对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</p>
<ul>
<li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以单播的形式发给 DHCP 服务器。</li>
<li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给DHCP 客户端 。</li>
</ul>
<hr>
<h3><span id="icmpigmp">ICMP/IGMP</span></h3><p><img src="https://krahets.gitee.io/assets/img/1568288257688.197541c0.png" alt="1568288257688"></p>
<h4><span id="网际控制报文协议-icmp">网际控制报文协议 <strong>ICMP</strong></span></h4><h4><span id="icmp-报文种类">ICMP 报文种类</span></h4><p>ICMP 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址</strong>、<strong>报告发送过程中 IP 包被废弃的原因</strong>和<strong>改善网络设置</strong>等。在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p>
<ul>
<li><p>ICMP 大致可以分为两大类：</p>
<ul>
<li>一类是用于诊断的查询消息，也就是<strong>查询报文类型</strong></li>
<li>另一类是通知出错原因的错误消息，也就是<strong>差错报文类型</strong></li>
</ul>
</li>
<li><p><strong>ICMP 差错报告报文和 ICMP 询问报文</strong></p>
<p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613473588045.png" alt="1613473588045"></p>
<p><img src="https://krahets.gitee.io/assets/img/1568635687315.e67e9b59.png" alt="1568635687315"></p>
</li>
<li><p><strong>ICMP应用：</strong></p>
<ul>
<li><strong>分组网间探测 PING (Packet Internet Groper)</strong>：使用了 <strong>ICMP</strong> 的回送请求和回送回答报文。</li>
</ul>
</li>
</ul>
<h5><span id="ping和telnet的区别">ping和telnet的区别</span></h5><ul>
<li><strong>ping用来检查网络是否通畅或者网络连接速度的命令</strong> </li>
<li><strong>telnet是用来探测指定ip是否开放指定端口</strong></li>
</ul>
<h4><span id="网际组管理协议-igmp">网际组管理协议 <strong>IGMP</strong></span></h4><hr>
<h3><span id="ip-数据报的格式">IP 数据报的格式</span></h3><p><img src="https://img-blog.csdn.net/20150730120353079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h5><span id="首部固定字段">首部固定字段</span></h5><ol>
<li><strong>版本：</strong> 占 4 位；指 IP 协议版本。通信双方使用的 IP 协议版本需一致。</li>
<li><strong>首部长度：</strong> 占 4 位；单位是 32 位字（4 字节）。</li>
<li><strong>区分服务：</strong> 占 8 位；只有在使用区分服务时才使用，一般情况不使用。</li>
<li><strong>总长度：</strong> 占 16 位；指首部和数据长度之和；单位为字节，因此数据报最大长度为 $2^{16}-1=65536$字节<ul>
<li>数据链路层规定了<strong>数据帧中数据字段的最大长度 MTU</strong> ，最常用的以太网规定 MTU = 1500 字节，若长度超过 MTU 值，就必须把数据报分片处理。</li>
<li>虽然尽可能长的 IP 数据报会使传输效率变高（首部长度占比小），但数据报短路由器转发速度也更快。</li>
</ul>
</li>
<li><strong>标识</strong>：占 16 位。 每产生一个 IP 数据报，计数器 +1。<ul>
<li>这个标识并不是序号（网络层不负责按序接收）；</li>
<li>在由于长度超过 MTU 而被分片时，标识字段值被复制到所有分片的标识字段，使各数据报片最后能正确地组装成原来的数据报。</li>
</ul>
</li>
<li><strong>标志</strong>：占 3 位，目前仅前 2 位有意义。<ul>
<li>最低位记为 MF (More Fragment) ，MF = 1 表示后面“还有分片”数据报，MF = 0 表示这是若干数据报片中的最后一个。</li>
<li>中间一位记为 DF (Don’t Fragment) ， DF = 1 表示不能分片，DF = 0 才允许分片。</li>
</ul>
</li>
<li><strong>片偏移：</strong> 占 13 位；表示数据报在分片后，某片在原分组中的相对位置；单位是 8 字节。<ul>
<li>每个分片的长度一定是 8 字节（64 位）的整数倍。</li>
</ul>
</li>
<li><strong>生存时间（TTL）</strong>：占 8 位；表示数据报在网络中的寿命。防止数据报在互联网中无限制兜圈子。<ul>
<li>最初设计 TTL 以秒为单位，消耗时间小于 1s 则将 TTL 减 1 。</li>
<li>目前路由器处理数据报时间一般远远小于 1s ，后来 TTL 字段功能改为<strong>“跳数限制”</strong>，路由器每次转发数据之前把 TTL 减 1 ，当 TTL = 0 就丢失这个数据报。</li>
<li>数据报能在互联网中经过路由器的最大数值是 $255=(2^8 - 1)$。若设置 TTL = 1 ，则表示此数据报只能在本局域网中传送。</li>
</ul>
</li>
<li><strong>协议：</strong> 占 8 位；表示此数据报中携带的数据使用何种协议，以便接收方主机 IP 层直到应将数据上交给哪个协议处理。</li>
<li><strong>首部校验和：</strong> 占 16 位；只检验数据报的首部，不包括数据部分（减少计算量）。</li>
<li><strong>源地址：</strong> 占 32 位；</li>
<li><strong>目的地址：</strong> 占 32 位。</li>
</ol>
<h5><span id="首部可变部分">首部可变部分</span></h5><ul>
<li>IP 数据报首部的可变部分就是一个<strong>选项字段</strong>，用来支持<strong>排错、测量、安全措施</strong>等。</li>
<li>长度 <strong>1 - 40</strong> 字节，取决于选择的项目。</li>
<li>可变部分是用来增加 IP 数据报的功能，实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 <strong>IPv6 就将 IP 数据报的首部长度做成固定的</strong>。</li>
</ul>
<hr>
<h2><span id="http">HTTP</span></h2><h3><span id="http状态码">HTTP状态码</span></h3><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p><strong>HTTP状态码列表:</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/" target="_blank" rel="noopener">客户端</a>应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
<hr>
<h3><span id="http字段">HTTP字段</span></h3><ul>
<li><p><strong>Host 字段：</strong></p>
<ul>
<li>客户端发送请求时，用来指定服务器的域名</li>
</ul>
</li>
<li><p><strong>Content-Length 字段：</strong></p>
<ul>
<li>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明<strong>本次回应的数据长度</strong>。</li>
</ul>
</li>
<li><p><strong>Connection 字段：</strong></p>
<ul>
<li><code>Connection</code> 字段最常用于客户端要求服务器使用 <code>TCP</code> 持久连接，以便其他请求复用。</li>
<li>HTTP/1.1版本的默认链接都是持久连接，但是为了兼容老版本的HTTP，需要指定Connection首部：<code>Connection: Keep-Alive</code></li>
</ul>
</li>
<li><p><strong>Content-Type 字段：</strong></p>
<ul>
<li><p>用于服务器回应时告知客户端本次的数据是什么格式的</p>
</li>
<li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端请求时，可以使用 <strong>Accept 字段</strong>声明自己可以接受哪些数据格式。</p>
</li>
</ul>
</li>
<li><p><strong>Content-Encoding 字段：</strong></p>
<ul>
<li><p>书名数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。</p>
</li>
<li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端在请求时，用<strong>Accept-Encoding 字段</strong>说明自己可以接受哪些压缩方法。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3><span id="https的通信过程">⭐HTTPS的通信过程</span></h3><p><code>HTTPS</code> 是一种通过计算机网络进行安全通信的传输协议。<code>HTTPS</code> 经由 <code>HTTP</code> 进行通信，但利用 <strong>SSL/TLS</strong> 来加密数据包。 <code>HTTPS</code> 的通信过程，充分利用了各种加密算法及其特性。<code>HTTPS</code> 只是在原有的协议接口替换成了<strong>SSL(Secure Socket Layer)</strong>和<strong>TLS(Transport Layer Security)</strong>协议</p>
<p><img src="https://img2018.cnblogs.com/blog/1627759/201906/1627759-20190615112708629-638195014.jpg" alt="img"></p>
<ol>
<li><p>客户端或者浏览器向服务器发送 <code>https</code> 请求</p>
</li>
<li><p>服务器将数字证书(公钥+数字签名)返回给客户端</p>
</li>
<li><p>浏览器接收到服务器公钥</p>
<p>浏览器收到公钥后会对公钥进行一系列的验证，如：颁发机构，过期时间等等。认证失败会有警告，成功的话，<strong>会生成一个随机的对阵密钥作为对称加密的密钥，用服务器返回的公钥对这个随机密钥进行加密</strong></p>
</li>
<li><p>加密后的随机密钥发送到服务器</p>
<p>服务器收到公钥加密后的随机密钥，会拿自己的私钥去解，解开之后得到随机密钥</p>
</li>
<li><p>客户端与服务器进行加密通信</p>
<p>客户端和服务器端信息数据通信，以这个随机密钥进行对称加密。</p>
</li>
</ol>
<h4><span id="非对称加密算法对称加密算法">非对称加密算法+对称加密算法</span></h4><p><code>HTTPS</code> 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>非对称加密算法，它有两个密钥：一个是公钥，可以明文传输的。一个是私钥，由发送放保存，其它人都不知道。非对称加密算法的加密和解密算法不同。通过公钥加密的信息只有用私钥才能解开。</p>
<p>主要是由于非对称加密算法运算量大，用非对称加密算法进行通信，其加解密过程特别慢。因此可以第一次用非对称加密算法传递对称加密算法的密钥，后续通信就用对称加密算法。除了第一次用非对称加密算法加解密密钥的时候比较慢外，其它时间都不会慢了。而且也可以保证对称加密算法密钥的安全性。这样可以充分利用非对称加密算法和对称加密算法的各自特点。</p>
<h4><span id="数字证书防止中间人攻击">数字证书—防止中间人攻击</span></h4><p>为了防止在通信过程中有中间人截获两端的非对称密钥，导致两端收到的公钥都是中间人的，可以获取两端的信息然后中转。找个可靠的人做公证人，两端各自把公钥交给他。由他颁布一个证书，证书包含公钥以及两端的身份信息，来证明两端各自的身份。但是这个证书也可以在传递过程中被篡改。</p>
<h4><span id="数字摘要算法">数字摘要算法</span></h4><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613463990017.png" alt="1613463990017"></p>
<p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p>
<p>为了解决数字证书中中间人攻击的问题，可以让公证人用<strong>数字摘要算法</strong>，把<strong>公钥和身份信息</strong>生成一个摘要。同时用非对称加密算法把对摘要进行加密，生成数字签名。然后把【公钥和身份信息+数字签名】合并，形成数字证书。在获得数字证书的时候，就可以用公钥进行解密生成摘要信息，再用数字摘要算法对公钥和身份信息生成摘要信息，两者比对，如果能匹配，就说明没有被篡改 。</p>
<p>数字证书通常来说是由受信任的数字证书颁发机构<strong>CA</strong>，在验证服务器身份后颁发。</p>
<h4><span id="证书内置">证书内置</span></h4><p>为了防止公证人公钥传输过程也会出现中间人攻击问题，可以把公证人公钥预先加载在操作系统中。微软等公司会根据一些权威安全机构的评估选取一些信誉很好并且通过一定的安全认证的证书发布机构，把这些证书发布机构的证书默认安装在操作系统中，并且设置为操作系统信任的数字证书。</p>
<hr>
<h3><span id="getpost-区别">get/post 区别</span></h3><ul>
<li><code>GET</code> 用于信息获取，是<strong>安全</strong>和<strong>幂等</strong>的，安全代表其不会增删改服务器上的内容，幂等代表多次相同操作返回相同；</li>
<li><code>POST</code> 请求可能修改服务器上资源；</li>
<li><code>GET</code> 请求数据附在 <code>URL</code> 后面，而 <code>POST</code> 在 <code>HTTP</code> 包体内；</li>
<li><code>POST</code> 安全性比 <code>GET</code> 高。</li>
</ul>
<hr>
<h3><span id="httphttps-09-10-11-20-30的特点和区别">http/https 0.9、1.0、1.1、2.0、3.0的特点和区别</span></h3><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613464426114.png" alt="1613464426114"></p>
<h4><span id="http09">Http0.9</span></h4><ul>
<li><strong>请求方法支持有限</strong><br>只支持 <code>GET</code> 请求方式，不支持其他请求方式，因此客户端向服务端传输信息的量非常有限，也就是现在常用的 <code>Post</code> 请求无法使用</li>
<li><strong>不支持请求头header</strong><br>不能在请求中指定版本号，服务端只具有返回 <code>HTML</code> 字符串的能力</li>
<li><strong>响应即关闭</strong><br>服务端相响应之后，立即关闭 <code>TCP</code> 连接</li>
</ul>
<hr>
<h4><span id="http10">Http1.0</span></h4><p>1.0版本主要是对0.9版本的强化，效果也比较明显，主要特性和缺点包括：</p>
<ul>
<li><strong>丰富请求方法</strong><br>请求方式新增了 <code>POST</code> ，<code>DELETE</code> ，<code>PUT</code> ，<code>HEADER</code> 等方式，提高了客户端向服务端发送信息的量级</li>
<li><strong>增加请求头和响应头</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，可以在通信中指定了 <code>HTTP</code> 协议版本号，以及其他 <code>header</code> 信息，使得C/S交互更加灵活方便</li>
<li><strong>丰富数据传输内容</strong><br>扩充了传输内容格式包括：<strong>图片、音视频资源、二进制</strong>等都可以进行传输，相比0.9的只能传输 <code>html</code> 内容让<code>http</code> 的应用场景更多。</li>
</ul>
<p><strong>缺点如下：</strong></p>
<ul>
<li><strong>链接复用性差</strong><br>1.0版本中<strong>每个TCP连接只能发送一个请求</strong>，<strong>数据发送完毕连接就关闭</strong>，如果还要请求其他资源，就必须重新建立连接。TCP为了保证正确性和可靠性需要客户端和服务器三次握手和四次挥手，因此建立连接成本很高，基于拥塞控制开始时发送速率较慢，所以1.0版本的<strong>性能并不理想</strong>。</li>
<li><strong>无状态无连接的弊端</strong><br>1.0版本是<strong>无状态且无连接</strong>的，换句话说就是服务器不跟踪不记录请求过的状态，客户端<strong>每次请求都需要建立tcp连接不能复用</strong>，并且1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞后面的请求就会被阻塞。 <strong>丢包和乱序问题</strong>和高成本的链接过程让复用和<strong>队头阻塞</strong>产生很多问题，所以<strong>无连接无状态</strong>是1.0版本的一个<strong>弱肋</strong>。</li>
</ul>
<hr>
<h4><span id="http11">Http1.1</span></h4><p>1.1版本在1.0版本发布后大约1年就推出了，是<strong>对1.0版本的优化和完善</strong>，1.1版本的主要特点包括：</p>
<ul>
<li><strong>增加长连接</strong><br>新增 <code>Connection</code> 字段，可以设置 <code>keep-alive</code> 值保持连接不断开，即 <code>TCP</code> 连接默认不关闭，可以被多个请求<strong>复用</strong>，这也是1.1版本很重要的优化，在请求首部字段中提出 <code>keepalive</code> 之后，只要任意一段没有明确提出断开连接，tcp就一直会保持连接状态。但是在S端服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着，仍然存在<strong>队头阻塞</strong>问题。</li>
<li><strong>管道化</strong><br>在长连接的基础上，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回，即在<strong>同一个TCP连接中，客户端可以同时发送多个请求</strong>，进一步改进了HTTP协议的传输效率。</li>
<li><strong>更多的请求方法</strong><br>增加了 <code>PUT</code>、 <code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code> 等请求方式。</li>
<li><strong>host字段</strong><br><code>Host</code> 字段用来指定服务器的域名，这样就可以将多种请求发往同一台服务器上的不同网站，提高了机器的复用，这个也是重要的优化</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>仍然存在着<strong>队首阻塞</strong>的问题。也就是虽然请求可以同时发送了，但是要是前面的回应特别慢，后面就会有许多请求排队等着，仍然存在队头阻塞问题。</li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端开始，服务器只能被动响应</li>
<li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
</ul>
<hr>
<h4><span id="http20基于https">Http2.0(基于HTTPS)</span></h4><p><strong>HTTP2.0多路复用+TLS安全加密+TCP拥塞控制</strong></p>
<p>2.0版本是个里程碑式的版本，相比1.x版本有了非常多的优化去适应当前的网络场景，其中几个重要功能点包括：</p>
<ul>
<li><p><strong>二进制格式(非明文报文)</strong><br><code>1.x</code> 是文本协议，然而2.0是<strong>以二进制帧为基本单位</strong>，可以说是一个二进制协议，将所有传输的信息分割为<strong>头信息帧和数据帧</strong>，并采用二进制格式的编码，一帧中包含数据和标识符，使得网络传输变得高效而灵活。</p>
<ul>
<li>二进制分帧层<strong>binary framing layer</strong>在不修改请求方法和语义的基础上，重新设计了<strong>编码机制</strong>。二进制编码机制使得通信可以在<strong>单个TCP连接</strong>上进行，该连接在整个对话期间一直处于活跃状态。<ul>
<li><strong>链接Link</strong><br>就是指一条C/S之间的TCP链接，这是个基础的链路数据的高速公路</li>
<li><strong>数据流Stream</strong><br>已建立的TCP连接内的双向字节流，TCP链接中可以承载一条或多条消息</li>
<li><strong>消息Message</strong><br>消息属于一个数据流，消息就是逻辑请求或响应消息对应的完整的一系列帧，也就是帧组成了消息</li>
<li><strong>帧Frame</strong><br>帧是通信的最小单位，每个帧都包含帧头和消息体，标识出当前帧所属的数据流</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>多路复用</strong><br>这是一个非常重要的改进，1.x中建立多个连接的消耗以及效率都存在问题，2.0版本的多路复用<strong>多个请求共用一个连接，多个请求可以同时在一个TCP连接上并发，主要借助于二进制帧中的标识进行区分实现链路的复用。</strong></p>
<ul>
<li><p>客户端和服务器将交互数据分解为<strong>相互独立的帧</strong>，互不影响地<strong>交错传输</strong>，最后再在对端根据<strong>帧头中的流标识符</strong>把它们<strong>重新组装</strong>起来，从而实现了TCP链接的多路复用。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5YING7tophKDYrYreRzSvGN0BlJ6LibtW2mK4QTTckvpm3408gax7XUg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
</li>
</ul>
</li>
<li><p><strong>头部压缩</strong><br>2.0版本使用使用<strong>HPACK算法</strong>对头部 <code>header</code> 数据进行压缩，从而减少请求的大小提高效率，这个非常好理解，之前每次发送都要带相同的 <code>header</code> ，显得很冗余，<code>2.0</code> 版本对头部信息进行增量更新有效减少了头部数据的传输。</p>
<ul>
<li><p>2.0版本中HPACK算法在C/S中使用<strong>首部表</strong>来存储之前发送的键值对，对于相同的数据通信期间几乎不会改变的通用键值对只需发送一次即可。</p>
</li>
<li><p>极端情况如果请求头每次没有变化，那么传输中则不包含首部，也就是首部开销就是<strong>零字节</strong>。如果首部键值对发生变化了，也<strong>只需要发送变化的数据</strong>，并且将<strong>新增或修改的首部帧会被追加到首部表</strong>，首部表在链接存活期始终存在, 并且由客户端和服务器<strong>共同更新和维护</strong>。</p>
</li>
<li><p>简单说就是客户端和服务端共同维护了一个<strong>key-value</strong>的结构，发生变化时则更新传输，否则就不传输，这样相当于<strong>首次全量传输之后增量更新传输</strong>即可，这个思想在日常开发中也非常普遍，不用想的太复杂。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qY7jqh1paIzGeMDunokbQY5hTnk3S5XJBVElZdWeB6U8lrMlyY9iaPZFj7WKE1OeSw3E3TNUj9Nz3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
</li>
</ul>
</li>
<li><p><strong>服务端推送</strong><br>这个功能有点意思，之前 <code>1.x</code> 版本服务端都是收到请求后被动执行，在2.0版本允许服务器主动向客户端发送资源，这样在客户端可以起到加速的作用。</p>
<ul>
<li>在实际的C/S交互中这种<strong>主动推送额外资源</strong>的方法很有效，因为几乎每个网络应用都会包含多种资源，客户端需要全部逐个获取它们，此时如果让服务器提前推送这些资源，从而可以<strong>有效减少额外的延迟时**</strong>间**，因为服务器可以知道客户端下一步要请求什么资源。</li>
</ul>
</li>
<li><p><strong>HTTP2.0存在的不足(主要是TCP的问题)</strong></p>
<ul>
<li>建立连接时间长</li>
<li>队头阻塞问题(HTTP2.0协议的<strong>多路复用机制</strong>解决了HTTP层的队头阻塞问题，但是在<strong>TCP层仍然存在队头阻塞问题</strong>。TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，<strong>如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用</strong>。)</li>
<li>移动互联网领域表现不佳(弱网环境)</li>
</ul>
</li>
</ul>
<p>HTTP/2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p>
<ul>
<li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住<br>了</li>
<li>HTTP/2 多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul>
<hr>
<h4><span id="http30">Http3.0</span></h4><p>HTTP3.0又称为<strong>HTTP Over QUIC</strong>，其<strong>弃用TCP协议</strong>，改为使用<strong>基于UDP协议</strong>的QUIC协议来实现。QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。</p>
<ul>
<li><strong>QUIC</strong>协议(<strong>Quick UDP Internet Connections</strong>)</li>
</ul>
<blockquote>
<p>QUIC提高了当前正在使用TCP的面向连接的Web应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。</p>
</blockquote>
<blockquote>
<p>QUIC的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
</blockquote>
<ul>
<li><strong>基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商</strong>，完成之后才可以真正传输业务数据。但是QUIC则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</li>
<li><strong>使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。首次连接之后传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互。</strong></li>
<li>QUIC协议基于UDP实现摒弃了五元组(SIP+SPort+DIP+DPort+协议号)的概念，使用64位的随机数作为连接的ID，并使用该ID表示连接。基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</li>
<li>QUIC协议的核心思想是将TCP协议在内核实现的诸如可靠传输、流量控制、拥塞控制等功能转移到用户态来实现，同时在加密传输方向的尝试也推动了TLS1.3的发展。</li>
</ul>
<hr>
<h3><span id="quic和bbr">QUIC和BBR</span></h3><hr>
<h3><span id="http的无状态性">HTTP的无状态性</span></h3><blockquote>
<p>HTTP两大缺点：</p>
<ul>
<li>无状态-&gt;用cookie/session解决</li>
<li>明文传输、不安全-&gt;用SSL/TLS层解决</li>
</ul>
</blockquote>
<p><code>http</code> 是一种无状态协议，即<strong>不会保存请求和响应之间的通信状态</strong>。好处是<strong>可以加快处理速度，确保协议的可伸缩性</strong>。<code>http</code> 最初的设计是无状态的(stateless)，但是无状态的 <code>http</code> 无法满足互联网日益发展的需求，于是业界扩展了 <code>http</code> 协议，增加了有状态(<strong>stateful</strong>)协议头，使之变成一个有状态协议。</p>
<p>两种用于<strong>保持HTTP连接状态</strong>的技术就应运而生了，一个是<strong>Cookie</strong>，而另一个则是<strong>Session</strong>。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</p>
<h4><span id="cookie">Cookie</span></h4><p>由于HTTP是一种无状态的协议，服务器<strong>单纯从网络连接上</strong>无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p>Cookie实际上是<strong>一小段的文本信息</strong>。客户端请求服务器，如果服务器需要记录该用户状态，就使用 <code>response</code> 向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，<strong>浏览器把请求的网址连同该Cookie一同提交给服务器</strong>。<strong>服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</strong></p>
<p> <em>Cookie具有不可跨域名性</em></p>
<p> 很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p>
<p>答案是否定的。Cookie具有<strong>不可跨域名性</strong>。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p>
<p><strong>Cookie在客户端是由浏览器来管理的</strong>。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。</p>
<h4><span id="session">Session</span></h4><p>由于网页是一种无状态的连接程序，因此无法得知用户的浏览状态。在网上购物的时，把很多商品加入了购物车，而在结账时网站却不知道你购物车有哪些物品。为了解决这个问题，服务器端就为特定用户创建了特定的<code>session</code> ，用于标示并跟踪这个用户，这样才知道购物车里有哪些商品。</p>
<ul>
<li><code>Session</code> 是另一种<strong>记录客户状态的机制</strong>，不同的是 <strong><code>Cookie</code> 保存在客户端浏览器中，而 <code>Session</code> 保存在服务器上。</strong></li>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 <code>Session</code> 。客户端浏览器再次访问时只需要从该 <code>Session</code> 中查找该客户的状态就可以了。</li>
<li>如果说 <code>Cookie</code> 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 <code>Session</code> 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</li>
<li><code>Session</code> 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</li>
</ul>
<h4><span id="session和cookie的关系">Session和Cookie的关系</span></h4><ul>
<li><ul>
<li><code>cookie</code> 是一个实际存在的、具体的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段。</li>
<li><code>session</code> 是一个抽象概念、开发者为了实现中断和继续等操作，将 <code>client</code> 和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念。</li>
<li>即 <code>session</code> 描述的是一种通讯会话机制，而 <code>cookie</code> 只是目前实现这种机制的主流方案里面的一个参与者，它一般是用于保存<strong>session ID</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3><span id="http请求种类">HTTP请求种类</span></h3><ol>
<li><strong>get：</strong>获取资源(多媒体，程序执行结果)</li>
<li><strong>post：</strong>传输实体主体，相比于 <code>get</code> 传输，<code>post</code> 请求的数据会放置在内容实体中而不是 <code>uri(Universal Resource Identifier)</code> 之后，安全性大大增强</li>
<li><strong>put：</strong>传输文件，由于 <code>http1.1</code> 本身不自带验证机制，所以安全性欠佳。一般 <code>web</code> 不使用此方法</li>
<li><strong>head：</strong>获得报文首部，与 <code>get</code> 一样，只是不获取报文主体，用来验证 <code>uri</code> 的有效性</li>
<li><strong>delete：</strong>删除文件 类似 <code>put</code> </li>
<li><strong>options：</strong>询问支持的方法</li>
<li><strong>trace：</strong>追踪路径，让 <code>web</code> 服务器端将之前的请求通信环回给客户端，用来确认连接过程中，代理中转的加工/篡改。</li>
<li><strong>connect：</strong>要求用隧道协议连接代理，主要使用 <code>ssl</code> 和 <code>tsl</code> 把通信内容加密后经网络隧道传输</li>
</ol>
<hr>
<h3><span id="http报文结构和内容">HTTP报文结构和内容</span></h3><p><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190724173147088-630413355.png" alt="img"></p>
<h4><span id="请求报文">请求报文</span></h4><p><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190724173242717-440362909.png" alt="img"></p>
<h5><span id="请求行">请求行</span></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /user HTTP/1.1      //请求行</span><br></pre></td></tr></table></figure>
<p><strong>请求行</strong>由三部分组成：<strong>请求方法</strong>，<strong>请求URL</strong>（不包括域名），<strong>HTTP协议版本</strong></p>
<p>请求方法比较多：<strong>GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</strong></p>
<p>最常用的是GET和POST。</p>
<h5><span id="请求头部">请求头部</span></h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span>: www.user.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">User-agent</span>: Mozilla/5.0.      //以上是首部行</span><br></pre></td></tr></table></figure>
<p>请求头部由关键字/值对组成，每行一对</p>
<ol>
<li><strong>User-Agent</strong> : 产生请求的浏览器类型</li>
<li><strong>Accept</strong> : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型</li>
<li><strong>Content-Type</strong>：发送端发送的实体数据的数据类型。<br>比如，Content-Type：text/html（application/json）表示发送的是html类型。</li>
<li><strong>Host</strong> : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</li>
<li>…</li>
</ol>
<h5><span id="空行">(空行)</span></h5><h5><span id="请求数据">请求数据</span></h5><ul>
<li><code>GET</code> 没有请求数据，<code>POST</code> 有。</li>
<li>与请求数据相关的最常使用的请求头是 <code>Content-Type</code> 和 <code>Content-Length</code> 。</li>
</ul>
<h4><span id="响应报文">响应报文</span></h4><h5><span id="状态行">状态行</span></h5><p>状态行也由三部分组成：<strong>服务器HTTP协议版本</strong>，<strong>响应状态码</strong>，<strong>状态码的文本描述</strong></p>
<ul>
<li>格式：HTTP-Version Status-Code Reason-Phrase CRLF</li>
<li>比如：HTTP/1.1 200 OK</li>
</ul>
<h5><span id="响应头部">响应头部</span></h5><h5><span id="空行">(空行)</span></h5><h5><span id="响应体">响应体</span></h5><hr>
<h3><span id="从浏览器输入url到出现页面经过了哪些阶段">从浏览器输入URL到出现页面经过了哪些阶段</span></h3><h4><span id="输入网址"><strong>输入网址</strong>：</span></h4><p>URL的形式： <code>schema://host:port/path?query#fragment</code></p>
<p>　　<code>-schema</code> : 协议，例如 <code>http</code> , <code>https</code> ,  <code>ftp</code> 等</p>
<p>　　<code>-host</code> : 域名或者 <code>ip</code> 地址</p>
<p>　　<code>-port</code> ： 端口，<code>http</code> 默认端口 <code>80</code> ，可以省略</p>
<p>　　<code>-path</code> ： 路径，例如 <code>/abc</code>   <code>/a/b/c</code> </p>
<p>　　<code>-query</code> : 查询参数，例如 <code>token=sdfs2223fds2&amp;name=sdffaf</code></p>
<p>　　<code>-fragment</code> : 锚点（哈希 <code>Hash</code> ），用于定位页面的某个位置。</p>
<p>符合规则的URL</p>
<p>　　<a href="http://www.baidu.com/java/web?flag=1#function" target="_blank" rel="noopener">http://www.baidu.com/java/web?flag=1#function</a></p>
<h4><span id="缓存解析"><strong>缓存解析</strong></span></h4><p>浏览器获取了这个 <code>url</code> ，它先去缓存当中看看有没有，依次从<strong>浏览器缓存</strong>-&gt;<strong>系统缓存</strong>-&gt;<strong>路由器缓存</strong>当中查看，如果有从缓存当中显示页面，这样是不需要发送 <code>http</code> 请求的。如果没有那就进行步骤3。<br>缓存就是把之前访问的web资源，比如一些js，css，图片什么的保存在本机的内存或者磁盘当中。</p>
<h4><span id="域名解析dns"><strong>域名解析(DNS)</strong></span></h4><p><img src="C:/Users/12105/AppData/Roaming/Typora/typora-user-images/1613472309683.png" alt="1613472309683"></p>
<p>当缓存中没有这个 <code>url</code> 的时候，就需要发送 <code>http</code> 请求了，那么在发送 <code>http</code> 请求之前，需要先进行<strong>DNS解析</strong>将域名解析成 <code>ip</code> 地址。<strong>DNS解析</strong>存在着多级缓存：</p>
<ul>
<li>浏览器的 <code>DNS</code> 缓存</li>
<li>系统的 <code>DNS</code> 缓存</li>
<li>路由器的 <code>DNS</code> 缓存</li>
<li>网络运营商的 <code>DNS</code> 缓存（中国移动，中国电信）</li>
<li>上述都没有找到，则会采取<strong>递归+迭代查询</strong>的方式<ul>
<li>主机先向<strong>本地域名(DNS)服务器</strong>进行递归查询</li>
<li><strong>本地域名服务器</strong>采用迭代查询，向一个<strong>根域名服务器</strong>进行查询</li>
<li><strong>根域名服务器</strong>告诉<strong>本地域名服务器</strong>，下一次应该查询的<strong>顶级域名服务器(.cn)</strong>的 <code>IP</code> 地址</li>
<li><strong>本地域名服务器</strong>向<strong>顶级域名服务器</strong>进行查询</li>
<li><strong>顶级域名服务器</strong>告诉<strong>本地域名服务器</strong>，下一步查询<strong>权威服务器(sjtu.edu.cn)</strong>的 <code>IP</code> 地址</li>
<li><strong>本地域名服务器</strong>向<strong>权威服务器</strong>进行查询</li>
<li><strong>权威服务器</strong>告诉<strong>本地域名服务器</strong>所查询的主机的 <code>IP</code> 地址</li>
<li><strong>本地域名服务器</strong>最后把查询结果告诉主机</li>
</ul>
</li>
<li><strong>递归查询</strong>：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以 <code>DNS</code> 客户机的身份向其它域名服务器查询，直到得到最终的 <code>IP</code> 地址告诉本机</li>
<li><strong>迭代查询</strong>：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</li>
</ul>
<p><strong>DNS优化</strong></p>
<ul>
<li><strong>DNS缓存</strong><br>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li>
<li><strong>DNS负载均衡</strong><br>DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，</li>
</ul>
<h4><span id="tcp链接三次握手"><strong>tcp链接，三次握手</strong></span></h4><p>在域名解析之后，浏览器向服务器发起了 <code>http</code> 请求，首先要经过<code>tcp</code> 连接，三次握手建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接。</p>
<p>（1）客户端向服务器发送连接请求报文；<br>（2）服务器端接受客户端发送的连接请求后后回复ACK报文，并为这次连接分配资源。<br>（3）客户端接收到ACK报文后也向服务器端再发送ACK报文，并分配资源。</p>
<p>这样TCP连接就建立了。</p>
<h4><span id="发送http请求">发送HTTP请求</span></h4><p>在此之后，浏览器开始向服务器发送http请求，请求数据包。请求信息包含一个<strong>请求头部</strong>和一个<strong>请求体</strong>。</p>
<h4><span id="服务器收到请求"><strong>服务器收到请求</strong></span></h4><p>服务器收到浏览器发送的请求信息，返回一个<strong>响应头</strong>和一个<strong>响应体</strong>。</p>
<h4><span id="浏览器页面渲染"><strong>浏览器页面渲染</strong></span></h4><ul>
<li>处理HTML标记并构建DOM树；</li>
<li>处理CSS标记并构建CSSOM树；</li>
<li>将DOM和CSSOM合并为一颗渲染树，通常为了更好的用户体验，渲染会与解析同时进行，将已经解析好的树渲染出来。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息(重排)</li>
<li>将各个结点绘制到屏幕上(重绘)</li>
<li>如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。</li>
</ul>
<h4><span id="断开连接四次挥手"><strong>断开连接，四次挥手</strong></span></h4><hr>
<h3><span id="http如何实现缓存怎样告诉浏览器这个可以被缓存以及缓存时间">HTTP如何实现缓存，怎样告诉浏览器这个可以被缓存以及缓存时间</span></h3><h2><span id="网络io">网络IO</span></h2><h3><span id="五种io模型">五种IO模型</span></h3><p><strong>阻塞IO(BIO)、非阻塞IO(NIO)、IO多路复用、信号驱动IO以及异步IO(AIO)</strong></p>
<p>首先一个 <code>IO</code> 操作其实分成了两个步骤：</p>
<ol>
<li><strong>等待数据：</strong>用户进程向内核发起 <code>IO</code> 请求，等待内核数据准备</li>
<li><strong>数据拷贝：</strong>实际的 <code>IO</code> 操作,将数据从内核拷贝到进程缓存区中 </li>
</ol>
<p>阻塞IO和非阻塞IO的区别在于第一步，当这次<strong>CPU COPY</strong>不能立即成功时，采取怎样的策略。阻塞IO就是一直等，比如等缓冲区非空、缓冲区非满等等状态达成。而非阻塞IO就是不等了，这次不行就下次再来。</p>
<p>同步IO和异步IO的区别就在于第二个步骤是否阻塞。如果实际的IO读写阻塞请求进程，那么就是同步IO，因此后面可以看到<strong>阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO</strong>；如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。</p>
<p>访问数据的方式：同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。</p>
<p>而非阻塞IO就是不等了，这次不行就下次再来。</p>
<p><img src="https://img-blog.csdn.net/20161028200140849" alt="img"></p>
<hr>
<h4><span id="阻塞iobio">阻塞IO(BIO)</span></h4><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p>
<p><img src="https://img-blog.csdn.net/20161028200138896" alt="img"></p>
<p>特点：</p>
<ol>
<li><strong>进程阻塞挂起不消耗CPU资源，及时响应每个操作</strong>；</li>
<li>实现难度低、开发应用较容易；</li>
<li>适用并发量小的网络应用开发；</li>
<li><strong>不适用并发量大的应用</strong>：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</li>
</ol>
<hr>
<h4><span id="非阻塞ionio">非阻塞IO(NIO)</span></h4><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p>
<p><img src="https://img-blog.csdn.net/20161028200139219" alt="img"></p>
<p>典型应用：<strong>socket</strong>是非阻塞的方式（设置为NONBLOCK）</p>
<p><strong>阻塞IO模型是一个阻塞IO调用，而非阻塞IO模型是多个非阻塞IO调用+一个阻塞IO调用，因为多个IO检查会立即返回错误，不会阻塞进程。</strong></p>
<p>特点：</p>
<ol>
<li><strong>进程轮询（重复）调用，消耗CPU的资源</strong>；</li>
<li>实现难度低、开发应用相对阻塞IO模式较难；</li>
<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>
</ol>
<hr>
<h4><span id="io多路复用">IO多路复用</span></h4><p>多个的进程的IO可以注册到一个复用器(<code>select</code>)上，然后用一个进程调用该 <code>select</code> ， <code>select</code> 会监听所有注册进来的IO；如果 <code>select</code> 监听的IO在内核缓冲区都没有可读数据，<code>select</code> 调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，<code>select</code> 调用就会返回；而后 <code>select</code> 调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。可以看到，<strong>多个进程注册IO后，只有另一个select调用进程被阻塞。</strong></p>
<p><img src="https://img-blog.csdn.net/20161028200139703" alt="img"></p>
<p><strong>典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;</strong></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>专一进程解决多个进程IO的阻塞问题，性能好</strong>；<strong>Reactor模式;</strong></li>
<li>实现、开发应用难度较大；</li>
<li><strong>适用高并发服务应用开发：一个进程（线程）响应多个请求</strong>；</li>
</ol>
<hr>
<h4><span id="信号驱动的io模型sigio">信号驱动的IO模型(SIGIO)</span></h4><p>当进程发起一个IO操作，会向内核注册一个<strong>信号处理函数</strong>，然后进程<strong>返回不阻塞</strong>；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p>
<p><img src="https://img-blog.csdn.net/20161028200140021" alt="img"></p>
<p><strong>特点：回调机制，</strong>实现、开发应用难度大；</p>
<hr>
<h4><span id="异步io模型aio非阻塞">异步IO模型(AIO)(非阻塞)</span></h4><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。<strong>如果IO操作成功则进程直接获取到数据</strong>。</p>
<p><img src="https://img-blog.csdn.net/20161028200140375" alt="img"></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>不阻塞，数据一步到位</strong>；<strong>Proactor模式</strong>；</li>
<li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>
<li>实现、开发应用难度大；</li>
<li>非常适合高性能高并发应用；</li>
</ol>
<hr>
<h3><span id="两种io事件处理模式">两种IO事件处理模式</span></h3><h4><span id="reactor模式同步的">Reactor模式(同步的)</span></h4><p>读取操作：</p>
<ol>
<li>应用程序注册读就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件的发生</li>
<li>当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器</li>
<li>事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190915131156673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>用<strong>Reactor</strong>模式的一个实现方案是：</p>
<ol>
<li>在<strong>Reactor</strong>中注册好感兴趣的事件(IO事件 信号 定时器)</li>
<li>用一个主线程(IO处理单元)负责监听文件描述符上的是否有事件发生除此之外它不做别的实质性的工作 ,采用<strong>io复用</strong>的形式 比如用select epoll  poll这些.</li>
<li>当发生了对应事件  主线程就通知工作进程 (通过请求队列)</li>
<li>在工作线程(逻辑单元)中读写数据  接受新的连接 处理客户请求等等 </li>
</ol>
<hr>
<h4><span id="proactor模式-异步">Proactor模式 (异步)</span></h4><p><img src="https://img-blog.csdnimg.cn/20190915142010343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZqaGdoamdoag==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的：</p>
<ul>
<li><strong>Reactor模式</strong>中需要应用程序自己读取或者写入数据，真正执行IO操作的(也就是从内核区读取io数据到缓存区的这一步)是事件处理器自身，也就是说在io操作的第二阶段应用程序是阻塞的，所以我们说<strong>Reactor模式是同步的</strong> </li>
<li><strong>Proactor模式</strong>中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备。</li>
</ul>
<hr>
<h3><span id="io多路复用selectpollepoll同步阻塞">⭐IO多路复用：select/poll/epoll(同步/阻塞)</span></h3><p><a href="https://blog.csdn.net/liushengxi_root/article/details/88654393" target="_blank" rel="noopener">https://blog.csdn.net/liushengxi_root/article/details/88654393</a></p>
<p>在计算机领域常说的 <code>I/O</code> 包括磁盘 <code>I/O</code> 和网络 <code>I/O</code> ，我们所说的 <code>I/O</code> 复用主要是指网络 <code>I/O</code> ，在 <code>Linux</code> 中一切皆文件，因此网络 <code>I/O</code> 也经常用文件描述符 <code>FD</code> 来表示。</p>
<p>所谓 <code>I/O</code> 多路复用指的是这样一个过程：</p>
<ol>
<li>我们拿到了一堆文件描述符 <code>fd</code> (不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)</li>
<li>通过调用<strong>某个函数</strong>告诉内核：“<strong>这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回</strong>”</li>
<li>当调用的这个函数返回后我们就能知道哪些文件描述符可以进行 <code>I/O</code> 操作了。</li>
</ol>
<p>也就是说<strong>通过I/O多路复用我们可以同时处理多路I/O</strong>，协调多个可释放资源的 <code>FD</code> <strong>交替共享任务处理线程</strong>完成<strong>通信任务</strong>，实现多个 <code>FD</code> 对应<strong>1</strong>个任务处理线程。。</p>
<p><code>select</code> ， <code>poll</code> ，<code>epoll</code> 都是 <code>IO</code> 多路复用的机制。<code>I/O</code> 多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步 <code>I/O</code> 则无需自己负责进行读写，异步 <code>I/O</code> 的实现会负责把数据从内核拷贝到用户空间。</p>
<p><code>I/O</code> 多路复用是指内核一旦发现进程指定的一个或者多个 <code>I/O</code> 条件准备读取，它就通知该进程。<code>I/O</code>多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述字时（一般是<strong>交互式输入</strong>和<strong>网络套接口</strong>），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
</ol>
<p><strong>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</strong></p>
<p><strong>select的几大缺点：</strong></p>
<ol>
<li><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></li>
<li><strong>同时每次调用select都需要在内核遍历O(n)地遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></li>
<li><strong>select支持的文件描述符数量太小了，32位默认是1024，64位是2048</strong></li>
<li><p><strong>每次完成监控需要再次重新传入并且分事件传入 操作冗余</strong></p>
<p><code>poll</code> 的实现和 <code>select</code> 非常相似，只是描述 <code>fd</code> 集合的方式不同，<code>poll</code> 使用 <code>pollfd</code> 结构而不是 <code>select</code> 的<code>fd_set</code> 结构，其他的都差不多。</p>
</li>
<li><p><strong>select 时间复杂度O(n)</strong></p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
</li>
<li><p><strong>poll 时间复杂度O(n)</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，但是同样有一个缺点：</p>
<p>1、大量的 <code>fd</code> 的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   </p>
<p>2、<code>poll</code> 还有一个特点是<strong>水平触发</strong>，如果报告 <code>fd</code> 后，没有被处理，那么下次 <code>poll</code> 时会再次报告该 <code>fd</code> 。</p>
</li>
<li><p><strong>epoll 时间复杂度O(1)</strong></p>
<p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，<code>epoll</code> 会把哪个流发生了怎样的I/O事件通知我们。所以我们说 <code>epoll</code> 实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
</li>
</ol>
<hr>
<h4><span id="select">select</span></h4><p><img src="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png" alt="img"></p>
<p><code>select</code> 使用一个宏定义函数按照 <code>bitmap</code> 原理填充 <code>fd</code> ，默认大小是 <code>1024</code> 个，因此对于 <code>fd</code> 的数值大于 <code>1024</code> 都可能出现问题。</p>
<p><img src="https://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png" alt="img"></p>
<p> <code>select</code> 函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：就绪描述符的数目，超时返回 <code>0</code> ，出错返回 <code>-1</code> 。</p>
<p>函数参数介绍如下：</p>
<ol>
<li>第一个参数 <code>maxfdp1</code> 指定待测试的描述字个数，它的值是待测试的最大描述字加 <code>1</code> （因此把该参数命名为<code>maxfdp1</code> ），描述字 <code>0、1、2...maxfdp1 - 1</code> 均将被测试。因为文件描述符是从 <code>0</code> 开始的。</li>
<li>中间的三个参数 <code>readset</code> 、<code>writeset</code> 和 <code>exceptset</code> 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code> 可以理解为一个集合，这个集合中存放的是<strong>文件描述符FD</strong>，可通过以下四个宏进行设置：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 检查集合中指定的文件描述符是否可以读写</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>timeval *timeout</code> 告知内核等待所指定描述字中的任何一个就绪可花多少时间。其 <code>timeval</code> 结构用于指定这段时间的秒数和微秒数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个参数有三种可能：</p>
<p>（1）永远等待下去：仅在有一个描述字准备好 <code>I/O</code> 时才返回。为此，把该参数设置为空指针 <code>NULL</code> 。</p>
<p>（2）等待一段固定时间：在有一个描述字准备好 <code>I/O</code> 时返回，但是不超过由该参数所指向的 <code>timeval</code> 结构中指定的秒数和微秒数。</p>
<p>（3）根本不等待：检查描述字后立即返回，这称为<strong>轮询</strong>。为此，该参数必须指向一个 <code>timeval</code> 结构，而且其中的定时器值必须为 <code>0</code> 。</p>
<hr>
<h4><span id="poll">poll</span></h4><p><strong>“选举出来，立刻返回”</strong></p>
<p><code>poll</code> 的机制与 <code>select</code> 类似，与 <code>select</code> 在本质上没有多大差别，管理多个描述符也是进行<strong>轮询</strong>，根据描述符的状态进行处理，但是 <code>poll</code> <strong>没有最大文件描述符数量的限制</strong>。<code>poll</code> 和 <code>select</code> 同样存在一个缺点就是，<strong>包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</strong></p>
<p>函数格式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pollfd</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;         	  <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents;        <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>每一个 <code>pollfd</code> 结构体指定了一个<strong>被监视的文件描述符</strong>，可以传递多个结构体，指示 <code>poll()</code> 监视多个文件描述符。每个结构体的 <code>events</code> 域是监视该文件描述符的事件掩码，由用户来设置这个域。<code>revents</code> 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。<code>events</code> 域中请求的任何事件都可能在 <code>revents</code> 域中返回。合法的事件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 　　　　　　　　有数据可读。</span><br><span class="line">POLLRDNORM 　　　　  有普通数据可读。</span><br><span class="line">POLLRDBAND　　　　　 有优先数据可读。</span><br><span class="line">POLLPRI　　　　　　　　 有紧迫数据可读。</span><br><span class="line">POLLOUT　　　　　　      写数据不会导致阻塞。</span><br><span class="line">POLLWRNORM　　　　　  写普通数据不会导致阻塞。</span><br><span class="line">POLLWRBAND　　　　　   写优先数据不会导致阻塞。</span><br><span class="line">POLLMSGSIGPOLL 　　　　消息可用。</span><br></pre></td></tr></table></figure>
<p>此外，<code>revents</code> 域中还可能返回下列事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POLLER　　   指定的文件描述符发生错误。</span><br><span class="line">POLLHUP　　 指定的文件描述符挂起事件。</span><br><span class="line">POLLNVAL　　指定的文件描述符非法。</span><br></pre></td></tr></table></figure>
<p><code>timeout</code> 参数指定等待的毫秒数，无论 <code>I/O</code> 是否准备好，<code>poll</code> 都会返回。<code>timeout</code> 指定为负数值表示无限超时，使 <code>poll()</code> 一直挂起直到一个指定事件发生；<code>timeout</code> 为 <code>0</code> 指示 <code>poll</code> 调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，<code>poll()</code> 就像它的名字那样，一旦选举出来，立即返回。</p>
<p><strong>返回值和错误代码</strong><br>成功时，<code>poll()</code> 返回结构体中 <code>revents</code> 域不为 <code>0</code> 的文件描述符个数；如果在超时前没有任何事件发生，<code>poll()</code> 返回 <code>0</code> ；失败时，<code>poll()</code> 返回 <code>-1</code> ，并设置 <code>errno</code> 为下列值之一。</p>
<hr>
<h4><span id="epoll">epoll</span></h4><p><a href="https://blog.csdn.net/liushengxi_root/article/details/87926566" target="_blank" rel="noopener">https://blog.csdn.net/liushengxi_root/article/details/87926566</a></p>
<p><code>epoll</code> 是在 <code>2.6</code> 内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> <strong>使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的 <code>copy</code> 只需一次。</p>
<p><code>epoll</code> 使用 <code>事件</code> 的就绪通知方式，通过 <code>epoll_ctl</code> 注册 <code>fd</code> ，一旦该 <code>fd</code> 就绪，内核就会采用类似 <code>callback</code> 的回调机制来激活该 <code>fd</code> ，<code>epoll_wait</code> 便可以收到通知。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户数据载体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">   <span class="keyword">void</span>    *ptr;</span><br><span class="line">   <span class="keyword">int</span>      fd;</span><br><span class="line">   <span class="keyword">uint32_t</span> u32;</span><br><span class="line">   <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"><span class="comment">//fd装载入内核的载体</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="keyword">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="keyword">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h5><span id="epoll-函数">epoll 函数</span></h5><p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>int epoll_create(int size);</strong><br>在内核区创建一个 <code>epoll</code> 相关的一些列结构，并且将一个句柄 <code>fd</code> 返回给用户态，后续的操作都是基于此 <code>fd</code> 的，<code>size</code> 用来告诉内核这个监听的数目一共有多大，类似于 <code>STL</code> 的 <code>vector</code> 动态数组，如果 <code>size</code> 不合适会涉及复制扩容，不过貌似 <code>4.1.2</code> 内核之后 <code>size</code> 已经没有太大用途了；这个参数不同于 <code>select()</code> 中的第一个参数，<code>select</code> 给出的是最大监听的 <code>fd+1</code> 的值。需要注意的是，当创建好 <code>epoll</code> 句柄后，它就是会占用一个 <code>fd</code> 值，在 <code>linux</code> 下如果查看 <code>/proc/</code> 进程 <code>id/fd/</code> ，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
</li>
<li><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p>
<p><code>epoll</code> 的事件注册函数， <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里 <code>epoll</code> 是先注册要监听的事件类型。第一个参数是 <code>epoll_create()</code> 的返回值，第二个参数 <strong>epoll_event</strong> 是用户态和内核态交互的结构，定义了用户态关心的事件类型和触发时数据的载体 <code>epoll_data</code> ；</p>
<ul>
<li><strong>EPOLL_CTL_ADD</strong>：注册新的 <code>fd</code> 到 <code>epfd</code> 中；</li>
<li><strong>EPOLL_CTL_MOD</strong>：修改已经注册的 <code>fd</code> 的监听事件；</li>
<li><strong>EPOLL_CTL_DEL</strong>：从 <code>epfd</code> 中删除一个 <code>fd</code> ；<br>第三个参数是需要监听的 <code>fd</code> ，第四个参数是告诉内核需要监听什么事，<strong>epoll_event是用户态需监控fd的代言人，后续用户程序对fd的操作都是基于此结构的</strong>，<code>struct epoll_event</code> 结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>events</code> 可以是以下几个宏的集合：</p>
<ul>
<li><strong>EPOLLIN</strong> ：表示对应的文件描述符可以读（包括对端 <code>SOCKET</code> 正常关闭）</li>
<li><strong>EPOLLOUT</strong>：表示对应的文件描述符可以写</li>
<li><strong>EPOLLPRI</strong>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li><strong>EPOLLERR</strong>：表示对应的文件描述符发生错误</li>
<li><strong>EPOLLHUP</strong>：表示对应的文件描述符被挂断</li>
<li><strong>EPOLLET</strong>： 将 <code>EPOLL</code> 设为边缘触发(<strong>Edge Triggered</strong>)模式，这是相对于水平触发(<strong>Level Triggered</strong>)来说的</li>
<li><strong>EPOLLONESHOT</strong>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 <code>socket</code> 的话，需要再次把这个 <code>socket</code> 加入到 <code>EPOLL</code> 队列里。</li>
</ul>
</li>
<li><p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<ul>
<li>是<strong>阻塞等待内核返回的可读写事件</strong>，<code>epfd</code> 还是 <code>epoll_create</code> 的返回值，<code>events</code> 是个结构体数组指针存储 <code>epoll_event</code> ，也就是将内核返回的待处理 <code>epoll_event</code> 结构都存储下来，<code>maxevents</code> 告诉内核本次返回的最大 <code>fd</code> 数量，这个和 <code>events</code> 指向的数组是相关的；</li>
<li><strong>events：</strong>第二个参数是<strong>返回给用户空间需要处理的 I/O 事件</strong>，这是一个数组，数组的大小由 <strong>epoll_wait</strong> 的返回值决定的<strong>事件的个数</strong>，这个数组的每个元素都是一个需要待处理的 I/O 事件，其中 <strong>events</strong> 表示具体的事件类型，事件类型取值和 <strong>epoll_ctl</strong> 可设置的值一样，这个 <strong>epoll_event</strong> 结构体里的 <strong>data</strong> 值就是在 <strong>epoll_ctl</strong> 那里设置的 <strong>data</strong>，也就是<strong>用户空间和内核空间调用时需要的数据</strong>。</li>
<li><strong>返回值:</strong> <ul>
<li>成功返回的是一个大于0的数，<strong>表示事件的个数</strong>；</li>
<li>返回 <code>0</code> 表示的是超时时间到；</li>
<li>返回 <code>-1</code> 表示出错</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5><span id="epoll的底层实现"><strong>epoll的底层实现</strong></span></h5><p><code>epoll</code> 底层实现最重要的两个数据结构：<code>epitem</code> 和 <code>eventpoll</code> 。</p>
<ul>
<li>1.执行 <strong>epoll_create</strong> 时，创建了红黑树和就绪 list 链表。</li>
<li>2.执行<strong>epoll_ctl</strong>时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，并且注册fd的回调函数（内核定义的回调函数），内核在检测到某fd就绪时会调用回调函数将fd 添加到就绪链表中。</li>
<li>3.执行 <strong>epoll_wait</strong> 时立刻通过<strong>共享内存</strong>❓(存疑)的方式返回准备就绪链表 <strong>rdlist</strong> 里的数据即可。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190903153708344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXNoZW5neGlfcm9vdA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以简单的认为<strong>epitem</strong>是和每个用户态监控 <code>I/O</code> 的 <code>fd</code> 对应的，<strong>eventpoll</strong>是用户态创建的管理所有被监控 <code>fd</code> 的结构，详细的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  _LINUX_RBTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _LINUX_RBTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rcupdate.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"><span class="comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">rdllink</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>  *<span class="title">next</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  </span><br><span class="line">  <span class="keyword">int</span>  nwait;                 </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">pwqlist</span>;</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>  *<span class="title">ep</span>;</span>      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">fllink</span>;</span>   </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>  <span class="title">event</span>;</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">  <span class="keyword">spin_lock_t</span>       lock; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>      <span class="title">mtx</span>;</span>  </span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>     wq; </span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>   poll_wait; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllist</span>;</span>   <span class="comment">//就绪事件链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>      <span class="title">rbr</span>;</span>      <span class="comment">//红黑树根节点 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>      *<span class="title">ovflist</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>epoll的高效就在于</strong>，当我们调用 <code>epoll_ctl</code> 往 <code>epoll_event</code> 里塞入百万个句柄时，<code>epoll_wait</code> 仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。这是由于我们在调用 <code>epoll_create</code> 时，内核除了帮我们在 <code>epoll</code> 文件系统里建了个 <code>file</code> 结点，在<strong>内核cache</strong>里建了个<strong>红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件</strong>，当 <code>epoll_wait</code> 调用时，仅仅观察这个 <code>list</code> 链表里有没有数据即可。有数据就返回，没有数据就 <code>sleep</code> ，等到 <code>timeout</code> 时间到后即使链表没数据也返回。所以，<code>epoll_wait</code> 非常高效。</p>
<p><code>epoll</code> 的解决方案不像 <code>select</code> 或 <code>poll</code> 一样每次都把 <code>current</code> 轮流加入 <code>fd</code> 对应的设备等待队列中，而只在<code>epoll_ctl</code> 时把 <code>current</code> 注册一遍（这一遍必不可少）并<strong>为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表</strong>）。</p>
<p>当我们执行 <code>epoll_ctl</code> 时，除了把 <code>socket</code> 放到 <code>epoll</code> 文件系统里 <code>file</code> 对象对应的红黑树上之外，还会给<strong>内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里</strong>。</p>
<p><strong>底层调用过程</strong></p>
<ol>
<li><code>epoll_create</code> 会创建一个类型为 <code>struct eventpoll</code> 的对象，并返回一个与之对应文件描述符。之后<strong>应用程序在用户态使用 <code>epoll</code> 的时候都将依靠这个文件描述符，而在 <code>epoll</code> 内部也是通过该文件描述符进一步获取到 <code>eventpoll</code> 类型对象，再进行对应的操作，完成了用户态和内核态的贯穿。</strong></li>
<li><code>epoll_ctl</code> 底层主要调用 <code>epoll_insert</code> 实现操作:<ul>
<li>创建并初始化一个<code>struct epitem</code> 类型的对象，完成该对象和被监控事件以及 <code>epoll</code> 对象 <code>eventpoll</code> 的关联;</li>
<li>将 <code>struct epitem</code> 类型的对象加入到 <code>epoll</code> 对象 <code>eventpoll</code> 的红黑树中管理起来;</li>
<li>将 <code>struct epitem</code> 类型的对象加入到被监控事件对应的目标文件的等待列表中，并注册事件就绪时会调用的回调函数，在 <code>epoll</code> 中该回调函数就是 <code>ep_poll_callback()</code> ;</li>
<li><code>ovflist</code> 主要是<strong>暂态处理</strong>，比如调用 <code>ep_poll_callback()</code> 回调函数的时候发现 <code>eventpoll</code> 的 <code>ovflist</code> 成员不等于 <code>EP_UNACTIVE_PTR</code> ，说明正在扫描 <code>rdllist</code> 链表，这时将就绪事件对应的<code>epitem</code> 加入到 <code>ovflist</code> 链表暂存起来，等 <code>rdllist</code> 链表扫描完再将 <code>ovflist</code> 链表中的元素移动到<code>rdllist</code> 链表中；</li>
</ul>
</li>
</ol>
<p>如图展示了红黑树、双链表、<code>epitem</code> 之间的关系：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMj1rxibhibqZx2wKJiaFvWic5iaqcOzoicHQVQ07GHIveN1Sb0ZV2tEQLic5nw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ol>
<li><p><strong>epoll_wait的数据拷贝</strong></p>
<p>关于 <code>epoll_wait</code> 使用共享内存的方式来加速用户态和内核态的数据交互，避免内存拷贝的观点，并没有得到2.6内核版本代码的证实，关于拷贝的实现是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">revents = ep_item_poll(epi, &amp;pt);<span class="comment">//获取就绪事件</span></span><br><span class="line"><span class="keyword">if</span> (revents) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">  __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">    list_add(&amp;epi-&gt;rdllink, head);<span class="comment">//处理失败则重新加入链表</span></span><br><span class="line">    ep_pm_stay_awake(epi);</span><br><span class="line">    <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">  &#125;</span><br><span class="line">  eventcnt++;</span><br><span class="line">  uevent++;</span><br><span class="line">  <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">    epi-&gt;event.events &amp;= EP_PRIVATE_BITS;<span class="comment">//EPOLLONESHOT标记的处理</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<span class="comment">//LT模式处理</span></span><br><span class="line">    ep_pm_stay_awake(epi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h5><span id="优点">优点</span></h5><ol>
<li>没有最大并发连接的限制，能打开的 <code>FD</code> 的上限远大于 <code>1024</code>（ <code>1G</code> 的内存上能监听约10万个端口）</li>
<li>效率提升，不是轮询的方式，不会随着 <code>FD</code> 数目的增加效率下降。只有活跃可用的 <code>FD</code> 才会调用 <code>callback</code> 函数。即 <code>Epoll</code> 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>Epoll</code> 的效率就会远远高于 <code>select</code> 和 <code>poll</code> 。</li>
<li>因为内核知道所有被监听的描述符，所以即使没有人调用 <code>epoll_wait()</code> ，内核也可以记录发生的事件，这允许实现边沿触发。</li>
<li><code>epoll_wait()</code> 函数可以让多个线程等待同一个 <code>epoll</code> 队列而且推荐设置为边沿触发模式，这在其他轮询方式中是不可能实现的。</li>
</ol>
<h5><span id="缺点">缺点</span></h5><ul>
<li><strong>改变监听事件的类型</strong>（例如从读事件改为写事件）需要调用<strong>epoll_ctl</strong>系统调用，而这在<strong>poll</strong>中只需要在用户空间简单的设置一下对应的掩码。如果需要改变5000个套接字的监听事件类型就需要5000次系统调用和上下文切换（直到2014年epoll_ctl函数仍然不能批量操作，每个描述符只能单独操作），这在poll中只需要循环一次pollfd结构体。</li>
<li><strong>每一个被accept()的套接字都需要添加到集合中</strong>，在 <code>epoll</code> 中必须使用 <code>epoll_ctl</code> 来添加：这就意味着<strong>每一个新的连接都需要两次系统调用，而在poll中只需要一次</strong>。如果你的服务有非常多的短连接它们都接受或者发送少量数据，epoll所花费的时间可能比poll更长。(解释了上文)</li>
<li>epoll是Linux上独有的，虽然其他平台上也有类似的机制但是他们的区别非常大，例如边沿触发这种模式是非常独特的（FreeBSD的kqueue对它的支持非常粗糙）。</li>
</ul>
<hr>
<h5><span id="边缘触发etamp水平触发lt">边缘触发ET&amp;水平触发LT</span></h5><p><strong>水平触发</strong>：<strong>只要缓冲区有数据就会一直触发</strong></p>
<p><strong>边沿触发</strong>：<strong>只有在缓冲区增加数据的那一刻才会触发</strong></p>
<p><code>epoll</code> 对文件描述符的操作有两种模式：<code>LT（level trigger）</code> 和 <code>ET（edge trigger）</code> 。<code>LT</code> 模式是默认模式，<code>LT</code> 模式与 <code>ET</code> 模式的区别如下：</p>
<ul>
<li><strong>LT模式</strong><ul>
<li><strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。</strong></li>
<li><strong>下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></li>
<li><strong>LT支持阻塞和非阻塞套接字，LT模式更加安全</strong></li>
</ul>
</li>
<li><p><strong>ET模式</strong></p>
<ul>
<li><strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。</strong></li>
<li><strong>如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件.</strong></li>
<li><strong>read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者遇到EAGAIN错误。</strong></li>
<li><strong>只支持非阻塞套接字，其效率要高于LT模式。</strong></li>
</ul>
</li>
<li><p>如果对 <code>listenfd</code> 设置 <code>ET</code> 模式，<code>accept</code> 只要没有接受完全连接队列，这些连接就不会再次被触发了！！！就是从 <code>rdllist</code> 上删除了呗</p>
</li>
<li><code>LT</code> 的话就是<strong>会将没处理完的放在 rdlist 的最前面，然后跟着下次需要返回的一起返回</strong></li>
</ul>
<p><code>ET</code> 模式在<strong>很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 <code>LT</code> 模式高</strong>。<code>epoll</code> 工作在 <code>ET</code> 模式的时候，必须使用<strong>非阻塞IO</strong>，<strong>以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死</strong>。</p>
<p><code>LT</code> 和 <code>ET</code> 模式下都可以通过 <code>epoll_wait</code> 方法来获取事件。</p>
<ul>
<li><p><code>LT</code> 模式下将事件拷贝给用户程序之后，如果没有被处理或者未处理完，那么在下次调用时还会反馈给用户程序，可以认为数据不会丢失会反复提醒；</p>
</li>
<li><p><code>ET</code> 模式下如果没有被处理或者未处理完，那么下次将不再通知到用户程序，因此<strong>避免了反复被提醒</strong>，却<strong>加强了对用户程序读写的要求</strong>；</p>
</li>
</ul>
<hr>
<h5><span id="lt和et的读写问题">LT和ET的读写问题</span></h5><ol>
<li><strong>LT</strong><ul>
<li><strong>read</strong><ul>
<li><code>LT</code> 对于 <code>read</code> 操作比较简单，有 <code>read</code> 事件就读，读多读少都没有问题。</li>
</ul>
</li>
<li><strong>write</strong><ul>
<li>但是 <code>write</code> 就不那么容易了，一般来说<strong>socket在空闲状态时发送缓冲区一定是不满的</strong>，假如 <code>fd</code> 一直在监控中，那么会一直通知写事件，不胜其烦。</li>
<li>所以必须<strong>保证没有数据要发送的时候，要把 <code>fd</code> 的 <code>写</code> 事件监控从 <code>epoll</code> 列表中删除</strong>，<strong>需要的时候再加入回去，如此反复</strong>。</li>
<li>对应 <code>write</code> 的过度提醒，需要使用者随用随加，否则将一直被提醒可写事件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>ET</strong><ul>
<li><strong>read</strong><ul>
<li><code>fd</code> 可读则返回可读事件，若开发者没有把所有数据读取完毕，<code>epoll</code> 不会再次通知 <code>read</code> 事件。</li>
<li>也就是说如果没有全部读取所有数据，那么导致 <code>epoll</code> 不会再通知该 <code>socket</code> 的 <code>read</code> 事件，事实上一直读完很容易做到。</li>
</ul>
</li>
<li><strong>write</strong><ul>
<li><strong>若发送缓冲区未满，epoll通知write事件，直到开发者填满发送缓冲区，epoll才会在下次发送缓冲区由满变成未满时通知write事件。</strong></li>
</ul>
</li>
<li><code>ET</code> 模式下<strong>只有socket的状态发生变化</strong>时才会通知，也就是<strong>读取缓冲区由无数据到有数据时通知read事件</strong>，<strong>发送缓冲区由满变成未满通知write事件</strong>。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>一道面试题</strong></p>
<blockquote>
<p>使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？</p>
<p>网络流传的腾讯面试题</p>
</blockquote>
<p>这道题目对 <code>LT</code> 和 <code>ET</code> 考察比较深入，验证了前文说的 <code>LT</code> 模式 <code>write</code> 问题。</p>
<p><strong>普通做法</strong>：  </p>
<ul>
<li>当<strong>需要向socket写数据时，将该socket加入到epoll等待可写事件</strong>。接收到 <code>socket</code> 可写事件后，调用 <code>write()</code> 或 <code>send()</code> 发送数据；</li>
<li><strong>当数据全部写完后， 将socket描述符移出epoll列表，这种做法需要反复添加和删除。</strong></li>
</ul>
<p><strong>改进做法</strong>:</p>
<ul>
<li>向 <code>socket</code> 写数据时直接调用 <code>send()</code> 发送，当 <code>send()</code> 返回错误码 <code>EAGAIN</code> (写空了)，才将 <code>socket</code> 加入到 <code>epoll</code> (类似 <code>ET</code> 模式)。等待可写事件后再发送数据，全部数据发送完毕，再移出 <code>epoll</code> 模型。</li>
<li>改进的做法相当于认为 <code>socket</code> 在<strong>大部分时候是可写的</strong>，<strong>不能写了再让epoll帮忙监控</strong>。</li>
</ul>
<p>上面两种做法是对 <code>LT</code> 模式下 <code>write</code> 事件频繁通知的修复，本质上 <code>ET</code> 模式就可以直接搞定，并不需要用户层程序的补丁操作。</p>
<hr>
<h5><span id="et模式的线程饥饿问题">ET模式的线程饥饿问题</span></h5><p>如果某个 <code>socket</code> 源源不断地收到非常多的数据，在试图读取完所有数据的过程中，有可能会造成其他的 <code>socket</code> 得不到处理，从而造成<strong>饥饿</strong>问题。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>为每个<strong>已经准备好的描述符</strong>维护一个队列，这样程序就可以知道哪些描述符已经准备好了但是并没有被读取完</li>
<li>程序定时或定量的读取，如果读完则移除，直到队列为空，这样就保证了每个 <code>fd</code> 都被读到并且不会丢失数据，流程如图。(类似调度算法中的 <code>Robin Round</code> ？)</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMSj8caicicn1aLlm47p4w3OKgk7dHGXUjRkGibPMfF4VAcdptA5wibPpg1w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<hr>
<h5><span id="epolloneshot设置">EPOLLONESHOT设置</span></h5><p><code>A</code> 线程读完某 <code>socket</code> 上的数据后开始处理这些数据，此时该 <code>socket</code> 上又有新数据可读，B线程被唤醒读新的数据，造成 <code>2</code> 个线程<strong>同时操作一个socket</strong>的局面 ，<strong>EPOLLONESHOT</strong>保证<strong>一个socket连接在任一时刻只被一个线程处理</strong>。 </p>
<hr>
<h5><span id="两种模式的选择">两种模式的选择</span></h5><p>通过前面的对比可以看到<strong>LT模式比较安全并且代码编写也更清晰</strong>，但是<strong>ET模式属于高速模式</strong>，在处理大高并发场景使用得当效果更好，具体选择什么根据自己实际需要和团队代码能力来选择，如果并发很高且团队水平较高可以选择 <code>ET</code> 模式，否则建议 <code>LT</code> 模式。</p>
<hr>
<h5><span id="epoll的惊群问题epollexclusive">Epoll的惊群问题(EPOLLEXCLUSIVE)</span></h5><p>在 <code>2.6.18</code> 内核中 <code>accept</code> 的惊群问题已经被解决了，但是在 <code>epoll</code> 中仍然存在<strong>惊群问题</strong>：表现起来就是<strong>当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。</strong></p>
<p>在 <code>epoll</code> 官方没有正式修复这个问题之前，Nginx作为知名使用者采用<strong>全局锁来限制每次可监听fd的进程数量</strong>，<strong>每次只有1个可监听的进程</strong>，后来在Linux 3.9内核中增加了SO_REUSEPORT选项实现了内核级的负载均衡，Nginx1.9.1版本支持了reuseport这个新特性，从而解决惊群问题。</p>
<p><strong>EPOLLEXCLUSIVE</strong> 是在2016年 <code>Linux 4.5</code> 内核新添加的一个 <code>epoll</code>  的标识，Ngnix 在 1.11.3 之后添加了 <code>NGX_EXCLUSIVE_EVENT</code> 选项对该特性进行支持。<strong><code>EPOLLEXCLUSIVE</code> 标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。</strong></p>
<hr>
<h5><span id="epoll边缘触发的io应该怎么写">Epoll边缘触发的IO应该怎么写？</span></h5><hr>
<h4><span id="epollpoll的选择">Epoll/poll的选择？</span></h4><p><strong>Epoll的性能一定比poll差吗？</strong></p>
<ul>
<li>在<strong>连接数少</strong>并且<strong>连接都十分活跃</strong>的情况下，<strong>poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></li>
<li><strong>在高并发连接钟，每次处理的活跃连接数量占比很小的情况下，epoll性能好。</strong></li>
</ul>
<h5><span id="什么情况下使用epoll">什么情况下使用Epoll：</span></h5><ul>
<li><strong>你的程序通过多个线程来处理大量的网络连接</strong>。如果你的程序只是单线程的那么将会失去epoll的很多优点。并且很有可能不会比poll更好。</li>
<li><strong>你需要监听的套接字数量非常大（至少1000）</strong>；如果监听的套接字数量很少则使用epoll不会有任何性能上的优势甚至可能还不如poll。</li>
<li><strong>你的网络连接相对来说都是长连接</strong>；就像上面提到的<strong>epoll处理短连接的性能还不如poll，因为epoll需要额外的系统调用来添加描述符到集合中。</strong></li>
<li>你的应用程序依赖于Linux上的其他特性</li>
</ul>
<p><strong>否则都应该使用poll</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/计算机网络/" rel="tag"># 计算机网络</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/24/操作系统总结/" rel="next" title="操作系统总结">
                <i class="fa fa-chevron-left"></i> 操作系统总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/28/数据库总结/" rel="prev" title="数据库总结">
                数据库总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">345</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">OSI七层模型，每一层的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.</span> <span class="nav-text">协议分别有：</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">TCP/UDP/运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.1.</span> <span class="nav-text">⭐UDP和TCP的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.</span> <span class="nav-text">TCP/UDP数据发送和接收过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.1.</span> <span class="nav-text">发送端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.2.</span> <span class="nav-text">接收端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.3.</span> <span class="nav-text">复用与分用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.3.</span> <span class="nav-text">TCP协议的可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.</span> <span class="nav-text">TCP协议保证数据传输可靠性的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.1.</span> <span class="nav-text">首部校验和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.2.</span> <span class="nav-text">序列号和确认应答(ACK)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">序列号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">确认应答</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">选择确认 SACK</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.3.</span> <span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.4.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.5.</span> <span class="nav-text">滑动窗口(以字节为单位)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.6.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">慢开始</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.6.3.</span> <span class="nav-text">快重传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.6.4.</span> <span class="nav-text">快恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.5.</span> <span class="nav-text">TCP 报文段首部格式(20Byte)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.</span> <span class="nav-text">UDP报文段首部格式(8Byte)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.1.</span> <span class="nav-text">计算伪首部的原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.7.</span> <span class="nav-text">停止等待 ARQ 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.8.</span> <span class="nav-text">常见的拥塞控制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.</span> <span class="nav-text">三次握手四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.2.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.3.</span> <span class="nav-text">TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.4.</span> <span class="nav-text">如果出现了大量的TIMEWAIT可能有什么原因？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.4.1.</span> <span class="nav-text">如何尽量处理TIMEWAIT过多?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.5.</span> <span class="nav-text">如果出现了大量的CLOSEWAIT可能有什么原因？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.10.</span> <span class="nav-text">TCP重传机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.10.1.</span> <span class="nav-text">TCP协议中的计时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.10.2.</span> <span class="nav-text">Nagle算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.11.</span> <span class="nav-text">TCP/IP中的分组和分片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.11.1.</span> <span class="nav-text">分组交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.11.2.</span> <span class="nav-text">分片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.</span> <span class="nav-text">Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.1.</span> <span class="nav-text">什么是socket</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.1.1.</span> <span class="nav-text">socket函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.1.2.</span> <span class="nav-text">bind函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.1.3.</span> <span class="nav-text">listen/connect函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.1.4.</span> <span class="nav-text">accept函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.2.</span> <span class="nav-text">read/write函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.3.</span> <span class="nav-text">SOCKET通信中TCP、UDP数据包大小的确定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.3.1.</span> <span class="nav-text">MTU最大传输单元</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.4.</span> <span class="nav-text">backlog是干嘛的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.13.</span> <span class="nav-text">为什么会发生粘包/黏包？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.13.1.</span> <span class="nav-text">TCP当中才会有粘包问题，UDP不存在粘包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">2.13.2.</span> <span class="nav-text">如何避免粘包问题？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.14.</span> <span class="nav-text">为什么会发生丢包？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.15.</span> <span class="nav-text">访问toutiao.com打不开，应该怎么排查错误？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">IP/网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.1.</span> <span class="nav-text">地址解析协议 ARP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">计算机网络是如何根据IP地址定位到一台主机的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.2.</span> <span class="nav-text">DHCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.</span> <span class="nav-text">ICMP/IGMP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.1.</span> <span class="nav-text">网际控制报文协议 ICMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.2.</span> <span class="nav-text">ICMP 报文种类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">ping和telnet的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.3.</span> <span class="nav-text">网际组管理协议 IGMP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.</span> <span class="nav-text">IP 数据报的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.0.1.</span> <span class="nav-text">首部固定字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.0.2.</span> <span class="nav-text">首部可变部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.1.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.</span> <span class="nav-text">HTTP字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.</span> <span class="nav-text">⭐HTTPS的通信过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.1.</span> <span class="nav-text">非对称加密算法+对称加密算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.2.</span> <span class="nav-text">数字证书—防止中间人攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.3.</span> <span class="nav-text">数字摘要算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.4.</span> <span class="nav-text">证书内置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.4.</span> <span class="nav-text">get/post 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.5.</span> <span class="nav-text">http/https 0.9、1.0、1.1、2.0、3.0的特点和区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.5.1.</span> <span class="nav-text">Http0.9</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.5.2.</span> <span class="nav-text">Http1.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.5.3.</span> <span class="nav-text">Http1.1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.5.4.</span> <span class="nav-text">Http2.0(基于HTTPS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.5.5.</span> <span class="nav-text">Http3.0</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.6.</span> <span class="nav-text">QUIC和BBR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.7.</span> <span class="nav-text">HTTP的无状态性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.7.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.7.2.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.7.3.</span> <span class="nav-text">Session和Cookie的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.8.</span> <span class="nav-text">HTTP请求种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.</span> <span class="nav-text">HTTP报文结构和内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.1.</span> <span class="nav-text">请求报文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.1.1.</span> <span class="nav-text">请求行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.1.2.</span> <span class="nav-text">请求头部</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.1.3.</span> <span class="nav-text">(空行)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.1.4.</span> <span class="nav-text">请求数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.2.</span> <span class="nav-text">响应报文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.2.1.</span> <span class="nav-text">状态行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.2.2.</span> <span class="nav-text">响应头部</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.2.3.</span> <span class="nav-text">(空行)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">4.9.2.4.</span> <span class="nav-text">响应体</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.</span> <span class="nav-text">从浏览器输入URL到出现页面经过了哪些阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.1.</span> <span class="nav-text">输入网址：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.2.</span> <span class="nav-text">缓存解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.3.</span> <span class="nav-text">域名解析(DNS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.4.</span> <span class="nav-text">tcp链接，三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.5.</span> <span class="nav-text">发送HTTP请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.6.</span> <span class="nav-text">服务器收到请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.7.</span> <span class="nav-text">浏览器页面渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">4.10.8.</span> <span class="nav-text">断开连接，四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.11.</span> <span class="nav-text">HTTP如何实现缓存，怎样告诉浏览器这个可以被缓存以及缓存时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">网络IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">5.1.</span> <span class="nav-text">五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.1.1.</span> <span class="nav-text">阻塞IO(BIO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.1.2.</span> <span class="nav-text">非阻塞IO(NIO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.1.3.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.1.4.</span> <span class="nav-text">信号驱动的IO模型(SIGIO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.1.5.</span> <span class="nav-text">异步IO模型(AIO)(非阻塞)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">5.2.</span> <span class="nav-text">两种IO事件处理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.2.1.</span> <span class="nav-text">Reactor模式(同步的)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.2.2.</span> <span class="nav-text">Proactor模式 (异步)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.</span> <span class="nav-text">⭐IO多路复用：select/poll/epoll(同步/阻塞)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">epoll 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">epoll的底层实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.5.</span> <span class="nav-text">边缘触发ET&amp;水平触发LT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.6.</span> <span class="nav-text">LT和ET的读写问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.7.</span> <span class="nav-text">ET模式的线程饥饿问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.8.</span> <span class="nav-text">EPOLLONESHOT设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.9.</span> <span class="nav-text">两种模式的选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.10.</span> <span class="nav-text">Epoll的惊群问题(EPOLLEXCLUSIVE)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.3.11.</span> <span class="nav-text">Epoll边缘触发的IO应该怎么写？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.4.</span> <span class="nav-text">Epoll/poll的选择？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">什么情况下使用Epoll：</span></a></li></ol></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
