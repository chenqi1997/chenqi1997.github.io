<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,Redis,数据库,">










<meta name="description" content="Redis Redis常用的五种数据类型 string字符串 list列表 set集合 sorted set(Zset)有序集合 ZSet中跳表的实现细节   hash哈希表 dictEntry： dictht： dict 渐进式扩容 map的扩容   Redis Geo Hash HyperLogLog Bitmap Bloom Filter   Redis持久化 RDB(Redis Dat">
<meta name="keywords" content="基础知识,Redis,数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis总结">
<meta property="og:url" content="http://chenqi1997.github.io/2021/01/01/Redis总结/index.html">
<meta property="og:site_name" content="Cq的Blog">
<meta property="og:description" content="Redis Redis常用的五种数据类型 string字符串 list列表 set集合 sorted set(Zset)有序集合 ZSet中跳表的实现细节   hash哈希表 dictEntry： dictht： dict 渐进式扩容 map的扩容   Redis Geo Hash HyperLogLog Bitmap Bloom Filter   Redis持久化 RDB(Redis Dat">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicRdRFqeTHHLZZhV8HdQBzLZqIib0Rxx4dOpZaM8icQ0tf9U9ibBwpgPZAw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7Diay6tbe99SxEdCbyfMItmJNEDgxQ3iayqmSyEZ8q6IIsibbNQJtP8AcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaS8FxVXL1em0ozmuyF9fVu5OAGw7wIXDQbLxM1RU90m0a7H41HjT2pbkBicX0wnUYibicxumpchp3dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7xgecNQ4nvH3PDdibyB4FVTVIq8VARFUy6sicxRoI7czmLib03DnNTmqCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaS8FxVXL1em0ozmuyF9fVuLlHpcCI2n0VyaAYiapcEPOZabutuZgh8iaR8LzSy7b59bfFrlybLvtYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRictDslPRoCZ9eo1Jyd1cI5TjGEKQ9zBpS7rKV1G1x0NHnrjqeA51NVWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicnAYFia6e6tnNjwW51AIibvibQKdicDKwOFmPDIUVOS5jobkj2iaTFX7bxfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic9gbIkzHhat4licrMDFto2EI9H4sv8fEib74SUZC90WP3YmsgibjoAjFiaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic4nG6bxaV4zdIpGjBqzdhicMicC8tqv3pyDNDXVg1tHZRyugicicVhrzX8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq1.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic8YDTXRLm1sPmRWOlEG8gKNBQj5LHicgaQmIibxXHOluSe10MR9Yo7KuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicFRKa0t7iciaRP0Tm4ogjUUc65RoGZC0VAdicBWrFiboofwNujkPJIPB4hg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://www.redis.com.cn/images/riq3.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq4.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicAhskdG8GFVN7KosOFbKyb57I1NbY5dp0YGre7g9Sib13kcNacntAt1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicHaIXZDQYwicxrdF0LZQ7KsbYnRZzEqk77iaXicf41GJcvwhv77nRgGspg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://www.redis.com.cn/images/riq5.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq6.png">
<meta property="og:image" content="https://www.redis.com.cn/images/riq7.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic9kicG37hoLHYI5rgokUdyjoqmicB7nxdHvibZg0Vtictsm6GJwIkGgILnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicdt9GcFtcd23aQ02J1AaoIvd9Sp1bNMgL6rf5iaTiaP3reNUhutVJ49sw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7WIOWyzXHCzPhr4bNJzH3QdYF8R4v27XuIWCqsg8PWGCGg39lTIe3LA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7j3SxhEXDibAdYCbYm28oUqFSbsFuJav9yGBNyoYbLl730vnc5YUyzqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicKADFgJeRqx92JxQLGicLfm6QaicJRc6fO1DFx02MuBUM3Jarl8XP5eLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-4bd6569139472aaf4423540dd303e61a_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-ae9a21e786e1a9366d49e6b65d41f8ec_720w.jpg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdamw8TUnbbmoMOjiauAdVZPNLjkw0wfCbZN4h881rxz6QnJ5soxoXLvicGibbWicqiak2VewO05or9GHog/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img.php.cn/upload/image/149/923/673/1574231607982056.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicxvnHbjoxtZoGYfnoH2GhkHBVTJtLGRgDgxcqgriaPkpIT1aST3gLaEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicNjicWnydjDCHISvBzjmXnHQLke08tYjVWa6xR2tiazNzJ5ImqXCguHfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRiceatj5q5PgGsbibicbVvxBaSDAibL1DVYU1stK0kcQOMibEmB98llI7fhyg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/740516/202009/740516-20200902230544013-1122873010.png">
<meta property="og:updated_time" content="2021-02-28T15:50:05.811Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis总结">
<meta name="twitter:description" content="Redis Redis常用的五种数据类型 string字符串 list列表 set集合 sorted set(Zset)有序集合 ZSet中跳表的实现细节   hash哈希表 dictEntry： dictht： dict 渐进式扩容 map的扩容   Redis Geo Hash HyperLogLog Bitmap Bloom Filter   Redis持久化 RDB(Redis Dat">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicRdRFqeTHHLZZhV8HdQBzLZqIib0Rxx4dOpZaM8icQ0tf9U9ibBwpgPZAw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chenqi1997.github.io/2021/01/01/Redis总结/">





  <title>Redis总结 | Cq的Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cq的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海交通大学电子系图像所/非自然程序员/业余厨师</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqi1997.github.io/2021/01/01/Redis总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈琦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cq的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-01T17:46:00+08:00">
                2021-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<ul>
<li><a href="#redis">Redis</a><ul>
<li><a href="#redis常用的五种数据类型">Redis常用的五种数据类型</a><ul>
<li><a href="#string字符串">string字符串</a></li>
<li><a href="#list列表">list列表</a></li>
<li><a href="#set集合">set集合</a></li>
<li><a href="#sorted-setzset有序集合">sorted set(Zset)有序集合</a><ul>
<li><a href="#zset中跳表的实现细节">ZSet中跳表的实现细节</a></li>
</ul>
</li>
<li><a href="#hash哈希表">hash哈希表</a><ul>
<li><a href="#dictentry"><strong>dictEntry</strong>：</a></li>
<li><a href="#dictht"><strong>dictht：</strong></a></li>
<li><a href="#dict"><strong>dict</strong></a></li>
<li><a href="#渐进式扩容"><strong>渐进式扩容</strong></a></li>
<li><a href="#map的扩容">map的扩容</a></li>
</ul>
</li>
<li><a href="#redis-geo-hash">Redis Geo Hash</a></li>
<li><a href="#hyperloglog">HyperLogLog</a></li>
<li><a href="#bitmap">Bitmap</a></li>
<li><a href="#bloom-filter">Bloom Filter</a></li>
</ul>
</li>
<li><a href="#redis持久化">Redis持久化</a><ul>
<li><a href="#rdbredis-database-半持久化模式snapshotting快照">RDB(Redis DataBase) 半持久化模式/Snapshotting快照</a><ul>
<li><a href="#手动触发以及copyonwrite">手动触发以及CopyOnWrite</a></li>
</ul>
</li>
<li><a href="#aofappend-only-file-全持久化模式">AOF(Append-only file) 全持久化模式</a><ul>
<li><a href="#aof整个流程分两步"><strong>AOF整个流程分两步</strong>：</a></li>
</ul>
</li>
<li><a href="#恢复">恢复</a></li>
<li><a href="#存储结构">存储结构</a></li>
</ul>
</li>
<li><a href="#redis架构模式集群高可用">Redis架构模式/集群高可用</a><ul>
<li><a href="#1-单机版">1. 单机版</a></li>
<li><a href="#2-主从复制">2. 主从复制</a><ul>
<li><a href="#全量同步">全量同步</a></li>
<li><a href="#增量同步">增量同步</a></li>
<li><a href="#redis主从同步策略"><strong>Redis主从同步策略</strong></a></li>
</ul>
</li>
<li><a href="#3-哨兵">3. 哨兵</a><ul>
<li><a href="#三个特性">三个特性：</a></li>
</ul>
</li>
<li><a href="#4-集群proxy型">4. 集群(proxy型)</a></li>
<li><a href="#5-集群直连型">5. 集群(直连型)</a><ul>
<li><a href="#分区规则">分区规则</a></li>
<li><a href="#特点">特点</a></li>
<li><a href="#缺点">缺点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis-限流">Redis 限流</a><ul>
<li><a href="#基于redis的setnx-zset">基于Redis的setnx、zset</a></li>
<li><a href="#漏桶算法">漏桶算法</a></li>
<li><a href="#令牌桶算法">令牌桶算法</a></li>
</ul>
</li>
<li><a href="#redis是单线程的但redis为什么这么快">Redis是单线程的，但Redis为什么这么快？</a><ul>
<li><a href="#基于内存实现">基于内存实现</a></li>
<li><a href="#高效的数据结构">高效的数据结构</a></li>
<li><a href="#合理的数据编码">合理的数据编码</a></li>
<li><a href="#合适的线程模型">合适的线程模型</a></li>
</ul>
</li>
<li><a href="#redis60后引入多线程提速">Redis6.0后引入多线程提速</a><ul>
<li><a href="#开启多线程后是否会存在线程并发安全问题"><strong>开启多线程后，是否会存在线程并发安全问题？</strong></a></li>
<li><a href="#redis60与memcached多线程模型对比"><strong>Redis6.0与Memcached多线程模型对比：</strong></a></li>
</ul>
</li>
<li><a href="#为什么redis用跳表不用红黑树">为什么redis用跳表不用红黑树</a></li>
<li><a href="#为什么redis不用b树">为什么redis不用b+树</a></li>
<li><a href="#redis的用途是什么">Redis的用途是什么？</a></li>
<li><a href="#redis缓存常见问题">Redis缓存常见问题</a><ul>
<li><a href="#1-缓存雪崩">1. 缓存雪崩</a></li>
<li><a href="#2-缓存穿透">2. 缓存穿透</a></li>
<li><a href="#3-缓存击穿">3. 缓存击穿</a></li>
<li><a href="#4-双写一致性">4. 双写一致性</a><ul>
<li><a href="#先更新数据库再更新缓存有线程安全问题"><strong>先更新数据库，再更新缓存</strong>(<strong>×有线程安全问题</strong>)</a></li>
<li><a href="#先删缓存再更新数据库延时双删"><strong>先删缓存，再更新数据库(延时双删)</strong></a></li>
<li><a href="#先更新数据库再删缓存cache-aside-pattern"><strong>先更新数据库，再删缓存(Cache Aside Pattern)</strong></a></li>
</ul>
</li>
<li><a href="#5-脑裂">5. 脑裂</a><ul>
<li><a href="#redis处理方案是redis的配置文件中存在两个参数">Redis处理方案是redis的配置文件中存在两个参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis事务">Redis事务</a></li>
<li><a href="#redis正确开发步骤">Redis正确开发步骤</a></li>
<li><a href="#redis-key的3种过期删除策略">Redis key的3种过期删除策略</a><ul>
<li><a href="#惰性删除被动-expireifneeded"><strong>惰性删除(被动) expireIfNeeded()</strong>：</a></li>
<li><a href="#定期删除主动-activeexpirecycle"><strong>定期删除(主动) </strong> <strong>activeExpireCycle()</strong>：</a></li>
<li><a href="#定时删除主动"><strong>定时删除(主动)</strong>：</a></li>
</ul>
</li>
<li><a href="#redis的6种内存淘汰策略">Redis的6种内存淘汰策略</a></li>
<li><a href="#redis实现分布式锁">Redis实现分布式锁</a></li>
<li><a href="#redis相比memcached有哪些优势">Redis相比memcached有哪些优势</a></li>
<li><a href="#redis-限流-1">Redis 限流</a><ul>
<li><a href="#基于redis的setnx-zset-1">基于Redis的setnx、zset</a><ul>
<li><a href="#1-setnx">1. setnx</a></li>
<li><a href="#2-zset">2. zset</a></li>
</ul>
</li>
<li><a href="#漏桶算法-1">漏桶算法</a></li>
<li><a href="#令牌桶算法-1">令牌桶算法</a></li>
<li><a href="#细节流程大致">细节流程大致：</a></li>
</ul>
</li>
<li><a href="#常见知识点">常见知识点</a></li>
<li><a href="#redis一次性获取多条消息的命令">redis一次性获取多条消息的命令</a></li>
<li><a href="#为什么redis集群的最大槽数是16384个">为什么redis集群的最大槽数是16384个？</a></li>
<li><a href="#redis如果一个key特别大怎么办">redis如果一个key特别大怎么办</a><ul>
<li><a href="#bigkey-带来了什么危害">bigkey 带来了什么危害？</a></li>
<li><a href="#lazyfree机制过期异步删除">lazyfree机制(过期异步删除)</a></li>
<li><a href="#怎么处理">怎么处理</a><ul>
<li><a href="#删除bigkey">删除bigkey</a></li>
<li><a href="#拆分bigkey">拆分bigkey</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#如何保证数据库和redis的数据一致性先更新数据库再删除缓存先删除缓存再更新数据库这两个方法分别存在什么问题">如何保证数据库和Redis的数据一致性？先更新数据库再删除缓存/先删除缓存再更新数据库这两个方法分别存在什么问题？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h1><span id="redis">Redis</span></h1><p><strong>Redis(REmote DIctionary Server)是一个基于内存的高性能非关系型key-value数据库，它通常被称为数据结构服务器，因为值(value)可以是字符串(String), 哈希(Map), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。</strong></p>
<p>传统数据库遵循 <code>ACID</code> 规则。而 Nosql(Not Only SQL 的缩写)，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 <strong>CAP</strong> 定理。</p>
<p><strong>CAP定理</strong>(CAP theorem)，又被称作布鲁尔定理(Brewer’s theorem)，是分布式系统中的一个基本定理。<br>它指出任何分布式系统(Distributed System)中，最多具有一致性(Consistence)、可用性(Availability)、分区容错(Partition Tolerance)这三个特性中的两个。也就是说，三个特性无法兼顾，必须有所取舍。</p>
<ul>
<li>舍弃P(选择C/A)：单点的传统关系型数据库 DBMS(MySQL/Oracle)，但如果采用集群就必须考虑P了；</li>
<li>舍弃A(选择C/P)：是分布式系统要保证P，而且保证一致性，如 ZooKeeper / Redis / MongoDB / HBase；</li>
<li>舍弃C(选择A/P)：是分布式系统要保证P，而且保证可用性，如 CoachDB / Cassandra / DynamoDB。</li>
</ul>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于<strong>缓存</strong>，每秒可以处理超过 10 万次读写操作，是已知<strong>性能最快的 Key-Value 数据库</strong>。另外，Redis 也经常用来做分布式锁。除此之外，<strong>Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案</strong>。</p>
<p>同时 <code>Redis</code> 也支持事务，<code>Redis</code> 的所有操作都是原子性的，同时 <code>Redis</code> 还支持对几个操作合并后的原子性执行。</p>
<hr>
<h3><span id="redis常用的五种数据类型">Redis常用的五种数据类型</span></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicRdRFqeTHHLZZhV8HdQBzLZqIib0Rxx4dOpZaM8icQ0tf9U9ibBwpgPZAw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><code>Redis</code> 可以存储键和不同类型的值之间的映射。<strong>键的类型只能为字符串</strong>，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p><code>redis</code> 源码文件 <code>src/server.h</code> 中对于5种结构的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br></pre></td></tr></table></figure>
<p><code>Redis</code> 对象由 <code>redisObject</code> 结构体表示，从 <code>src/server.h</code>可以看到该结构的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;		<span class="comment">//对象类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">//对象编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; 	<span class="comment">//过期设置</span></span><br><span class="line">    <span class="keyword">int</span> refcount;			<span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;				<span class="comment">//内存指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p><code>redisObject</code> 明确了<strong>对象类型、对象编码方式、过期设置、引用计数、内存指针</strong>等，从而完整表示一个 <code>key-value</code> 键值对。</p>
<p>由于 <code>Redis</code> 是基于内存的，<code>Antirez</code> 在实现这5种数据类型时在底层创建了多种数据结构，在对象底层选择采用哪种结构来实现，需要根据对象大小以及单个元素大小来进行确定，从而提高空间使用率和效率。</p>
<h4><span id="string字符串">string字符串</span></h4><blockquote>
<p>适用于简单key-value存储、setnx key value实现分布式锁、计数器(原子性)、分布式全局唯一ID。</p>
</blockquote>
<p><strong>底层</strong>：<code>C</code> 语言中 <code>String</code> 用 <code>char[]</code> 数组表示，源码中用 <code>SDS</code> (simple dynamic string)封装 <code>char[]</code> ，这是是<code>Redis</code> 存储的<strong>最小单元</strong>，<strong>一个SDS最大可以存储512M信息</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7Diay6tbe99SxEdCbyfMItmJNEDgxQ3iayqmSyEZ8q6IIsibbNQJtP8AcQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ol>
<li><p><strong>字符串长度</strong></p>
<p>Redis 中怎么操作呢？用一个 <code>len</code> 字段记录当前字符串的长度。想要获取长度只需要获取 <code>len</code> 字段即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>空间预分配</strong>:</p>
<p>对 <code>SDS</code> 修改及空间扩充时，除了分配所必须的空间外，还会额外分配未使用的空间。</p>
<p>具体分配规则是这样的：<code>SDS</code> 修改后，<code>len</code> 长度小于 <code>1M</code>，那么将会额外分配与 <code>len</code> 相同长度的未使用空间。如果修改后长度大于 1M，那么将分配1M的使用空间。但是有大小限制，<code>redis</code> 中的字符串最大值是 <code>512m</code>。 <code>redis</code> 中采用<strong>这种冗余的预处理机制来扩容主要是为了防止频繁的内存申请，内存的分配是很浪费时间的。</strong></p>
</li>
<li><p><strong>惰性空间释放</strong></p>
<p><code>SDS</code> 是<code>惰性释放空间</code>的。<code>SDS</code> 缩短时，并不会回收多余的内存空间，而是使用 <code>free</code> 字段将多出来的空间记录下来。如果后续有变更操作，直接使用 <code>free</code> 中记录的空间，不用新申请空间，减少了内存的分配。</p>
</li>
<li><p><strong>二进制安全</strong></p>
<p><code>SDS</code> 类型是二进制安全的。意思是 <code>redis</code> 的 <code>string</code> 可以包含任何数据。比如 <code>jpg</code> 图片或者序列化对象 。二进制数据并不是规则的字符串格式，可能会包含一些特殊的字符，比如 <code>&#39;\0&#39;</code> 等。<code>C</code> 中字符串遇到 <code>&#39;\0&#39;</code> 会结束，那 <code>&#39;\0&#39;</code> 之后的数据就读取不上了。但在 <code>SDS</code> 中，是根据 <code>len</code> 长度来判断字符串结束的，二进制安全的问题就解决了。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个string // 可以同时两次set一个string，就是把它直接颠覆了，</span></span><br><span class="line"><span class="built_in">set</span> googege redis</span><br><span class="line"><span class="comment">// 得到一个string</span></span><br><span class="line">get googege</span><br><span class="line"><span class="comment">// 获取字符串的长度</span></span><br><span class="line"><span class="built_in">strlen</span> googege</span><br><span class="line"><span class="comment">// 对string做切片,getrange string fitst-index end-index</span></span><br><span class="line"><span class="comment">// 并且必须提供后面的两个起始和结束的index，否则报错。</span></span><br><span class="line">getrange googege <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="comment">// 覆盖字符串 setrange string first-index new string.</span></span><br><span class="line">setrange googege <span class="number">1</span> ddddddd</span><br><span class="line"><span class="comment">// 追加字符串 append string xxx</span></span><br><span class="line">append googege ttt</span><br></pre></td></tr></table></figure>
<p>当字符串是整数的时候，也可以将它当成<strong>计数器</strong>(<strong>原子性的</strong>)。</p>
<hr>
<h4><span id="list列表">list列表</span></h4><p><code>list</code> 的底层是一个双向链表，所以可以使用这个链表来实现 <code>queue</code> 或者 <code>stack</code> 的功能。查看源码底层 <code>adlist.h</code> 会发现底层就是个 <strong>双端链表</strong>，该链表最大长度为 <code>2^32 - 1</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>常用就这几个组合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush + lpop = <span class="built_in">stack</span> 先进后出的栈 </span><br><span class="line">lpush + rpop = <span class="built_in">queue</span> 先进先出的队列 </span><br><span class="line">lpush + ltrim = capped collection 有限集合</span><br><span class="line">lpush + brpop = message <span class="built_in">queue</span> 消息队列</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Redis brpop 命令移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
</blockquote>
<p><code>Redis</code> 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p><strong>在 key 对应 list 的头部添加字符串元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush name value</span><br></pre></td></tr></table></figure>
<p><strong>在 key 对应 list 的尾部添加字符串元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush name value</span><br></pre></td></tr></table></figure>
<p><strong>key 对应 list 中删除 count 个和 value 相同的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem name index</span><br></pre></td></tr></table></figure>
<p><strong>返回 key 对应 list 的长度</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen name</span><br></pre></td></tr></table></figure>
<p><strong>获取子链</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush aaa go rust dart2</span><br><span class="line">lindex aaa <span class="number">1</span> <span class="comment">// 获取aaa的第2个元素</span></span><br><span class="line">lrang aaa <span class="number">0</span> <span class="number">2</span> <span class="comment">// 获取子链</span></span><br><span class="line">lrang aaa <span class="number">0</span> <span class="number">-1</span> <span class="comment">// -的意思就是倒着数</span></span><br><span class="line"><span class="comment">// 遍历全部的数据</span></span><br><span class="line">lrang <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 这个时候使用-数不用使用llen了，也是极好的。</span></span><br></pre></td></tr></table></figure>
<p><strong>修改和插入元素</strong></p>
<p>插入数据不是根据的下标的顺序，因为 <code>redis</code> 经常用在分布式的环境中，那么分布式中的下标就没有意义了，所以特别的指定在某个元素后面或者前面插入xx元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush aa go java rust</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">lset aa <span class="number">1</span> t <span class="comment">// 变成了  go t rust</span></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">linsert aa before go tt<span class="comment">// tt go java rust</span></span><br><span class="line">linsert aa after go tt <span class="comment">// go tt java rust</span></span><br></pre></td></tr></table></figure>
<p> <strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpush aa go rust dd</span><br><span class="line">lrem aa <span class="number">1</span> go <span class="comment">// 删除的时候不仅仅要写出来个数还要写出来元素的值</span></span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="set集合">set集合</span></h4><p>这里 <code>set</code> 可以认为是没有 <code>Value</code> 的 <code>Dict</code> 。看源码 <code>t_set.c</code> 就可以了解本质了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the specified value into a set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the value was already member of the set, nothing is done and 0 is</span></span><br><span class="line"><span class="comment"> * returned, otherwise the new element is added and 1 is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        <span class="comment">//这里调用的还是dictAddRaw，只不过是把第三个参数dictEntry设置成null</span></span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>增加元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加元素sadd setname value value value value</span></span><br><span class="line">sadd y <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 读取元素 smembers 读取全部元素。 scard 获取set的长度 srandmember获取随机个数的元素，默认是1</span></span><br><span class="line">smembers y</span><br><span class="line">scard y</span><br><span class="line">srandmember y <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素 srem setname 1 2 3 4 删除必须指出来删除谁</span></span><br><span class="line">srem q <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 随机删除一个元素 spop setname</span></span><br><span class="line">spop q</span><br></pre></td></tr></table></figure>
<p><strong>判断元素是否存在</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否存在 sismember setname value</span></span><br><span class="line">sismember q <span class="number">43</span></span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="sorted-setzset有序集合">sorted set(Zset)有序集合</span></h4><p><code>zset</code> 实现的是有序集合，有序集合对象的编码可以是<strong>ziplist</strong>或者<strong>skiplist</strong>，<strong>在元素小于 <code>128</code> 并且元素长度小于<code>64Byte</code> 时</strong>才会选择<strong>ziplist</strong>实现，一般使用<strong>skiplist</strong>跳表实现。</p>
<p> <code>hash</code> 是关联元素 <code>key</code> 和权重（key和权重一一对应，其实相当于权重就是它的 <code>value</code> 值），<strong>跳表在于排序value 根据score范围查找元素。</strong>跳表包含一个表头，它查找数据时，是<strong>从上往下，从左往右</strong>进行查找。</p>
<p><code>ZSet</code> 结构同时包含一个字典和一个跳跃表，跳跃表按 <code>score</code> 从小到大保存所有集合元素。字典保存着从<code>member</code> 到 <code>score</code> 的映射。这两种结构通过指针共享相同元素的 <code>member</code> 和 <code>score</code> ，不会浪费额外内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaS8FxVXL1em0ozmuyF9fVu5OAGw7wIXDQbLxM1RU90m0a7H41HjT2pbkBicX0wnUYibicxumpchp3dQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7xgecNQ4nvH3PDdibyB4FVTVIq8VARFUy6sicxRoI7czmLib03DnNTmqCA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h5><span id="zset中跳表的实现细节">ZSet中跳表的实现细节</span></h5><ul>
<li><strong>随机层数的实现原理</strong></li>
</ul>
<p>跳表是一个<strong>概率型的数据结构</strong>，元素的插入层数是随机指定的。在论文中描述了它的计算过程如下：</p>
<ul>
<li><strong>指定节点最大层数 MaxLevel，指定概率 p， 默认层数 lvl 为1</strong> </li>
<li><strong>生成一个0~1的随机数r，若r&lt;p，且lvl&lt;MaxLevel ，则lvl ++</strong></li>
<li><strong>重复第 2 步，直至生成的r &gt;p 为止，此时的 lvl 就是要插入的层数。</strong></li>
</ul>
<p>论文中生成随机层数的伪码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaS8FxVXL1em0ozmuyF9fVuLlHpcCI2n0VyaAYiapcEPOZabutuZgh8iaR8LzSy7b59bfFrlybLvtYA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"><br>$$<br>p(level=1)=p^0(1-p)\<br>p(level=2)=p^1(1-p)^1\<br>p(level=3)=p^2(1-p)^1\<br>p(level=3)=p^3(1-p)^1\<br>…\<br>E(level)=1/1-p<br>$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，节点层数的期望值是 <strong>1 / 1 - p</strong>。</p>
<p><strong>增加删除数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd zsetname 权重 value 权重 value</span></span><br><span class="line">zadd u <span class="number">4.0</span> go </span><br><span class="line"><span class="comment">// 后面跟着的是权重</span></span><br><span class="line">zadd u <span class="number">4.0</span> go <span class="number">1.0</span> java</span><br><span class="line"><span class="comment">// 获取元素个数</span></span><br><span class="line">zcard q</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">//zrem zsetname value</span></span><br><span class="line">zrem u Java</span><br></pre></td></tr></table></figure>
<p><strong>计数器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd zsetname 权重 value</span></span><br><span class="line">zadd q <span class="number">4.0</span> python</span><br><span class="line"><span class="comment">// 获取排名和分数</span></span><br><span class="line">zscore q python</span><br><span class="line"><span class="comment">// zrank获取指定元素的正向排名</span></span><br><span class="line">zrank q python</span><br><span class="line"><span class="comment">// zrerank 反向排名</span></span><br></pre></td></tr></table></figure>
<p><strong>根据排名范围获取元素</strong> </p>
<p>这个原理主要是因为跳表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zrange q <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 获取所有数据</span></span><br><span class="line">zrange q <span class="number">0</span> <span class="number">-1</span> withscores <span class="comment">// 获取数据和他们的权重</span></span><br><span class="line">zrevrange q <span class="number">0</span> <span class="number">-1</span> <span class="comment">// 按照负的顺序去排名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据sore返回获取value</span></span><br><span class="line">zrangebysocre q <span class="number">0</span> <span class="number">5</span><span class="comment">// zrangebyscore zsetname 权重区间</span></span><br><span class="line">zrangebyscore q -inf + inf withscores <span class="comment">// -inf负无穷 +inf 正无穷</span></span><br></pre></td></tr></table></figure>
<p><strong>根据范围移除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangenyrank zsetname scorestart scoreend</span><br></pre></td></tr></table></figure>
<hr>
<h4><span id="hash哈希表">hash哈希表</span></h4><p>跟一般的 <code>hash table</code> 没有区别，使用 <code>哈希函数 + 数组 + 链表</code> 。</p>
<p>哈希函数算出值，然后加入到那个值对应的数组，然后数组中是一个链表，链表表示都是算出来的这个的值的kv结构（这个时候如果链表太长就意味着是hash碰撞了，这也是攻击手段的一种。）</p>
<p><strong>hash</strong>非常适用于将一些相关的数据存储在一起，比如用户的购物车。该类型在日常用途还是挺多的。</p>
<p>这里需要明确一点：<strong>Redis中只有一个K，一个V。其中 K 绝对是字符串对象，而 V 可以是String、List、Hash、Set、ZSet任意一种。</strong></p>
<p><code>hash</code> 的底层主要是采用字典 <code>dict</code> 的结构，整体呈现层层封装。从小到大如下：</p>
<ol>
<li><h5><span id="dictentry"><strong>dictEntry</strong>：</span></h5><p>真正的 <code>hash</code> 数据节点，包括 <code>key</code> ，<code>value</code> 和 <code>next</code> 节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
</li>
<li><h5><span id="dictht"><strong>dictht：</strong></span></h5><ol>
<li>数据 <code>dictEntry</code> 类型的数组，每个数组的 <code>item</code> 可能都指向一个链表。</li>
<li>数组长度 <code>size</code> 。</li>
<li><code>sizemask</code> 等于 <code>size - 1</code>。</li>
<li>当前 <code>dictEntry</code> 数组中包含总共多少节点。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRictDslPRoCZ9eo1Jyd1cI5TjGEKQ9zBpS7rKV1G1x0NHnrjqeA51NVWg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
</li>
<li><h5><span id="dict"><strong>dict</strong></span></h5><ol>
<li><code>dictType</code> 类型，包括一些自定义函数，这些函数使得 <code>key</code> 和 <code>value</code> 能够存储</li>
<li><code>rehashidx</code> 其实是一个标志量，如果为<code>-1</code>说明当前没有扩容，如果 <code>不为 -1</code> 则记录扩容位置。</li>
<li><code>dictht</code> 数组，两个 <code>Hash</code> 表。</li>
<li><code>iterators</code> 记录了当前字典正在进行中的迭代器</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
</li>
<li><h5><span id="渐进式扩容"><strong>渐进式扩容</strong></span></h5><p>为什么 <strong>dictht ht[2]</strong> 是两个呢？<strong>目的是在扩容的同时不影响前端的CURD</strong>，慢慢的把数据从 <code>ht[0]</code> 转移到<code>ht[1]</code> 中，同时 <code>rehashindex</code>来记录转移的情况，当全部转移完成，将 <code>ht[1]</code> 改成 <code>ht[0]</code> 使用。</p>
<p><code>rehashidx = -1</code> 说明当前没有扩容，<code>rehashidx != -1</code> 则表示扩容到数组中的第几个了。</p>
<p>扩容之后的数组大小为大于 <code>used*2</code> 的<strong>2的n次方</strong>的最小值，跟 <code>Hashmap</code> 类似。然后挨个遍历数组同时调整<code>rehashidx</code> 的值，对每个 <code>dictEntry[i]</code> 再挨个遍历链表将数据 <code>Hash</code> 后重新映射到 <code>dictht[1]</code> 里面。并且 <strong>dictht[0].use</strong> 跟 <strong>dictht[1].use</strong> 是动态变化的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicnAYFia6e6tnNjwW51AIibvibQKdicDKwOFmPDIUVOS5jobkj2iaTFX7bxfg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>整个过程的重点在于<strong>rehashidx</strong>，其为第一个数组正在移动的<strong>dictEntry</strong>下标位置，如果当前内存不够，或者操作系统繁忙，扩容的过程可以随时停止。</p>
<blockquote>
<p>停止之后如果对该对象进行操作，那是什么样子的呢？</p>
</blockquote>
<ol>
<li>如果是新增，则直接新增后第二个数组，因为如果新增到第一个数组，以后还是要移过来，没必要浪费时间</li>
<li>如果是删除，更新，查询，则先查找第一个数组，如果没找到，则再查询第二个数组。</li>
</ol>
</li>
</ol>
<p><strong>增加查询删除</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hset mapname key value 增加一个</span></span><br><span class="line">hset ui a b</span><br><span class="line"><span class="comment">// hmset mapnae key value key value 增加一堆</span></span><br><span class="line">hmset ui a b c d e f g h</span><br><span class="line"><span class="comment">// 获取一个key hget mapname key</span></span><br><span class="line">hget ui a</span><br><span class="line"><span class="comment">//获取一堆key value hmget mapname key key key</span></span><br><span class="line">hmget ui a c e h</span><br><span class="line"><span class="comment">// 获取全部k-v hgetall mapname</span></span><br><span class="line">hgetall ui</span><br><span class="line"><span class="comment">//获取全部key</span></span><br><span class="line">hkeys mapname</span><br><span class="line"><span class="comment">// 获取全部value</span></span><br><span class="line">hvals mapname</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">hdel mapname key key key</span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line"><span class="comment">// hexists mapname key</span></span><br><span class="line">hexists ui a <span class="comment">// 0表示不存在 1 表示存在</span></span><br></pre></td></tr></table></figure>
<p><strong>计数器hash</strong></p>
<p>每一个k-v都是一个独立的计数器</p>
<h5><span id="map的扩容">map的扩容</span></h5><p>当<code>hash</code> 碰撞太多的时候（时间复杂度已经从o(1)变成了o(n)）这个时候就该扩容了， 扩容的原则就是直接将数组扩大一倍，并且将各种数据从老的数组中转移到新的数组中；同时为了避免数据迁移带来的巨大损耗，<strong>redis是新旧同时保留，然后在后台使用一个定时的任务，以及hash读写指令，将数据逐步转移到新的数据结构中</strong>，新旧同时保留如何查找数据呢，其实只要在两个数组中都查查就行了。</p>
<hr>
<h4><span id="redis-geo-hash">Redis Geo Hash</span></h4><p>核心思想就是将地球近似为球体来看待，然后 <code>GEO</code> 利用 <code>GeoHash</code> 将二维的经纬度转换成字符串，来实现位置的划分跟指定距离的查询。(可以实现类似附近的餐厅的推荐功能)</p>
<h4><span id="hyperloglog">HyperLogLog</span></h4><p><code>HyperLogLog</code> 是一种<code>概率</code>数据结构，它使用概率算法来统计<strong>集合的近似基数</strong>。而它算法的最本源则是 <code>伯努利过程 + 分桶 + 调和平均数</code>。具体实现可看 <code>HyperLogLog</code> 讲解。</p>
<p><strong>功能</strong>：误差允许范围内做基数统计 (<strong>基数就是指一个集合中不同值的个数</strong>) 的时候非常有用，每个 <code>HyperLogLog</code> 的键可以计算接近<strong>2^64</strong>不同元素的基数，而大小只需要 <code>12KB</code> 。错误率大概在 <code>0.81%</code> 。所以如果用做 <code>UV</code> 统计很合适。</p>
<p><code>HyperLogLog</code> 底层 一共分了 <strong>2^14</strong> 个桶，也就是 <code>16384</code> 个桶。每个 <code>register</code> 桶中是一个 <code>6 bit</code> 的数组，这里有个骚操作就是一般人可能直接用一个字节当桶浪费 <code>2个bit</code> 空间，但是 <code>Redis</code> 底层只用 <code>6个</code> 然后通过前后拼接实现对内存用到了极致，最终就是 <code>16384*6/8/1024 = 12KB</code> 。</p>
<h4><span id="bitmap">Bitmap</span></h4><p><code>BitMap</code> 原本的含义是用一个比特位来映射某个元素的状态(二值状态)。由于一个比特位只能表示 <code>0</code> 和 <code>1</code> 两种状态，所以 <code>BitMap</code> 能映射的状态有限，但是使用比特位的优势是能大量的节省内存空间。</p>
<p>在 <code>Redis</code> 中 <code>BitMap</code> 底层是基于字符串类型实现的，可以把 <code>Bitmaps</code> 想象成一个以比特位为单位的数组，数组的每个单元只能存储 <code>0</code> 和 <code>1</code> ，数组的下标在 <code>Bitmaps</code> 中叫做偏移量，<code>BitMap</code> 的 <code>offset</code> 值上限 <strong>2^32 - 1</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic9gbIkzHhat4licrMDFto2EI9H4sv8fEib74SUZC90WP3YmsgibjoAjFiaA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ol>
<li>用户签到</li>
</ol>
<blockquote>
<p>key = 年份：用户id  offset = （今天是一年中的第几天） % （今年的天数）</p>
</blockquote>
<ol>
<li>统计活跃用户</li>
</ol>
<blockquote>
<p>使用日期作为 key，然后用户 id 为 offset 设置不同offset为0 1 即可。</p>
</blockquote>
<h4><span id="bloom-filter">Bloom Filter</span></h4><p>使用布隆过滤器得到的判断结果：<code>不存在的一定不存在，存在的不一定存在</code>。</p>
<p>布隆过滤器 原理：</p>
<blockquote>
<p>当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点(有效降低冲突概率)，把它们置为1。检索时，我们只要看看这些点是不是都是1就知道集合中有没有它了：如果这些点有任何一个为0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic4nG6bxaV4zdIpGjBqzdhicMicC8tqv3pyDNDXVg1tHZRyugicicVhrzX8w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<hr>
<h3><span id="redis持久化">Redis持久化</span></h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p><code>Redis</code> 提供了两种持久化方式：<code>RDB</code> (默认)和 <code>AOF</code></p>
<h4><span id="rdbredis-database-半持久化模式snapshotting快照">RDB(Redis DataBase) 半持久化模式/Snapshotting快照</span></h4><p><code>RDB</code> 持久化是指<strong>在指定的时间间隔内将内存中的数据集快照写入磁盘</strong>，实际操作过程是 <code>fork</code> 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。(<strong>半持久化模式，更适合做冷备</strong>)</p>
<ul>
<li><strong>优点：</strong><ul>
<li>压缩后的二进制文，<strong>适用于备份、全量复制</strong>，<strong>用于灾难恢复加载 <code>RDB</code> 恢复数据远快于 <code>AOF</code> 方式，适合大规模的数据恢复</strong>。</li>
<li>如果业务对数据完整性和一致性要求不高，<code>RDB</code> 是很好的选择。数据恢复比 <code>AOF</code> 快。因为 <code>RDB</code> 是数据的内存映射，直接载入到内存，而 <code>AOF</code> 是命令，需要逐条执行。</li>
<li>如果创建 <code>RDB</code> 文件时出现了错误，Redis不会将它用于替换原来的文件，所以出错时不会影响到之前保存的版本。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><code>RDB</code> 是<strong>周期间隔性的快照文件</strong>，数据的完整性和一致性不高，因为 <code>RDB</code> 可能在最后一次备份时宕机了。</li>
<li><strong>备份时占用内存</strong>，因为 <code>Redis</code> 在备份时会独立 <code>fork</code> 一个<strong>子进程</strong>，将数据写入到一个临时文件（<strong>此时内存中的数据是原来的两倍哦</strong>），<strong>最后再将临时文件替换之前的备份文件</strong>。所以要考虑到大概两倍的数据膨胀性。</li>
</ul>
</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png" alt="img"></p>
<p>功能核心函数<strong>rdbSave</strong>(生成RDB文件)和<strong>rdbLoad</strong>（从文件加载内存）两个函数</p>
<p><img src="https://www.redis.com.cn/images/riq1.png" alt="img"></p>
<h5><span id="手动触发以及copyonwrite">手动触发以及CopyOnWrite</span></h5><ol>
<li><code>SAVE</code> 直接调用 <code>rdbSave</code> ，<strong>阻塞Redis 主进程</strong>，导致无法提供服务，直到 <code>RDB</code> 文件创建完毕。</li>
<li><code>BGSAVE</code> 则 <code>fork</code> 出一个子进程，子进程负责调用 <code>rdbSave</code> ，在保存完成后向主进程发送信号告知完成。在<code>BGSAVE</code> 执行期间<strong>仍可以继续处理客户端的请求</strong>。</li>
<li><code>Copy On Write</code> 机制，备份的是开始那个时刻内存中的数据，只复制被修改内存页数据，不是全部内存数据。<code>Copy On Write</code> 时如果父子进程大量写操作会导致分页错误。</li>
</ol>
<hr>
<h4><span id="aofappend-only-file-全持久化模式">AOF(Append-only file) 全持久化模式</span></h4><p>每当执行服务器(定时)任务或者函数时<strong>flushAppendOnlyFile</strong> 函数都会被调用，把每一次数据变化都写入到一个<strong>append only file(aof)</strong>里面。  由于该机制对日志文件的写入操作采用的是 <code>append</code> 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。因为这个模式是<strong>只追加</strong>的方式，所以没有任何磁盘寻址的开销，所以很快，有点像 <code>Mysql</code> 中的 <code>binlog</code> 。<strong>AOF更适合做热备</strong>。</p>
<ul>
<li><strong>优点：</strong><ul>
<li><code>AOF</code> 是一秒一次去通过一个后台的线程 <code>fsync</code> 操作，数据丢失不用怕。(适合热备)</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>对于相同数量的数据集而言，<code>AOF</code> 文件通常要大于 <code>RDB</code> 文件。<code>RDB</code> 在<strong>恢复</strong>大数据集时的速度比 <code>AOF</code> 的恢复速度要快。</li>
<li>根据同步策略的不同，<code>AOF</code> 在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的。</li>
</ul>
</li>
</ul>
<p>在 <code>Redis</code> 的配置文件中存在三种<strong>同步方式</strong>，它们分别是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append only defines */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_FSYNC_NO 0			<span class="comment">//每次有数据修改发生时都会写入AOF文件。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_FSYNC_ALWAYS 1		<span class="comment">//每秒钟同步一次，该策略为AOF的缺省策略。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_FSYNC_EVERYSEC 2	<span class="comment">//从不同步。高效但是数据不会被持久化。</span></span></span><br></pre></td></tr></table></figure>
<p><code>AOF</code> 是通过调用 <code>BIO(background IO)</code> 来实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Starts a background task that performs fsync() against the specified</span></span><br><span class="line"><span class="comment"> * file descriptor (the one of the AOF file) in another thread. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aof_background_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    bioCreateBackgroundJob(BIO_AOF_FSYNC,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>redis.conf</code> 中的 <strong>appendfysnc</strong> 是对 <code>redis</code> 性能有重要影响的参数之一。可取三种值：<code>always</code> 、<code>everysec</code> 和 <code>no</code> 。</p>
<ul>
<li>设置为 <code>always</code> 时，会极大消弱 <code>Redis</code> 的性能，因为这种模式下每次 <code>write</code> 后都会调用 <code>fsync</code> （ <code>Linux</code> 为调用 <code>fdatasync</code> ）。</li>
<li>如果设置为 <code>no</code> ，则 <code>write</code> 后不会有 <code>fsync</code> 调用，<strong>由操作系统自动调度刷磁盘，性能是最好的</strong>。</li>
<li><code>everysec</code> 为<strong>最多每秒调用一次fsync</strong>，这种模式性能并不是很糟糕，一般也不会产生毛刺，<strong>这归功于Redis引入了BIO线程，所有fsync操作都异步交给了BIO线程。</strong></li>
</ul>
<hr>
<h5><span id="aof整个流程分两步"><strong>AOF整个流程分两步</strong>：</span></h5><ul>
<li>第一步是命令的<strong>实时写入</strong>(<strong>aofWrite</strong>)和<strong>磁盘同步(aof_background_fsync)</strong>，不同级别可能有1秒数据损失。命令先追加到 <code>aof_buf</code>然后再同步到AO磁盘，<strong>如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能</strong>。</li>
<li>第二步是对 <code>aof</code> 文件的<strong>重写</strong>，目的是为了减少 <code>AOF</code> 文件的大小，可以自动触发或者手动触发(<strong>BGREWRITEAOF</strong>)，是 <code>Fork</code> 出子进程操作，期间 <code>Redis</code> 服务仍可用。</li>
</ul>
<ol>
<li><strong>实时写入和磁盘同步</strong>：<code>Redis</code> 在处理一条命令时，并不立即调用 <code>write</code> 写 <code>AOF</code> 文件，只是将数据写入到 <code>AOF buffer</code>（server.<strong>aof_buf</strong>）中。调用 <code>write</code> 和命令处理是分开的，<code>Redis</code> 只在每次进入 <code>epoll_wait</code> 之前做<code>write</code> 操作。具体来说，写入AOF文件的步骤是在 void <strong>flushAppendOnlyFile</strong>(int force) 中： </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br></pre></td></tr></table></figure>
<p>​    然后再根据 <code>fsync</code> 的频率 <code>config</code> 条件，调用 <code>fsync</code> 或 <code>fdatasync</code> 函数，将 <code>AOF</code> 文件同步到磁盘中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">try_fsync:</span><br><span class="line"><span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></span><br><span class="line"><span class="comment">     * children doing I/O in the background. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; hasActiveChildProcess())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Perform the fsync if needed. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">    <span class="comment">/* redis_fsync is defined as fdatasync() for Linux in order to avoid</span></span><br><span class="line"><span class="comment">         * flushing metadata. */</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    redis_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"aof-fsync-always"</span>,latency);</span><br><span class="line">    server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">    server.aof_last_fsync = server.unixtime;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">            server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sync_in_progress) &#123;</span><br><span class="line">        <span class="comment">// eversec性能并不那么糟糕，因为它：</span></span><br><span class="line">        <span class="comment">// 后台方式执行fsync</span></span><br><span class="line">        <span class="comment">// Redis并不是严格意义上的单线程，实际上它创建一组BIO线程，专门处理阻塞和慢操作</span></span><br><span class="line">        <span class="comment">// 这些操作就包括FSYNC，另外还有关闭文件和内存的free两个操作。</span></span><br><span class="line">        <span class="comment">// 不像always模式，EVERYSEC模式并不立即调用fsync，</span></span><br><span class="line">        <span class="comment">// 而是将这个操作丢给了BIO线程异步执行，</span></span><br><span class="line">        <span class="comment">// BIO线程在进程启动时被创建，两者间通过bio_jobs和bio_pending两个</span></span><br><span class="line">        <span class="comment">// 全局对象交互，其中主线程负责写，BIO线程负责消费。</span></span><br><span class="line">        aof_background_fsync(server.aof_fd);</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">    &#125;</span><br><span class="line">    server.aof_last_fsync = server.unixtime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>ReWrite</strong>：第二步是对 <code>aof</code> 文件的<strong>重写</strong>，目的是为了减少 <code>AOF</code> 文件的大小，可以<strong>自动触发</strong>或者<strong>手动触发</strong>(<strong>BGREWRITEAOF</strong>)，是 <code>fork</code> 出子进程然后在<strong>background</strong>进行操作，期间 <code>Redis</code> 服务仍可用。</p>
<blockquote>
<p>通过该功能，Redis服务器可以创建一个新的AOF文件替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态完全相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF会比旧AOF文件体积小很多。<strong>主要思想是，从数据库中读取出键现在的值，然后用一条命令去记录键值对，替代之前记录这个键值对的多条命令，这个就是AOF重写功能的实现原理。</strong></p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic8YDTXRLm1sPmRWOlEG8gKNBQj5LHicgaQmIibxXHOluSe10MR9Yo7KuQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ol>
<li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；为了解决数据不一致的问题，<code>Redis</code> 服务器设置了一个<strong>aof_rewrite_buf</strong>，这个缓冲区在服务器创建子进程的时候开始使用，当 <code>redis</code> 主进程响应了一个操作的时候，它会同时将命令发送到 <code>AOF</code> 缓存区 <strong>aof_buf</strong>和 <code>AOF</code> 重写缓存区<strong>aof_rewrite_buf</strong>。从而防止新写的 <code>file</code> 丢失数据。</li>
<li>当子进程完成 <code>AOF</code> rewrite的工作后，会向父进程发送一个信号，父进程会调用一个信号处理函数，然后：<ol>
<li>将<strong>aof_rewrite_buf</strong>中的所有内容写到新的 <code>AOF</code> 的临时文件中，这时 <code>AOF</code> 文件所保存的数据库状态与当前数据库状态一致。</li>
<li>对新的 <code>AOF</code> 文件进行改名，<strong>原子</strong>地覆盖现有 <code>AOF</code> 文件，完成新旧两个 <code>AOF</code> 文件的替换。</li>
</ol>
</li>
<li>重写是直接把<code>当前内存的数据生成对应命令</code>，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li><strong>无论是 RDB 还是 AOF 都是先写入一个临时文件，然后通过rename完成文件的替换工作</strong>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is how rewriting of the append only file in background works:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) The user calls BGREWRITEAOF</span></span><br><span class="line"><span class="comment"> * 2) Redis calls this function, that forks():</span></span><br><span class="line"><span class="comment"> *    2a) the child rewrite the append only file in a temp file.</span></span><br><span class="line"><span class="comment"> *    2b) the parent accumulates differences in server.aof_rewrite_buf.</span></span><br><span class="line"><span class="comment"> * 3) When the child finished '2a' exists.</span></span><br><span class="line"><span class="comment"> * 4) The parent will trap the exit code, if it's OK, will append the</span></span><br><span class="line"><span class="comment"> *    data accumulated into server.aof_rewrite_buf into the temp file, and</span></span><br><span class="line"><span class="comment"> *    finally will rename(2) the temp file in the actual file name.</span></span><br><span class="line"><span class="comment"> *    The the new file is reopened as the new append only file. Profit!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    openChildInfoPipe();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork(CHILD_TYPE_AOF)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">"redis-aof-rewrite"</span>);</span><br><span class="line">        redisSetCpuAffinity(server.aof_rewrite_cpulist);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-rewriteaof-bg-%d.aof"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_TYPE_AOF, <span class="string">"AOF rewrite"</span>);</span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Can't rewrite append only file in background: fork: %s"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            aofClosePipes();</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Background append only file rewriting started by pid %d"</span>,childpid);</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        <span class="comment">/* We set appendseldb to -1 in order to force the next call to the</span></span><br><span class="line"><span class="comment">         * feedAppendOnlyFile() to issue a SELECT command, so the differences</span></span><br><span class="line"><span class="comment">         * accumulated by the parent into server.aof_rewrite_buf will start</span></span><br><span class="line"><span class="comment">         * with a SELECT statement and it will be safe to merge. */</span></span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>关于 <code>Fork</code> 的建议：</p>
<blockquote>
<p>1、降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</p>
<p>2、控制Redis最大使用内存，防止fork耗时过长；</p>
<p>3、配置牛逼点，合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</p>
<p>4、Redis在执行<code>BGSAVE</code>和<code>BGREWRITEAOF</code>命令时，哈希表的负载因子&gt;=5，而未执行这两个命令时&gt;=1。目的是<strong>尽量减少写操作</strong>，避免不必要的内存写入操作。</p>
<p>5、<strong>哈希表的扩展因子</strong>：哈希表已保存节点数量 / 哈希表大小。因子决定了是否扩展哈希表。</p>
</blockquote>
<hr>
<h4><span id="恢复">恢复</span></h4><p>启动时会先检查 <code>AOF</code> (数据更完整)文件是否存在，如果不存在就尝试加载 <code>RDB</code> 。既然单独用 <code>RDB</code> 会丢失很多数据。单独用 <code>AOF</code> ，数据恢复没 <code>RDB</code> 来的快，<strong>所以出现问题了第一时间用 <code>RDB</code> 恢复，然后 <code>AOF</code> 做数据补全才是王道。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicFRKa0t7iciaRP0Tm4ogjUUc65RoGZC0VAdicBWrFiboofwNujkPJIPB4hg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<hr>
<h4><span id="存储结构">存储结构</span></h4><p>持久化存储的内容是 <code>redis</code> 通讯协议( <code>RESP(Redis Serialization Protocol)</code>  )格式的命令文本存储。<code>RESP</code> 是 <code>redis</code> 客户端和服务端之前使用的一种<strong>基于TCP的应用层协议通讯协议</strong>；</p>
<p><code>RESP</code> 的特点：<strong>实现简单、快速解析、可读性好</strong></p>
<p>协议如下：</p>
<ul>
<li><strong>客户端以规定格式的形式发送命令给服务器；</strong></li>
<li><strong>服务器在执行最后一条命令后，返回结果。</strong></li>
</ul>
<ol>
<li><strong>简单字符串</strong> (<strong>Simple Strings</strong>), 以 “+”加号 开头</li>
</ol>
<p>​      格式：<strong>+</strong> 字符串 \r\n  。字符串不能包含 CR或者 LF(不允许换行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg: &quot;+OK\r\n&quot;</span><br></pre></td></tr></table></figure>
<p>​      注意：为了发送二进制安全的字符串，一般推荐使用后面的 <strong>Bulk Strings</strong> 类型</p>
<ol start="2">
<li><strong>错误</strong>( <strong>Errors)</strong>, 以”<strong>-</strong>“减号 开头</li>
</ol>
<p>　　格式：- 错误前缀 错误信息 \r\n 。错误信息不能包含 CR或者 LF(不允许换行)，Errors与Simple Strings很相似，不同的是Erros会被当作异常来看待</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg: &quot;-Error unknow command &apos;foobar&apos;\r\n&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>整数型</strong> (<strong>Integer</strong>)， 以 “:” 冒号开头。格式 : 数字 \r\n</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg: &quot;:1000\r\n&quot;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>大字符串类型</strong> (<strong>Bulk Strings</strong>), 以 “$”美元符号开头，长度限制512M</li>
</ol>
<p>　　格式：<code>$ 字符串的长度 \r\n 字符串 \r\n</code>  字符串不能包含 CR或者 LF(不允许换行);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg: **&quot;$6\r\nfoobar\r\n&quot;**    其中字符串为 foobar，而6就是foobar的字符长度</span><br><span class="line">&quot;$0\r\n\r\n&quot;       			  空字符串</span><br><span class="line">&quot;$-1\r\n&quot;           		  null</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>数组类型</strong> (<strong>Arrays</strong>)，以 “*“星号开头。格式：<code>* 数组元素个数 \r\n 其他所有类型 (结尾不需要\r\n)</code></li>
</ol>
<p>​             注意：只有元素个数后面的\r\n是属于该数组的，结尾的\r\n一般是元素的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg: &quot;*0\r\n&quot;      									  空数组</span><br><span class="line">	&quot;*2\r\n2\r\nfoo\r\n2\r\nfoo\r\n3\r\nbar\r\n&quot;      数组包含2个元素，分别是字符串foo和bar</span><br><span class="line">	&quot;*3\r\n:1\r\n:2\r\n:3\r\n&quot;       				  数组包含3个整数：1、2、3</span><br><span class="line">	&quot;*5\r\n:1\r\n:2\r\n:3\r\n:4\r\n$6\r\nfoobar\r\n&quot;  包含混合类型的数组</span><br><span class="line">	&quot;*-1\r\n&quot;         								  Null数组</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="redis架构模式集群高可用">Redis架构模式/集群高可用</span></h3><h4><span id="1-单机版">1. 单机版</span></h4><p><strong>内存容量有限/处理能力有限/无法高可用。</strong></p>
<p><img src="https://www.redis.com.cn/images/riq3.png" alt="img"></p>
<h4><span id="2-主从复制">2. 主从复制</span></h4><p><img src="https://www.redis.com.cn/images/riq4.png" alt="img"></p>
<p><code>Redis</code> 的复制(replication)功能允许用户根据一个 <code>Redis</code> 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将<strong>发生在自己身上的数据更新同步给从服务器</strong>，从而<strong>一直保证主从服务器的数据相同</strong>。</p>
<p>持久化保证了即使 <code>redis</code> 服务重启也不会丢失数据，因为 <code>redis</code>服务重启后会将硬盘上持久化的数据恢复到内存中，但是当 <code>redis</code> 服务器的<strong>硬盘损坏</strong>了可能会导致数据丢失，如果通过redis的主从复制机制就可以<strong>避免这种单点故障</strong></p>
<p>主从复制具有<strong>高可用性且读写分离</strong>的特点， 会采用 <code>增量同步</code> 跟 <code>全量同步</code> 两种机制。</p>
<h5><span id="全量同步">全量同步</span></h5><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicAhskdG8GFVN7KosOFbKyb57I1NbY5dp0YGre7g9Sib13kcNacntAt1Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><code>Redis</code> 全量复制一般发生在<strong>Slave初始化阶段</strong>，这时 <code>Slave</code> 需要将 <code>Master</code> 上的<strong>所有数据</strong>都复制一份：</p>
<ol>
<li><p>slave连接master，发送 <code>psync</code> 命令。</p>
</li>
<li><p>master接收到 <code>psync</code> 命名后，开始执行 <code>bgsave</code> 命令生成 <code>RDB</code> 文件并使用缓冲区记录此后执行的所有写命令。</p>
</li>
<li><p>master发送快照文件到slave，并在发送期间继续记录被执行的写命令。</p>
</li>
<li>slave收到快照文件后丢弃所有旧数据，载入收到的快照。</li>
<li>master快照发送完毕后开始向slave发送缓冲区中的写命令。</li>
<li>slave完成对快照的载入，开始接收命令请求，并执行来自master缓冲区的写命令。</li>
</ol>
<h5><span id="增量同步">增量同步</span></h5><p>也叫<strong>指令同步</strong>，就是<strong>从库重放在主库中进行的指令</strong>。<code>Redis</code> 会把指令存放在一个<strong>环形队列</strong>当中，因为内存容量有限，如果备机一直起不来，不可能把所有的内存都去存指令，也就是说，如果备机一直未同步，<strong>指令可能会被覆盖掉。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicHaIXZDQYwicxrdF0LZQ7KsbYnRZzEqk77iaXicf41GJcvwhv77nRgGspg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><code>Redis</code> 增量复制是指 <code>Slave</code> 初始化后开始正常工作时，<strong><code>master</code> 发生的写操作同步到 <code>slave</code> 的过程</strong>。增量复制的过程主要是<strong>master每执行一个写命令就会向slave发送相同的写命令</strong>。</p>
<h5><span id="redis主从同步策略"><strong>Redis主从同步策略</strong></span></h5><ol>
<li><strong>主从刚刚连接的时候，进行全量同步</strong>；<strong>全同步结束后，进行增量同步</strong>。当然，如果有需要，<strong>slave 在任何时候都可以发起全量同步</strong>。<code>redis</code> 策略是，无论如何，<strong>首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</strong></li>
<li>slave在同步master数据时候如果slave丢失连接不用怕，slave在重新连接之后 <code>丢失重补</code>。</li>
<li>一般<strong>通过主从来实现读写分离</strong>，但是如果master挂掉后如何保证Redis的高可用呢？引入 <code>Sentinel哨兵</code> 进行master的选择。</li>
</ol>
<p><strong>复制是高可用Redis的基础</strong>，哨兵和集群都是在复制基础上实现高可用的。</p>
<ul>
<li>复制主要实现了数据的多机备份，以及<strong>对于读操作的负载均衡和简单的故障恢复</strong>。</li>
<li>缺陷：<ul>
<li>故障恢复无法自动化；</li>
<li>写操作无法负载均衡；</li>
<li>存储能力受到单机的限制。</li>
</ul>
</li>
</ul>
<p><strong>特点：</strong></p>
<ol>
<li><strong>master/slave</strong> 角色</li>
<li><strong>master/slave</strong> 数据相同</li>
<li>降低 <strong>master</strong> <strong>读</strong>压力在转交从库</li>
</ol>
<p><strong>问题：</strong></p>
<ol>
<li>无法保证<strong>高可用</strong></li>
<li>没有解决 <code>master</code> <strong>写的压力</strong></li>
</ol>
<hr>
<h4><span id="3-哨兵">3. 哨兵</span></h4><p><img src="https://www.redis.com.cn/images/riq5.png" alt="img"></p>
<p><strong>Redis sentinel</strong> 是一个分布式系统中监控 <code>redis</code> 主从服务器，并在主服务器下线时自动进行故障转移。<code>Redis-sentinel</code>  本身是一个<strong>独立</strong>运行的进程，一般 <code>sentinel</code> 集群 节点数至少三个且奇数个，它能监控多个 <code>master-slave</code> 集群，<code>sentinel</code> 节点发现 <code>master</code> 宕机后能进行自动切换。</p>
<h5><span id="三个特性">三个特性：</span></h5><ol>
<li><strong>集群监控(Monitoring)</strong>：<strong>Sentinel</strong> 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>消息通知(Notification)</strong>：当被监控的某个 <strong>Redis</strong> 服务器出现问题时， <strong>Sentinel</strong> 可以通过 <strong>API</strong> 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移(Automatic failover)</strong>：当一个主服务器不能正常工作时， <strong>Sentinel</strong> 会开始一次自动故障迁移操作。</li>
<li><strong>配置中心</strong>：如果故障转移发生了，通知 <code>client</code> 客户端新的 <code>master</code> 地址。</li>
</ol>
<p><strong>特点：</strong></p>
<ol>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>主从模式，切换需要时间丢数据</li>
<li>没有解决 <code>master</code> <strong>写的压力</strong></li>
</ol>
<p><strong>哨兵机制的原理</strong></p>
<p>通过 <code>sentinel</code> 模式启动 <code>redis</code> 后，自动监控 <code>master/slave</code> 的运行状态，基本原理是：<strong>心跳机制+投票裁决(raft)</strong>。</p>
<p>每个 <code>sentinel</code> 会向其它 <code>sentinal</code> 、<code>master</code> 、<code>slave</code> 定时发送消息，以确认对方是否活着，如果发现对方在指定时间内未回应，则暂时认为对方<strong>宕机</strong>。</p>
<p>若<strong>哨兵群中的多数</strong> <code>sentinel</code> 都报告某一 <code>master</code> 没响应，系统才认为该 <code>master</code> 真正宕机，通过 <strong>Raft投票算法</strong>，从剩下的 <code>slave</code> 节点中，选一台提升为 <code>master</code> ，然后自动修改相关配置。</p>
<hr>
<h4><span id="4-集群proxy型">4. 集群(proxy型)</span></h4><p><img src="https://www.redis.com.cn/images/riq6.png" alt="img"></p>
<h4><span id="5-集群直连型">5. 集群(直连型)</span></h4><p><img src="https://www.redis.com.cn/images/riq7.png" alt="img"></p>
<p>从redis 3.0之后版本支持<strong>redis-cluster</strong>集群，<strong>Redis-Cluster</strong>采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<h5><span id="分区规则">分区规则</span></h5><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic9kicG37hoLHYI5rgokUdyjoqmicB7nxdHvibZg0Vtictsm6GJwIkGgILnQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>常见的分区规则有下面三种</p>
<ol>
<li><strong>节点取余</strong>：<code>hash(key) % N</code></li>
<li><strong>一致性哈希</strong>：一致性哈希环</li>
<li><strong>虚拟槽哈希</strong>：<code>CRC16[key] &amp; 16383</code></li>
</ol>
<p><strong>Redis Cluster</strong>采用了<code>虚拟槽分区</code>方式，具题的实现细节如下：</p>
<ol>
<li>采用去<strong>中心化</strong>的思想，它使用<strong>虚拟槽slot分区</strong>覆盖到所有节点上，取数据一样的流程，节点之间使用轻量协议通信 <strong>Gossip</strong> 来减少带宽占用，所以性能很高</li>
<li>自动实现<strong>负载均衡与高可用</strong>，自动实现<strong>failover</strong>并且支持<strong>动态扩展</strong>，官方已经玩到可以1000个节点，实现的复杂度低。</li>
<li>每个 <code>Master</code> 也需要配置主从，并且内部也是采用<strong>哨兵模式</strong>，如果有半数节点发现某个异常节点会共同决定更改异常节点的状态。</li>
<li>如果集群中的 <code>master</code> 没有 <code>slave</code> 节点，则 <code>master</code> 挂掉后整个集群就会进入<strong>fail</strong>状态，因为集群的 <code>slot</code> 映射不完整。<strong>如果集群超过半数以上的master挂掉，集群都会进入fail状态</strong>。</li>
<li>官方推荐 <strong>集群部署至少要3台以上的master节点</strong>。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicdt9GcFtcd23aQ02J1AaoIvd9Sp1bNMgL6rf5iaTiaP3reNUhutVJ49sw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h5><span id="特点">特点</span></h5><ol>
<li><strong>无中心架构</strong>（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li><strong>多节点分布</strong>：数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li><strong>可扩展性</strong>，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li><strong>高可用性</strong>，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</li>
<li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，<strong>用投票机制完成 Slave到 Master 的角色提升。</strong></li>
</ol>
<h5><span id="缺点">缺点</span></h5><ol>
<li>资源<strong>隔离性较差</strong>，容易出现相互影响的情况。</li>
<li>数据通过<strong>异步复制，不保证数据的强一致性</strong></li>
</ol>
<hr>
<h3><span id="redis-限流">Redis 限流</span></h3><h4><span id="基于redis的setnx-zset">基于Redis的setnx、zset</span></h4><h4><span id="漏桶算法">漏桶算法</span></h4><h4><span id="令牌桶算法">令牌桶算法</span></h4><hr>
<h3><span id="redis是单线程的但redis为什么这么快">Redis是单线程的，但Redis为什么这么快？</span></h3><h4><span id="基于内存实现">基于内存实现</span></h4><p><code>Redis</code> 是基于内存的操作，<strong><code>CPU</code> 不是 <code>Redis</code> 的瓶颈</strong>，<code>Redis</code> 的瓶颈最有可能是<strong>机器内存的大小或者网络带宽</strong>。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了，毕竟采用多线程会有很多麻烦。Redis采用单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用<strong>setnx</strong>实现锁。</p>
<h4><span id="高效的数据结构">高效的数据结构</span></h4><p><code>Redis</code> 中有多种数据类型，每种数据类型的底层都由一种或多种数据结构来支持。正是因为有了这些数据结构，<code>Redis</code> 在存储与读取上的速度才不受阻碍。比如 <code>HyperLogLog</code> 它连2个字节都不想浪费。</p>
<ol>
<li><p><strong>简单动态字符串</strong></p>
<p>如上</p>
</li>
<li><p><strong>压缩链表</strong></p>
<p>双端链表我们已经熟悉了。不知道你有没有注意到一个问题：如果在一个链表节点中存储一个小数据，比如一个字节。那么对应的就要保存头节点，前后指针等额外的数据。这样就浪费了空间，同时由于反复申请与释放也容易导致内存碎片化。这样内存的使用效率就太低了。</p>
<p>于是，压缩列表上场了！压缩链表是一种专门为了提升内存使用效率而设计的，经过特殊编码的双端链表数据结构。 既可以用来保存<strong>整形数值</strong>，也可以用来保存<strong>字符串数值</strong>，为了节约内存，同时也是体现压缩之含义， 当保存一个整形数值时，压缩链表会使用一个真正的整形数来保存，而不是使用字符串的形式来存储。 这一点很容易理解，一个整数可以根据其数值的大小使用1个字节，2个字节，4个字节或者8个字节来表示， 如果使用字符串的形式来存储的话，其所需的字节数大小一定不小于使用整形数所需的字节数。</p>
<p><strong>有序集合ZSet对象的底层数据结构可以是ziplist或者skiplist，在元素小于128并且元素长度小于64Byte时才会选择压缩列表实现，一般使用skiplist跳表实现。</strong></p>
<p>压缩链表允许在链表两端以 <em>O(1)</em> 的时间复杂度执行 <em>Pop</em> 或者 <em>Push</em> 操作，当然这只是一种理想状态下的情况， 由于压缩链表实际上是内存中一段连续分配的内存，因此这些操作需要对压缩链表所使用的内存进行重新分配， 所以其真实的时间复杂度是和链表所使用的内存大小相关的。</p>
<p><strong>压缩链表的内存分布</strong></p>
<p>压缩链表与经典双端链表最大的区别在于，双端链表的节点是分散在内存中并不是连续的，压缩链表中所有的数据都是存储在一段连续的内存之中的，</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7WIOWyzXHCzPhr4bNJzH3QdYF8R4v27XuIWCqsg8PWGCGg39lTIe3LA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<ul>
<li><strong>zlbytes</strong>：该字段固定是一个四字节的无符号整数，用于表示整个压缩链表所占用内存的长度（以字节为单位），这个长度数值是包含这个<code>&lt;zlbytes&gt;</code>本身的。</li>
<li><strong>ztail</strong>：该字段固定是一个四字节的无符号整数，用于表示在链表中最后一个节点的偏移字节量，借助这个字段，我们不需要遍历整个链表便可以在链表尾部执行<em>Pop</em>操作。</li>
<li><strong>zllen</strong>：该字段固定是一个两个字节的无符号整数，用于表示链表中节点的个数。但是该字段最多只能表示<code>2^16-2</code>个节点个数；超过这个数量，也就是该字段被设置为<code>2^16-1</code>时， 意味着我们需要遍历整个链表，才可以获取链表中节点真实的数量。</li>
<li><strong>entry</strong>：该字段表示链表中的一个节点，同一个链表中的节点，其长度大概率是不同的，因此需要特殊的方式来获取节点的长度，具体的内容会在下一个部分详细介绍。</li>
<li><strong>zlend</strong>：该字段可以被认为是一个特殊的<code>&lt;entry&gt;</code>节点，用作压缩链表的结束标记，只有一个字节，存储着<code>0xFF</code>，一旦我们遍历到这个特殊的标记，便意味着我们完成了对这个压缩链表的遍历。</li>
</ul>
</li>
</ol>
<h4><span id="合理的数据编码">合理的数据编码</span></h4><p><code>Redis</code> 底层提供了丰富而合理的编码，五种数据类型根据长度及元素的个数适配不同的编码格式。</p>
<ul>
<li><strong>String</strong>：存储数字的话，采用int类型的编码，如果是非数字的话，采用 raw 编码；</li>
<li><strong>List</strong>：字符串长度及元素个数小于一定范围使用 ziplist 编码，任意条件不满足，则转化为 linkedlist 编码；</li>
<li><strong>Hash</strong>：hash 对象保存的键值对内的键和值字符串长度小于一定值及键值对；</li>
<li><strong>Set</strong>：保存元素为整数及元素个数小于一定范围使用 intset 编码，任意条件不满足，则使用 hashtable 编码；</li>
<li><strong>Zset</strong>：zset 对象中保存的元素个数小于及成员长度小于一定值使用 ziplist 编码，任意条件不满足，则使用 skiplist 编码。</li>
</ul>
<h4><span id="合适的线程模型">合适的线程模型</span></h4><p>Redis 快的原因还有一个是因为使用了合适的线程模型：</p>
<ol>
<li><p>采用单线程，<strong>避免了不必要的上下文切换和竞争条件</strong>，也<strong>不存在多进程或者多线程导致的切换而消耗 CPU</strong>，<strong>不用去考虑各种锁的问题</strong>，<strong>不存在加锁释放锁操作</strong>，<strong>没有因为可能出现死锁而导致的性能消耗</strong>；<code>Redis</code> 中使用了 <code>Reactor</code> 单线程模型，接收到用户的请求后，全部推送到一个队列里，然后交给<strong>文件事件分派器</strong>，而它是单线程的工作方式。<code>Redis</code> 又是基于它工作的，所以说 <code>Redis</code> 是单线程的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7j3SxhEXDibAdYCbYm28oUqFSbsFuJav9yGBNyoYbLl730vnc5YUyzqg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
</li>
<li><p>使用多路I/O复用模型，非阻塞IO；<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</strong>非阻塞IO 内部实现采用 <code>epoll</code> ，采用了 <code>epoll</code> +自己实现的简单的事件框架。<code>epoll</code> 中的读、写、关闭、连接都转化成了事件，然后利用 <code>epoll</code> 的多路复用特性，绝不在io上浪费一点时间。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicKADFgJeRqx92JxQLGicLfm6QaicJRc6fO1DFx02MuBUM3Jarl8XP5eLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
</li>
</ol>
<hr>
<h3><span id="redis60后引入多线程提速">Redis6.0后引入多线程提速</span></h3><p>其实严格意义上来讲，<code>Redis</code> 并不是单线程。它也有后台线程在工作，处理一些较为缓慢的操作，例如无用连接的释放、大key的删除等等。但是客户端命令的请求获取( <code>socket</code> 读)、解析、执行、内容返回( <code>socket</code> 写)等等都是由一个线程处理，所有操作是一个个挨着串行执行的(主线程)，这也是 <code>Redis</code> 有“单线程”定义的来源。单线程机制使得 <code>Redis</code> 内部实现的复杂度大大降低，<code>Hash</code> 的惰性 <code>Rehash</code> 、<code>Lpush</code> 等等“线程不安全”的命令都可以无锁进行。</p>
<p><code>Redis</code> 抽象了一套AE事件模型，将 <code>IO</code> 事件和时间事件融入一起，同时借助epoll的回调特性，使得IO读写都是非阻塞的，实现高性能的网络处理能力。加上Redis基于内存的数据处理，这便是“单线程，但却高性能”的核心原因。</p>
<p><strong>但IO数据的读写依然是阻塞的，这也是Redis目前的主要性能瓶颈之一，特别是在数据吞吐量特别大的时候</strong></p>
<p>要知道，读写网络的 <code>read/write</code> 系统耗时远大于 <code>Redis</code> 运行执行耗时，<code>Redis</code> 的瓶颈主要在于<strong>网络的 IO 消耗</strong>, 优化主要有两个方向:</p>
<ol>
<li>提高网络 <code>IO</code> 性能，典型的实现比如使用 <code>DPDK</code> 来替代内核网络栈的方式 </li>
<li>使用<strong>多线程充分利用多核</strong>，典型的实现比如 <code>Memcached</code> 。</li>
</ol>
<p>协议栈优化的这种方式跟 <code>Redis</code> 关系不大，支持多线程是一种最有效最便捷的操作方式。所以 <code>Redis</code> 支持多线程主要就是两个原因：</p>
<ol>
<li>可以充分利用服务器 <code>CPU</code> 资源，目前主线程只能利用一个核</li>
<li>多线程任务可以分摊 <code>Redis</code> 同步 <code>IO</code> 读写负荷</li>
</ol>
<p><strong>注意事项如下：</strong></p>
<ol>
<li><code>Redis 6.0</code> 版本默认多线程是关闭的 <strong>io-threads-do-reads no</strong></li>
<li><code>Redis 6.0</code> 版本开启多线程后，线程数也要谨慎设置。</li>
<li>多线程可以使得性能翻倍，但是多线程只是用来处理网络数据的读写和协议解析，<strong>执行命令仍然是单线程顺序执行</strong>。</li>
</ol>
<p>核心思路是，将主线程的IO读写任务拆分出来给一组独立的线程执行，使得多个socket的读写可以并行化。（命令的执行依然是主线程串行执行）</p>
<p><strong>核心流程大概如下：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-4bd6569139472aaf4423540dd303e61a_720w.jpg" alt="img"></p>
<p><strong>流程简述如下：</strong></p>
<ul>
<li><p>主线程获取 <code>socket</code> 放入等待列表</p>
</li>
<li><p>将 <code>socket</code> 分配给各个 <code>IO</code> 线程</p>
</li>
<li><p>主线程阻塞等待 <code>IO</code> 线程读取 <code>socket</code> 完毕</p>
</li>
<li><p>主线程执行命令-<strong>单线程</strong></p>
</li>
<li><p>主线程阻塞等待 <code>IO</code> 线程将数据回写 <code>socket</code> 完毕</p>
</li>
<li><p>解除绑定，清空等待队列</p>
<p><img src="https://pic1.zhimg.com/80/v2-ae9a21e786e1a9366d49e6b65d41f8ec_720w.jpg" alt="img"></p>
</li>
</ul>
<p><strong>有如下特点：</strong></p>
<ul>
<li>IO线程要么同时在读 <code>socket</code> ，要么同时在写，<strong>不会同时读或写</strong></li>
<li>IO线程只负责读写 <code>socket</code> 解析命令，不负责命令处理</li>
<li>IO线程数可自行配置（目前代码限制上限为512，默认为1(关闭此功能)）</li>
</ul>
<h5><span id="开启多线程后是否会存在线程并发安全问题"><strong>开启多线程后，是否会存在线程并发安全问题？</strong></span></h5><p>从上面的实现机制可以看出，<code>Redis</code> 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 <code>key</code> 、<code>lua</code> 、事务，LPUSH/LPOP 等等的并发及线程安全问题。</p>
<h5><span id="redis60与memcached多线程模型对比"><strong>Redis6.0与Memcached多线程模型对比：</strong></span></h5><ul>
<li>相同点：都采用了 <code>maste-worker</code> 线程的模型</li>
<li>不同点：<code>Memcached</code> 执行主逻辑也是在 <code>worker</code> 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 <code>Redis</code> 把处理逻辑交还给 <code>master</code> 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</li>
</ul>
<hr>
<h3><span id="为什么redis用跳表不用红黑树">为什么redis用跳表不用红黑树</span></h3><ul>
<li>跳表范围查找比红黑树好</li>
<li>更好实现</li>
<li>并发状态下锁住的数据比红黑树少</li>
<li>动态更改的时候跳表要更改的数据少，红黑树则需要树化。更改更大</li>
</ul>
<p>跳表如果消耗内存过大，其实可以调节索引的稠密程度，稍微稀疏一点占用的内存就少了。</p>
<hr>
<h3><span id="为什么redis不用b树">为什么redis不用b+树</span></h3><ul>
<li>主要是 <code>redis</code> 经常在并发高的条件下使用，<code>b+</code> 树每次数据更改都需要树化，但是<strong>跳表锁定的数据很少，很适合并发分布式状态下使用</strong></li>
<li>B树，B+树：它们特点是一样的，是<strong>多路查找树</strong>，一般用于数据库系统中，为什么，因为它们分支多层数少， 都知道磁盘IO是非常耗时的，而像大量数据存储在磁盘中所以我们要有效的减少磁盘IO次数避免磁盘频繁的查找。 这是多路树的作用，在磁盘中减少io。但是它不适合在并发分布式下，尤其是动态更改数据强烈的状态下使用</li>
</ul>
<hr>
<h3><span id="redis的用途是什么">Redis的用途是什么？</span></h3><ul>
<li><strong>计数器</strong>： 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</li>
<li><strong>缓存</strong>：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</li>
<li><strong>会话缓存</strong>： 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</li>
<li><strong>全页缓存（FPC）</strong>：除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
<li><strong>查找表</strong>：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</li>
<li><strong>消息队列(发布/订阅功能)</strong>：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</li>
<li><strong>分布式锁实现</strong>：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</li>
<li><strong>其它</strong>：Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet可以实现有序性操作，从而实现排行榜等功能。</li>
</ul>
<hr>
<h3><span id="redis缓存常见问题">Redis缓存常见问题</span></h3><h4><span id="1-缓存雪崩">1. 缓存雪崩</span></h4><p><strong>雪崩定义：</strong></p>
<p><strong>Redis中大批量key</strong>在<strong>同一时间同时失效</strong>导致<strong>所有请求都打到了MySQL</strong>。而MySQL扛不住导致大面积崩塌。</p>
<p><strong>雪崩解决方案：</strong></p>
<ol>
<li>缓存数据的过期时间加上个随机值，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
</ol>
<h4><span id="2-缓存穿透">2. 缓存穿透</span></h4><p><strong>穿透定义：</strong></p>
<blockquote>
<p>缓存穿透 是 指缓存和数据库中 <code>都没有</code> 的数据，比如ID默认 &gt; 0，黑客一直 请求 <code>ID= -12</code> 的数据那么就会导致数据库压力过大，严重会击垮数据库。</p>
</blockquote>
<p><strong>穿透解决方案：</strong></p>
<ol>
<li>后端接口层增加用户<strong>鉴权校验</strong>，<strong>参数做校验</strong>等。</li>
<li>单个IP每秒访问次数超过阈值<strong>直接拉黑IP</strong>，关进小黑屋1天。</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将 <code>key-value</code> 对写为 <code>key-null</code> 失效时间可以为15秒<strong>防止恶意攻击</strong>。</li>
<li>用 <code>Redis</code> 提供的  <strong>Bloom Filter</strong> 特性也OK。</li>
</ol>
<h4><span id="3-缓存击穿">3. 缓存击穿</span></h4><p><strong>击穿定义：</strong></p>
<blockquote>
<p>现象：大并发集中对这一个热点key进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库。</p>
</blockquote>
<p><strong>击穿解决：</strong></p>
<blockquote>
<p>设置<strong>热点数据永远不过期</strong>，<strong>加上互斥锁也能搞定</strong>了</p>
</blockquote>
<h4><span id="4-双写一致性">4. 双写一致性</span></h4><p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9041659.html</a></p>
<p>读取数据如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdamw8TUnbbmoMOjiauAdVZPNLjkw0wfCbZN4h881rxz6QnJ5soxoXLvicGibbWicqiak2VewO05or9GHog/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>但是在<strong>更新缓存</strong>方面，对于更新完数据库，是更新缓存呢，还是删除缓存？又或者是先删除缓存，再更新数据库？其实大家存在很大的争议。</p>
<p><strong>双写</strong>：<code>缓存</code> 跟 <code>数据库</code> 均更新数据，如何保证数据一致性？</p>
<ol>
<li><h5><span id="先更新数据库再更新缓存有线程安全问题"><strong>先更新数据库，再更新缓存</strong>(<strong>×有线程安全问题</strong>)</span></h5><ol>
<li>安全问题：线程A更新数据库-&gt;线程B更新数据库-&gt;线程B更新缓存-&gt;线程A更新缓存。<code>导致脏读</code>。</li>
<li>业务场景：读多写少场景，频繁更新数据库而缓存根本没用。更何况如果缓存是叠加计算后结果更 <code>浪费性能</code>。</li>
</ol>
</li>
<li><h5><span id="先删缓存再更新数据库延时双删"><strong>先删缓存，再更新数据库(延时双删)</strong></span></h5><p>先删除缓存，再修改数据库。如果<strong>数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</strong></p>
<p>该方案会导致不一致的原因是：同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<p>（1）请求A进行写操作，删除缓存；</p>
<p>（2）请求B查询发现缓存不存在；</p>
<p>（3）请求B去数据库查询得到旧值；</p>
<p>（4）请求B将旧值写入缓存；</p>
<p>（5）请求A将新值写入数据库；</p>
<p>上述情况就会导致不一致的情形出现。而且，<strong>如果不采用给缓存设置过期时间策略，该数据永远都是脏数据</strong>。</p>
<p>那么，<strong>如何解决呢？采用延时双删策略</strong>！伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="built_in">string</span> key, Object data)</span> </span>&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先淘汰缓存；</li>
<li>再写数据库（这两步和原来一样）；</li>
<li><strong>休眠1秒，再次淘汰缓存；</strong></li>
</ol>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除！</p>
</li>
<li><h5><span id="先更新数据库再删缓存cache-aside-pattern"><strong>先更新数据库，再删缓存(Cache Aside Pattern)</strong></span></h5><p>因此 <strong>FackBook</strong> 提出了  <a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247486125&amp;idx=1&amp;sn=9a263b9bb7f1abdf249a0011e7996a5e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Cache Aside Pattern</a></p>
<ol>
<li>失效：应用程序先从 <code>cache</code> 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从 <code>cache</code> 中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ol>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<ol>
<li>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</li>
<li>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</li>
<li>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？</li>
<li>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，<strong>如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</strong></li>
<li>其实<strong>删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</strong>像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</li>
</ol>
</li>
</ol>
<hr>
<h4><span id="5-脑裂">5. 脑裂</span></h4><p><img src="https://img.php.cn/upload/image/149/923/673/1574231607982056.png" alt=""></p>
<p>脑裂是指因为<strong>网络原因</strong>，导致 <code>master</code> 节点、<code>slave</code> 节点 和 <code>sentinel(哨兵)</code> 集群处于<strong>不用的网络分区</strong>，此时因为 <code>sentinel(哨兵)</code> 集群<strong>无法通过心跳感知</strong>到 <code>master</code> 的存在，所以选举出来一个 <code>slave</code> 节点提升为 <code>master</code> 节点，此时存在两个不同的 <code>master</code> 节点就像一个大脑分裂成了两个。其实在 <code>Hadoop</code> 、<code>Spark</code> 集群中都会出现这样的情况，只是解决方法不同而已(用 <code>ZK</code> 配合强制杀死)。</p>
<p>集群脑裂问题中，如果客户端还在基于原来的 <code>master</code> 节点继续写入数据，那么新的 <code>master</code> 节点将无法同步这些数据，当网络问题解决后 <code>sentinel</code> 集群将原先的 <code>master</code> 节点降为 <code>slave</code> 节点，此时再从新的 <code>master</code> 中同步数据将造成大量的数据丢失。</p>
<h5><span id="redis处理方案是redis的配置文件中存在两个参数">Redis处理方案是redis的配置文件中存在两个参数</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-replicas-to-write <span class="number">3</span>  <span class="comment">//表示连接到master的最少slave数量(这个在我的redis里看是0啊)</span></span><br><span class="line">min-replicas-max-lag <span class="number">10</span>  <span class="comment">//表示slave连接到master的最大延迟时间</span></span><br></pre></td></tr></table></figure>
<p>按照上面的配置，要求至少 <code>3</code> 个 <code>slave</code> 节点，且数据复制和同步的延迟不能超过 <code>10</code> 秒。即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 <code>ACK</code> 确认了。这样一来，<code>min-replicas-to-write</code> 和 <code>min-replicas-max-lag</code> 的组合要求就无法得到满足，原主库就会被限制接收客户端请求，客户端也就不能在原主库中写入新数据了。那么 <code>master</code> 就会拒绝写请求，配置了这两个参数后，如果发生了集群脑裂，则原先的 <code>master</code> 节点<strong>接收到客户端的写入请求会拒绝就可以减少数据同步之后的数据丢失。</strong></p>
<hr>
<h3><span id="redis事务">Redis事务</span></h3><p>事务提供了一种将多个命令打包，然后一次性，有序地执行的机制。</p>
<p><code>Redis</code> 中的事务只要有如下三步：</p>
<ol>
<li><p><strong>开始事务：MULTI</strong></p>
</li>
<li><p><strong>命令入队：正常的插入命令</strong></p>
<ul>
<li><p>多个命令会被入队到事务队列中，然后按照FIFO的顺序执行、</p>
</li>
<li><p>事务在执行的过程中不会被打断，当事务队列中的所有命令都被执行完毕之后，事务才会结束</p>
</li>
<li><p><code>WATCH</code> 指令类似于<strong>乐观锁</strong>，在事务提交时，如果 <code>watch</code> 监控的多个 <code>KEY</code> 中任何 <code>KEY</code> 的值已经被其他客户端更改，则使用 <code>EXEC</code> 执行事务时，事务队列将不会被执行。WATCH指令会将客户端和被监视的键在数据库的 <code>watched_keys</code> 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 标志打开。</p>
<blockquote>
<p>悲观锁：顾名思义很悲观，每次去拿数据的时候都认为别人修改，所以每次在拿数据的时候都会上锁，这样如果中间有人想拿数据就会一直阻塞除非锁被释放获取到锁。<strong>传统的关系型数据库里，用到了很多种这种锁机制，比如行锁，表锁，写锁等</strong></p>
<p>乐观锁：顾名思义很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong></p>
</blockquote>
</li>
<li><p>1</p>
</li>
</ul>
</li>
<li><p><strong>执行事务：EXEC</strong></p>
</li>
</ol>
<ul>
<li><code>redis</code> 事务就是一次性、顺序性、排他性的执行一个队列中的<strong>一系列命令</strong>。　 </li>
<li><code>redis</code> 事务<strong>没有隔离级别</strong>的概念：批量操作在发送 <code>EXEC</code> 命令前被放入队列缓存，并不会被实际执行，也就<strong>不存在事务内的查询要看到事务里的更新，事务外查询不能看到</strong>。</li>
<li><code>redis</code> <strong>不保证原子性</strong>：<code>redis</code> 中<strong>单条命令是原子性执行的</strong>，但<strong>事务不保证原子性</strong>。Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</li>
<li>事务可以理解为一个打包的批量执行脚本，但<strong>批量指令并非原子化的操作</strong>，<strong>中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做</strong>。</li>
<li><code>redis</code> 编译型错误事务中所有代码均不执行，指令使用错误。运行时异常是错误命令导致异常，其他命令可正常执行。</li>
</ul>
<hr>
<h3><span id="redis正确开发步骤">Redis正确开发步骤</span></h3><ul>
<li><code>上线前</code>：<code>redis</code> <strong>高可用</strong>，主从+哨兵，<code>redis cluster</code>，避免全盘崩溃。</li>
<li><code>上线时</code>：本地 <code>ehcache</code> 缓存 + <code>Hystrix</code> 限流 + 降级，避免 <code>MySQL</code> 扛不住。</li>
<li><code>上线后</code>：<code>redis</code> <strong>持久化</strong>采用 <code>RDB + AOF</code> 来保证断点后自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<hr>
<h3><span id="redis-key的3种过期删除策略">Redis key的3种过期删除策略</span></h3><p><strong>《redis P107》</strong></p>
<ol>
<li><h4><span id="惰性删除被动-expireifneeded"><strong>惰性删除(被动)  expireIfNeeded()</strong>：</span></h4><ul>
<li>当读/写一个已经过期的 <code>key</code> 时，会触发<strong>惰性删除策略</strong>，直接删除掉这个过期 <code>key</code> 。</li>
<li><strong>对CPU时间最友好</strong>：程序只会在取出键时才对键进行过期检查，不会浪费CPU时间。</li>
<li><strong>对内存最不友好</strong>：如果一个键已经过期，它所占用的内存会一直不被释放，有内存泄露的危险。</li>
</ul>
</li>
<li><h4><span id="定期删除主动-activeexpirecycle"><strong>定期删除(主动) </strong> <strong>activeExpireCycle()</strong>：</span></h4><ul>
<li>由于惰性删除策略无法保证<strong>冷数据</strong>被及时删掉，所以 <code>redis</code> 会定期主动淘汰一批已过期的 <code>key</code> 。每隔一段时间，程序都对数据库进行一次检查，删除里面的过期键，至于要删除多少个过期键，要检查多少数据库，是由算法决定的</li>
<li>是惰性删除和定时删除的折中</li>
<li>难点是如何确定删除操作执行的时长和频率</li>
<li>每当 <code>redis</code> 的服务器周期性操作 <code>serverCron</code> 函数执行时，<strong>activeExpireCycle()</strong>函数会在规定时间内分多次遍历服务器中的各个数据库(用 <code>current_db</code> 变量记录遍历过的数据库)，<strong>从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键</strong>。</li>
<li>通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 <code>CPU</code> 和内存资源<strong>达到最优</strong>的平衡效果。</li>
<li><code>expires</code> 字典会保存所有设置了过期时间的 <code>key</code> 的过期时间数据，其中 <code>key</code> 是指向键空间中的某个键的指针，<code>value</code> 是该键的毫秒精度的 <code>UNIX</code> 时间戳表示的过期时间。键空间是指该 <code>redis</code> 集群中保存的所有键。</li>
</ul>
</li>
<li><h4><span id="定时删除主动"><strong>定时删除(主动)</strong>：</span></h4><ul>
<li>在设置键的过期时间的同时，创建一个定时器 <code>Timer</code> ，让定时器在键的过期时间来临时，立刻执行对键的删除操作。</li>
<li><strong>对CPU时间最不友好</strong>：在过期键比较多的情况下，删除键的行为可能占用很多 <code>CPU</code> 时间。创建一个 <code>Timer</code> 需要用到无序链表实现的<strong>时间事件</strong>，查找一个事件的时间复杂度为 <code>O(N)</code> ，很慢。</li>
<li><strong>对内存最友好</strong>：可以保证过期键尽可能快地被删除，并释放过期键所产生的内存。</li>
</ul>
</li>
</ol>
<p><strong>Redis采用的过期策略：<code>惰性删除</code> + <code>定期删除</code>。memcached采用的过期策略：<code>惰性删除</code>。</strong></p>
<hr>
<h3><span id="redis的6种内存淘汰策略">Redis的6种内存淘汰策略</span></h3><p><code>Redis</code> 的内存淘汰策略是指<strong>在Redis的用于缓存的内存不足</strong>时，怎么<strong>处理需要新写入且需要申请额外空间的数据</strong>。</p>
<ul>
<li><p><strong>volatile-lru：</strong></p>
<ul>
<li>从<strong>已设置过期时间的数据集</strong>（server.db[i].expires）中挑选 <strong>最近最少使用</strong> 的数据淘汰 </li>
</ul>
</li>
<li><p><strong>volatile-ttl：</strong></p>
<ul>
<li>从<strong>已设置过期时间的数据集</strong>（server.db[i].expires）中挑选 <strong>将要过期</strong> 的数据淘汰 </li>
</ul>
</li>
<li><p><strong>volatile-random：</strong></p>
<ul>
<li>从<strong>已设置过期时间的数据集</strong>（server.db[i].expires）中 <strong>任意选择</strong> 数据淘汰 </li>
</ul>
</li>
<li><p><strong>allkeys-lru：</strong></p>
<ul>
<li>从数据集（server.db[i].dict）中挑选 <strong>最近最少使用</strong> 的数据淘汰 </li>
</ul>
</li>
<li><p><strong>allkeys-random：</strong></p>
<ul>
<li>从数据集（server.db[i].dict）中 <strong>任意选择数</strong> 据淘汰</li>
</ul>
</li>
<li><p><strong>no-enviction（驱逐）：</strong></p>
<ul>
<li>禁止驱逐数据，<strong>不删除</strong>的意思。</li>
</ul>
</li>
</ul>
<hr>
<h3><span id="redis实现分布式锁">Redis实现分布式锁</span></h3><p><strong>实现分布式锁要满足3点：多进程可见，互斥，可重入。</strong></p>
<p>本身原理也比较简单，<code>redis</code> 自身就是一个<strong>单线程处理器</strong>，具备<strong>互斥</strong>的特性，通过<strong>setNX</strong>，<strong>exist</strong>等命令就可以完成简单的分布式锁，处理好超时释放锁的逻辑即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                <span class="meta"># job 不存在</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis&gt; SETNX job <span class="string">"programmer"</span>    <span class="meta"># job 设置成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; SETNX job <span class="string">"code-farmer"</span>   # 尝试覆盖 job ，失败</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis&gt; GET job                   # 没有被覆盖</span><br><span class="line"><span class="string">"programmer"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>SETNX</strong></p>
<ul>
<li><p><code>SETNX</code> 是 <code>SET if Not eXists</code> 的简写，日常指令是 <code>SETNX key value</code>，如果 <code>key</code> 不存在则 <code>set</code> 成功返回 <code>1</code>，如果这个 <code>key</code> 已经存在了返回 <code>0</code> 。</p>
</li>
<li><p>通过 <code>SETNX</code> 可以完成实现不同客户端之间的排他性访问。不过也会有问题，如果一个客户端获取锁之后挂掉了，那么这个锁就不会被释放，其他客户端都不能再获取这个锁了，所以需要给每个锁设置一个时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETNX job <span class="string">"programmer"</span>  </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; EXPIRE job <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>SETEX(SETNX+EXPIRE)</strong></p>
<p><code>SETEX key seconds value</code> 表达的意思是 将值 <code>value</code> 关联到 <code>key</code> ，并将 <code>key</code> 的生存时间设为多少秒。如果 <code>key</code> 已经存在，<code>setex</code> 命令将覆盖旧值。并且 <code>setex</code> 是一个 <code>原子性</code> (atomic)操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET job <span class="string">"programmer"</span> NX EX <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>加锁</strong></p>
<p>一般就是用一个标识唯一性的字符串比如 <code>UUID</code> 配合 <code>SETNX</code> 实现加锁。</p>
</li>
<li><p><strong>解锁</strong></p>
<p>解锁用到了 <code>LUA</code> 脚本，<code>LUA</code> 是可以保证是<strong>原子性</strong>的，思路就是判断一下 <code>Key</code> 和入参是否相等，是的话就删除，返回成功 <code>1</code> ，<code>0</code> 就是失败。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">'get'</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">'del'</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缺点</strong></p>
<p>这个锁是<strong>无法重入的</strong>，且自己实现的话各种边边角角都要考虑到，所以了解个大致思路流程即可，<strong>工程化还是用开源工具包就行</strong>。</p>
</li>
<li><p><strong>与事务的对比</strong></p>
<ul>
<li>分布式锁最大的优点是，更加灵活，粒度更小：<strong>事务功能只能对某个键进行加锁</strong>，但是<strong>分布式锁可以对键中的数据进行加锁</strong>：比如，分布式锁可以单独对哈希表中的某个键值对加锁，但是事务只能对整个哈希表进行加锁。</li>
<li><strong>分布式锁比起事务有明显的优势</strong>。因为锁的更加灵活，可以<strong>锁住粒度更小的键值</strong>，<strong>减少大量的访问冲突和重试</strong>，所以效率远远高于事务。且这种优势会<strong>随着哈希键内部的键值对的增多</strong>，<strong>访问客户端数量的增多而越来越大</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>C++实现</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getLock</span><span class="params">(redisContext* conn, <span class="built_in">string</span>&amp; name, <span class="keyword">char</span>* uuid_buff, <span class="keyword">int</span> get_timeout = <span class="number">10</span>, <span class="keyword">int</span> lock_timeout = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uuid_t</span> uuid;</span><br><span class="line">	uuid_generate_random(uuid);<span class="comment">//生成唯一标识符</span></span><br><span class="line">	uuid_unparse(uuid, uuid_buff);<span class="comment">//将标识符转化为字符串</span></span><br><span class="line">	<span class="built_in">string</span> lockname = <span class="string">"lock:"</span> + name;<span class="comment">//得到锁的名字</span></span><br><span class="line">	<span class="keyword">time_t</span> end = time(<span class="literal">NULL</span>) + get_timeout;<span class="comment">//超过end未获取到锁就放弃</span></span><br><span class="line">	<span class="keyword">while</span> (time(<span class="literal">NULL</span>) &lt; end)<span class="comment">//尝试获取锁</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		redisReply* reply = (redisReply*)redisCommand(conn, <span class="string">"SET %s %s NX EX %d"</span>, lockname.data(), uuid_buff, lock_timeout);<span class="comment">//尝试加锁</span></span><br><span class="line">		<span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; <span class="built_in">strcmp</span>(reply-&gt;str, <span class="string">"OK"</span>)==<span class="number">0</span>)<span class="comment">//加锁成功返回</span></span><br><span class="line">		&#123;</span><br><span class="line">			freeReplyObject(reply);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//加锁失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			freeReplyObject(reply);</span><br><span class="line">			reply = (redisReply*)redisCommand(conn, <span class="string">"TTL %s"</span>, lockname.data());<span class="comment">//查看锁的剩余时间</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_INTEGER &amp;&amp; reply-&gt;integer == <span class="number">-1</span>)<span class="comment">//如果锁没有设置超时时间，为它设置一个超时时间</span></span><br><span class="line">			&#123;</span><br><span class="line">				redisCommand(conn, <span class="string">"EXPIRE %s %d"</span>, lockname, lock_timeout);</span><br><span class="line">			&#125;</span><br><span class="line">			freeReplyObject(reply);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">releaseLock</span><span class="params">(redisContext* conn, <span class="built_in">string</span>&amp; name, <span class="keyword">char</span>* uuid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> lockname = <span class="string">"lock:"</span> + name;<span class="comment">//获取锁的名字</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		freeReplyObject(redisCommand(conn, <span class="string">"WATCH %s"</span>, lockname.data()));<span class="comment">//监视锁，防止删除过程中锁已经被别的客户端获取了</span></span><br><span class="line">		redisReply* reply = (redisReply*)redisCommand(conn, <span class="string">"GET %s"</span>,lockname.data());</span><br><span class="line">		<span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_STRING &amp;&amp; <span class="built_in">strcmp</span>(reply-&gt;str, uuid) == <span class="number">0</span>)<span class="comment">//查看锁的uuid，以验证是否是属于自己的锁</span></span><br><span class="line">		&#123;</span><br><span class="line">			redisAppendCommand(conn, <span class="string">"MULTI"</span>);<span class="comment">//将命令打包</span></span><br><span class="line">			redisAppendCommand(conn, <span class="string">"DEL %s"</span>, lockname.data());</span><br><span class="line">			redisAppendCommand(conn, <span class="string">"EXEC"</span>);</span><br><span class="line">			redisGetReply(conn, (<span class="keyword">void</span>**)&amp;reply);</span><br><span class="line">			freeReplyObject(reply);</span><br><span class="line">			redisGetReply(conn, (<span class="keyword">void</span>**)&amp;reply);</span><br><span class="line">			freeReplyObject(reply);</span><br><span class="line">			redisGetReply(conn, (<span class="keyword">void</span>**)&amp;reply);</span><br><span class="line">			<span class="keyword">if</span> (reply-&gt;type!=REDIS_REPLY_NIL)<span class="comment">//如果返回不为nil，删除成功</span></span><br><span class="line">			&#123;</span><br><span class="line">				freeReplyObject(reply);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//删除过程中锁状态发生了改变，尝试重新删除</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		freeReplyObject(redisCommand(conn, <span class="string">"UNWATCH"</span>, lockname.data()));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="redis相比memcached有哪些优势">Redis相比memcached有哪些优势</span></h3><ul>
<li><code>memcached</code> 所有的值均是简单的字符串，<code>redis</code> 作为其替代者，支持更为丰富的数据类型</li>
<li><code>redis</code> 的速度比 <code>memcached</code> 快很多</li>
<li><code>redis</code> 可以持久化其数据</li>
</ul>
<hr>
<h3><span id="redis-限流">Redis 限流</span></h3><p>在开发高并发系统时，有三把利器用来保护系统：<code>缓存</code>、<code>降级</code> 和 <code>限流</code>。那么何为限流呢？顾名思义，限流就是限制流量，就像你宽带包了1个G的流量，用完了就没了。通过限流，我们可以很好地控制系统的 <code>qps</code> ，从而达到保护系统的目的。</p>
<h4><span id="基于redis的setnx-zset">基于Redis的setnx、zset</span></h4><h5><span id="1-setnx">1. setnx</span></h5><p>比如我们需要在10秒内限定20个请求，那么我们在 <code>setnx</code> 的时候可以设置过期时间 <code>10</code> ，当请求的setnx数量达到 <code>20</code> 时候即达到了限流效果。</p>
<p><strong>缺点</strong>：比如当统计 <code>1-10秒</code> 的时候，无法统计 <code>2-11秒</code> 之内，如果需要统计 <code>N</code> 秒内的 <code>M</code> 个请求，那么我们的 <code>Redis</code> 中<strong>需要保持N个key等等问题</strong>。</p>
<h5><span id="2-zset">2. zset</span></h5><p>其实限流涉及的最主要的就是<strong>滑动窗口</strong>，上面也提到 <code>1-10</code> 怎么变成 <code>2-11</code> 。其实也就是起始值和末端值都各 <code>+1</code> 即可。我们可以将请求打造成一个<strong>zset数组</strong>，当每一次请求进来的时候，<code>value</code> 保持唯一，可以用 <code>UUID</code> 生成，而 <code>score</code> 可以用当前时间戳表示，因为 <code>score</code> 我们可以用来计算<strong>当前时间戳之内有多少的请求数量</strong>。而 <code>zset</code> 数据结构也提供了<strong>range</strong>方法让我们可以很轻易的获取到 <code>2</code> 个时间戳内有多少请求，</p>
<p><strong>缺点</strong>：就是 <code>zset</code> 的数据结构会越来越大。</p>
<h4><span id="漏桶算法">漏桶算法</span></h4><p>漏桶算法思路：把水比作是请求，漏桶比作是系统处理能力极限，水先进入到漏桶里，漏桶里的水<strong>按一定速率流出</strong>，当流出的速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicxvnHbjoxtZoGYfnoH2GhkHBVTJtLGRgDgxcqgriaPkpIT1aST3gLaEA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4><span id="令牌桶算法">令牌桶算法</span></h4><p>令牌桶算法的原理：可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRicNjicWnydjDCHISvBzjmXnHQLke08tYjVWa6xR2tiazNzJ5ImqXCguHfQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4><span id="细节流程大致">细节流程大致：</span></h4><ol>
<li><p>所有的请求在处理之前都需要<strong>拿到一个可用的令牌才会被处理</strong>。</p>
</li>
<li><p>根据限流大小，设置按照一定的速率往<strong>桶里添加令牌</strong>。</p>
</li>
<li><p>设置<strong>桶最大可容纳值</strong>，当桶满时新添加的令牌就被丢弃或者拒绝。</p>
</li>
<li><p>请求达到后首先要获取令牌桶中的令牌，<strong>拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除。</strong></p>
</li>
<li><p><strong>令牌桶有最低限额</strong>，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。</p>
</li>
</ol>
<hr>
<h3><span id="常见知识点">常见知识点</span></h3><ol>
<li>字符串模糊查询时用 <code>Keys</code> 可能导致线程阻塞，尽量用 <code>scan</code> 指令进行无阻塞的取出数据然后去重下即可。</li>
<li>多个操作的情况下记得用 <code>pipeLine</code> 把所有的命令一次发过去，避免频繁的发送、接收带来的网络开销，提升性能。</li>
<li><code>bigkeys</code> 可以扫描 <code>redis</code> 中的 <code>大key</code> ，底层是使用 <code>scan</code> 命令去遍历所有的键，对每个键根据其类型执行STRLEN、LLEN、SCARD、HLEN、ZCARD这些命令获取其长度或者元素个数。缺陷是线上试用并且个数多不一定空间大，</li>
<li>线上应用记得开启Redis慢查询日志哦，基本思路跟MySQL类似。</li>
<li><code>Redis</code> 中因为内存分配策略跟增删数据是会导致<code>内存碎片</code>，你可以重启服务也可以执行<code>activedefrag yes</code>进行内存重新整理来解决此问题。<img src="https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRiceatj5q5PgGsbibicbVvxBaSDAibL1DVYU1stK0kcQOMibEmB98llI7fhyg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></li>
</ol>
<blockquote>
<p>1、Ratio &gt;1 表明有内存碎片，越大表明越多严重。</p>
<p>2、Ratio &lt; 1 表明正在使用虚拟内存，虚拟内存其实就是硬盘，性能比内存低得多，这是应该增强机器的内存以提高性能。</p>
<p>3、一般来说，mem_fragmentation_ratio的数值在1 ~ 1.5之间是比较健康的</p>
</blockquote>
<hr>
<h3><span id="redis一次性获取多条消息的命令">redis一次性获取多条消息的命令</span></h3><p>mget,pipeline,lua</p>
<hr>
<h3><span id="为什么redis集群的最大槽数是16384个">为什么redis集群的最大槽数是16384个？</span></h3><p>Redis 集群并没有使用 <code>一致性hash</code> ，而是引入了<strong>哈希槽</strong>的概念。Redis 集群有 <code>16384</code> 个哈希槽，每个 <code>key</code> 通过 <code>CRC16</code> 校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分 <code>hash</code> 槽。但为什么哈希槽的数量是16384（$2^{14}​$）个呢？</p>
<p>在Redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用<code>char</code>进行 <code>bitmap</code> 压缩后是2k（<code>2 * 8 (8 bit) * 1024(1k) = 16K</code>），也就是说使用2k的空间创建了16k的槽数。</p>
<p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（<code>8 * 8 (8 bit) * 1024(1k) =65K</code>），也就是说需要需要8k的心跳包，作者认为这样做不太值得；redis的集群主节点数量基本不可能超过1000个。<br>如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p>
<h3><span id="redis如果一个key特别大怎么办">redis如果一个key特别大怎么办</span></h3><p><img src="https://img2020.cnblogs.com/blog/740516/202009/740516-20200902230544013-1122873010.png" alt="img"></p>
<p><strong>bigkey</strong>是指当Redis 的字符串类型过大，非字符串类型元素过多。Redis 可以在执行 <strong>redis-cli</strong> 命令时带上 <strong>–bigkeys</strong> 选项，进而对整个数据库中的键值对大小情况进行统计分析。</p>
<h4><span id="bigkey-带来了什么危害">bigkey 带来了什么危害？</span></h4><ol>
<li><strong>Redis 阻塞</strong> ：因为 Redis 单线程特性，如果操作某个 <code>bigkey</code> 耗时比较久，则后面的请求会被阻塞。</li>
<li><strong>内存空间不均匀</strong> ：比如在 <code>Redis cluster</code> 或者 <code>codis</code> 中，会造成节点的内存使用不均匀。</li>
<li><strong>过期时可能阻塞 ：如果 <code>bigkey</code> 设置了过期时间，当过期后，这个 <code>key</code> 会被删除，假如没有使用 Redis 4.0 的</strong>过期异步删除**，就会存在阻塞 Redis 的可能性，并且慢查询中查不到（因为这个删除是内部循环事件）。</li>
<li><strong>导致倾斜</strong> ：某个实例上正好保存了 <code>bigkey</code>。<code>bigkey</code> 的 value 值很大（String 类型），或者是 <code>bigkey</code> 保存了大量集合元素（集合类型），会导致这个实例的数据量增加，内存资源消耗也相应增加。实例的处理压力就会增大，速度变慢，甚至还可能会引起这个实例的内存资源耗尽，从而崩溃。</li>
</ol>
<h4><span id="lazyfree机制过期异步删除">lazyfree机制(过期异步删除)</span></h4><p>Lazyfree的原理是在删除的时候只进行逻辑删除，把key释放操作放在bio(Background I/O)单独的子线程处理中，减少删除大key对redis主线程的阻塞，有效地避免因删除大key带来的性能问题。在此提一下bio线程，很多人把Redis通常理解为单线程内存数据库, 其实不然。Redis将最主要的网络收发和执行命令等操作都放在了主工作线程，然而除此之外还有几个bio后台线程，从源码中可以看到有处理关闭文件和刷盘的后台线程，以及Redis4.0新增加的lazyfree线程。</p>
<h4><span id="怎么处理">怎么处理</span></h4><h5><span id="删除bigkey">删除bigkey</span></h5><h5><span id="拆分bigkey">拆分bigkey</span></h5><p>对于需要整取 value 的 大 key, 可以尝试将对象分拆成几个 key-value， 使用 multiGet 获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个实例中，降低对单个实例的IO影响;</p>
<p>对于每次需要取部分 value 的 大 key, 同样可以拆成几个 key-value，也可以将这些存储在一个 hash 中，每个 field 代表具体属性，使用 hget，hmget 来获取部分 value，使用 hset，hmset 来更新部分属性;</p>
<hr>
<h3><span id="如何保证数据库和redis的数据一致性先更新数据库再删除缓存先删除缓存再更新数据库这两个方法分别存在什么问题">如何保证数据库和Redis的数据一致性？先更新数据库再删除缓存/先删除缓存再更新数据库这两个方法分别存在什么问题？</span></h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/28/数据库总结/" rel="next" title="数据库总结">
                <i class="fa fa-chevron-left"></i> 数据库总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/05/字节跳动面试题：36进制加法/" rel="prev" title="字节跳动面试题：36进制加法">
                字节跳动面试题：36进制加法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="陈琦">
            
              <p class="site-author-name" itemprop="name">陈琦</p>
              <p class="site-description motion-element" itemprop="description">图像处理/深度学习@SJTU</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">345</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenqi1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="chen-qi1997@sjtu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/chenqi1997" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.</span> <span class="nav-text">Redis常用的五种数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">string字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">list列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">set集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">sorted set(Zset)有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.4.1.</span> <span class="nav-text">ZSet中跳表的实现细节</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">hash哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.5.1.</span> <span class="nav-text">dictEntry：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.5.2.</span> <span class="nav-text">dictht：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.5.3.</span> <span class="nav-text">dict</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.5.4.</span> <span class="nav-text">渐进式扩容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.5.5.</span> <span class="nav-text">map的扩容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.6.</span> <span class="nav-text">Redis Geo Hash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.7.</span> <span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.8.</span> <span class="nav-text">Bitmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.1.9.</span> <span class="nav-text">Bloom Filter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.2.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">RDB(Redis DataBase) 半持久化模式/Snapshotting快照</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.2.1.1.</span> <span class="nav-text">手动触发以及CopyOnWrite</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">AOF(Append-only file) 全持久化模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.2.2.1.</span> <span class="nav-text">AOF整个流程分两步：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.</span> <span class="nav-text">Redis架构模式/集群高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">1. 单机版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">2. 主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.2.1.</span> <span class="nav-text">全量同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.2.2.</span> <span class="nav-text">增量同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.2.3.</span> <span class="nav-text">Redis主从同步策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">3. 哨兵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.3.1.</span> <span class="nav-text">三个特性：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">4. 集群(proxy型)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.5.</span> <span class="nav-text">5. 集群(直连型)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.5.1.</span> <span class="nav-text">分区规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.5.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.3.5.3.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.4.</span> <span class="nav-text">Redis 限流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">基于Redis的setnx、zset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">漏桶算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">令牌桶算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.5.</span> <span class="nav-text">Redis是单线程的，但Redis为什么这么快？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">基于内存实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">高效的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">合理的数据编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">合适的线程模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.6.</span> <span class="nav-text">Redis6.0后引入多线程提速</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.6.0.1.</span> <span class="nav-text">开启多线程后，是否会存在线程并发安全问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.6.0.2.</span> <span class="nav-text">Redis6.0与Memcached多线程模型对比：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.7.</span> <span class="nav-text">为什么redis用跳表不用红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.8.</span> <span class="nav-text">为什么redis不用b+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.9.</span> <span class="nav-text">Redis的用途是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.</span> <span class="nav-text">Redis缓存常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.1.</span> <span class="nav-text">1. 缓存雪崩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.2.</span> <span class="nav-text">2. 缓存穿透</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.3.</span> <span class="nav-text">3. 缓存击穿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.4.</span> <span class="nav-text">4. 双写一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.4.1.</span> <span class="nav-text">先更新数据库，再更新缓存(×有线程安全问题)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.4.2.</span> <span class="nav-text">先删缓存，再更新数据库(延时双删)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.4.3.</span> <span class="nav-text">先更新数据库，再删缓存(Cache Aside Pattern)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.5.</span> <span class="nav-text">5. 脑裂</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.10.5.1.</span> <span class="nav-text">Redis处理方案是redis的配置文件中存在两个参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.11.</span> <span class="nav-text">Redis事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.12.</span> <span class="nav-text">Redis正确开发步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.13.</span> <span class="nav-text">Redis key的3种过期删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.13.1.</span> <span class="nav-text">惰性删除(被动)  expireIfNeeded()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.13.2.</span> <span class="nav-text">定期删除(主动)  activeExpireCycle()：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.13.3.</span> <span class="nav-text">定时删除(主动)：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.14.</span> <span class="nav-text">Redis的6种内存淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.15.</span> <span class="nav-text">Redis实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.16.</span> <span class="nav-text">Redis相比memcached有哪些优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.17.</span> <span class="nav-text">Redis 限流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.17.1.</span> <span class="nav-text">基于Redis的setnx、zset</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.17.1.1.</span> <span class="nav-text">1. setnx</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.17.1.2.</span> <span class="nav-text">2. zset</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.17.2.</span> <span class="nav-text">漏桶算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.17.3.</span> <span class="nav-text">令牌桶算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.17.4.</span> <span class="nav-text">细节流程大致：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.18.</span> <span class="nav-text">常见知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.19.</span> <span class="nav-text">redis一次性获取多条消息的命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.20.</span> <span class="nav-text">为什么redis集群的最大槽数是16384个？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.21.</span> <span class="nav-text">redis如果一个key特别大怎么办</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.21.1.</span> <span class="nav-text">bigkey 带来了什么危害？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.21.2.</span> <span class="nav-text">lazyfree机制(过期异步删除)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.21.3.</span> <span class="nav-text">怎么处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.21.3.1.</span> <span class="nav-text">删除bigkey</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.21.3.2.</span> <span class="nav-text">拆分bigkey</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.0.22.</span> <span class="nav-text">如何保证数据库和Redis的数据一致性？先更新数据库再删除缓存/先删除缓存再更新数据库这两个方法分别存在什么问题？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈琦</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
